<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Handbuch zur Schulung &raquo;Einf&uuml;hrung in C&laquo;</TITLE>
<!-- Begin Header Records  ========================================== -->
<!-- d:\doku\creferenz\refer.scr converted by B2h R4.3 (362) (WIN95)  -->
<!-- on 25 Feb 2000 at 10:56:54                                       -->
<META HTTP-EQUIV="updated" CONTENT="Wed, 23 Feb 2000 10:24:36">
<META HTTP-EQUIV="review" CONTENT="Fri, 23 Feb 2001 10:24:36">
<META HTTP-EQUIV="expires" CONTENT="Sat, 23 Feb 2002 10:24:36">
</HEAD><BODY>
<!-- End Header Records  ============================================ -->
<A NAME="Top_Of_Page"></A>
<H1>Handbuch zur Schulung &raquo;Einf&uuml;hrung in C&laquo;</H1>
<B>Handbuch zur Schulung</B><BR>
<B>&raquo;Einf&uuml;hrung in C&laquo;</B><BR>
<P>Sascha Kliche
<P>
IBM Deutschland Informationssysteme GmbH<BR>
<P><BR>
PL Ausbildung Berlin<BR>
Kst. 1190<BR>
Geb. 12277-05<BR>
<P>Februar 2000
<P>Ausgabe 7.2
<HR><H1><A NAME="Header_1" HREF="&b2htoc_1">Vorwort</A></H1>
<P>Dieses Handbuch wurde als Begleitmaterial zu einer Einf&uuml;hrungsschulung
in die Programmiersprache C entwickelt. Die erste Fassung entstand im
September 1994 in Zusammenarbeit mit Daniel Matthies im Rahmen einer
Praxisphase in der BAB Hannover. Eine stark &uuml;berarbeitete Fassung
entstand im Juni 1997 und enthielt neben Fehlerbereinigungen
einige neue Kapitel und Abschnitte. Die vorliegende Fassung wurde
seitdem ebenfalls um einige Abschnitte erweitert und korrigiert.
<P>
<P>
<P>
Berlin, Februar 2000
<P>
Sascha Kliche
<HR><H1><A NAME="ToC">Inhaltsverzeichnis</A></H1>
<MENU>
<P><B><LI><A NAME="ToC_1" HREF="#Header_1">Vorwort</A></B>
<P><B><LI><A NAME="ToC_2" HREF="#HDRTLIST_START">Tabellen</A></B>
<P><B><LI><A NAME="ToC_3" HREF="#HDRFIGLIST_START">Abbildungen</A></B>
<P><B><LI><A NAME="ToC_4" HREF="#HDREINLEIT">1.0 Einleitung</A></B>
<MENU>
<LI><A NAME="ToC_5" HREF="#Header_5">1.1 Konventionen</A>
<LI><A NAME="ToC_6" HREF="#HDRDUMMY">1.2 Aufbau des Handbuches</A>
<LI><A NAME="ToC_7" HREF="#Header_7">1.3 Historie von C</A>
<LI><A NAME="ToC_8" HREF="#Header_8">1.4 Vom Quellcode zum lauff&auml;higen Programm</A>
<LI><A NAME="ToC_9" HREF="#Header_9">1.5 Argumente f&uuml;r den Einsatz der Sprache C</A>
</MENU>
<P><B><LI><A NAME="ToC_10" HREF="#HDRGRUND">2.0 Grundlagen der C Programmierung</A></B>
<MENU>
<LI><A NAME="ToC_11" HREF="#Header_11">2.1 Zeichensatz</A>
<LI><A NAME="ToC_12" HREF="#Header_12">2.2 Gro&szlig;- und Kleinschreibung</A>
<LI><A NAME="ToC_13" HREF="#HDRKEY">2.3 Schl&uuml;sselworte</A>
<LI><A NAME="ToC_14" HREF="#Header_14">2.4 Formale Grundstruktur</A>
<MENU>
<LI><A NAME="ToC_15" HREF="#HDRCOMMENT">2.4.1 Der Einsatz von Kommentaren</A>
<LI><A NAME="ToC_18" HREF="#Header_18">2.4.2 Formatierung</A>
</MENU>
<LI><A NAME="ToC_19" HREF="#Header_19">2.5 Ausdr&uuml;cke</A>
<LI><A NAME="ToC_20" HREF="#Header_20">2.6 Operatoren</A>
<MENU>
<LI><A NAME="ToC_21" HREF="#Header_21">2.6.1 Arithmetische Operatoren</A>
<LI><A NAME="ToC_22" HREF="#Header_22">2.6.2 Un&auml;re oder monadische Operatoren</A>
<LI><A NAME="ToC_23" HREF="#HDRVEROP">2.6.3 Vergleichende Operatoren</A>
<LI><A NAME="ToC_24" HREF="#Header_24">2.6.4 Logische Operatoren</A>
<LI><A NAME="ToC_25" HREF="#Header_25">2.6.5 Zusammengesetzte Zuweisungsoperatoren</A>
<LI><A NAME="ToC_26" HREF="#HDRHIERAR">2.6.6 Hierarchie der Operatoren</A>
<LI><A NAME="ToC_27" HREF="#Header_27">2.6.7 Beispiele zur Verkn&uuml;pfung der Operatoren</A>
</MENU>
<LI><A NAME="ToC_28" HREF="#HDRBEZEI">2.7 Bezeichner</A>
</MENU>
<P><B><LI><A NAME="ToC_29" HREF="#HDRTYPEN">3.0 Datentypen</A></B>
<MENU>
<LI><A NAME="ToC_30" HREF="#Header_30">3.1 Einfache Datentypen</A>
<MENU>
<LI><A NAME="ToC_31" HREF="#HDRINT">3.1.1 Ganze Zahlen - Integer</A>
<LI><A NAME="ToC_36" HREF="#HDRRAT">3.1.2 Rationale Zahlen</A>
<LI><A NAME="ToC_41" HREF="#HDRCHAR">3.1.3 Textzeichen - char</A>
</MENU>
<LI><A NAME="ToC_43" HREF="#Header_43">3.2 H&ouml;here Datenstrukturen</A>
<MENU>
<LI><A NAME="ToC_44" HREF="#HDRFELD">3.2.1 Felder - Array - Vektoren</A>
<LI><A NAME="ToC_50" HREF="#HDRSTRUKT">3.2.2 Strukturen</A>
<LI><A NAME="ToC_56" HREF="#HDRUNION">3.2.3 Unions</A>
<LI><A NAME="ToC_57" HREF="#HDRZEI">3.2.4 Zeiger - Pointer</A>
</MENU>
<LI><A NAME="ToC_61" HREF="#Header_61">3.3 Weitere Datentypen</A>
<MENU>
<LI><A NAME="ToC_62" HREF="#HDRVOID">3.3.1 void</A>
<LI><A NAME="ToC_63" HREF="#HDRENUM">3.3.2 enum</A>
</MENU>
<LI><A NAME="ToC_64" HREF="#Header_64">3.4 Datentypumwandlung</A>
<MENU>
<LI><A NAME="ToC_65" HREF="#Header_65">3.4.1 Implizite Datentypumwandlung</A>
<LI><A NAME="ToC_66" HREF="#Header_66">3.4.2 Explizite Datentypumwandlung</A>
</MENU>
<LI><A NAME="ToC_67" HREF="#HDROWNTYPE">3.5 Eigene Typen - typedef</A>
<LI><A NAME="ToC_68" HREF="#HDRCLASSES">3.6 Speicherklassen</A>
<MENU>
<LI><A NAME="ToC_69" HREF="#Header_69">3.6.1 Automatic</A>
<LI><A NAME="ToC_70" HREF="#HDRSTATIC">3.6.2 Static</A>
<LI><A NAME="ToC_71" HREF="#HDREXTERN">3.6.3 Extern</A>
<LI><A NAME="ToC_72" HREF="#Header_72">3.6.4 Register</A>
</MENU></MENU>
<P><B><LI><A NAME="ToC_73" HREF="#HDRFUNK">4.0 &Uuml;bersicht &uuml;ber wichtige Funktionen</A></B>
<MENU>
<LI><A NAME="ToC_74" HREF="#HDRPRF">4.1 printf - formatierte Ausgabe auf dem Bildschirm</A>
<MENU>
<LI><A NAME="ToC_75" HREF="#HDRSPEZI">4.1.1 Erl&auml;uterung des Formatstrings</A>
<LI><A NAME="ToC_76" HREF="#HDRFLUCHT">4.1.2 Fluchtsymbolzeichen</A>
</MENU>
<LI><A NAME="ToC_77" HREF="#Header_77">4.2 scanf - formatiertes Lesen vom Standardeingabeger&auml;t</A>
<LI><A NAME="ToC_78" HREF="#Header_78">4.3 Eingabe- und Ausgabepuffer leeren</A>
<LI><A NAME="ToC_79" HREF="#Header_79">4.4 Funktionen zur Bearbeitung von Zeichenketten</A>
<MENU>
<LI><A NAME="ToC_80" HREF="#Header_80">4.4.1 Die Funktionen strcpy() und strcat()</A>
<LI><A NAME="ToC_81" HREF="#Header_81">4.4.2 Auswahl h&auml;ufig benutzter Funktionen zur Zeichenkettenbearbeitung</A>
</MENU></MENU>
<P><B><LI><A NAME="ToC_82" HREF="#HDROWN">5.0 Eigene Funktionen</A></B>
<MENU>
<LI><A NAME="ToC_83" HREF="#Header_83">5.1 Definition eigener Funktionen</A>
<LI><A NAME="ToC_84" HREF="#Header_84">5.2 Call by value und call by reference</A>
<LI><A NAME="ToC_85" HREF="#Header_85">5.3 Prototypen</A>
<LI><A NAME="ToC_86" HREF="#Header_86">5.4 Variable Anzahl an Parametern beim Funktionsaufruf</A>
</MENU>
<P><B><LI><A NAME="ToC_87" HREF="#HDRREPEAT">6.0 Wiederholungen - Schleifen</A></B>
<MENU>
<LI><A NAME="ToC_88" HREF="#Header_88">6.1 while</A>
<LI><A NAME="ToC_89" HREF="#Header_89">6.2 do while</A>
<LI><A NAME="ToC_90" HREF="#Header_90">6.3 for</A>
<LI><A NAME="ToC_91" HREF="#HDRBRE">6.4 Die Anweisungen break und continue</A>
</MENU>
<P><B><LI><A NAME="ToC_92" HREF="#HDRCHOICE">7.0 Auswahl</A></B>
<MENU>
<LI><A NAME="ToC_93" HREF="#Header_93">7.1 if/else</A>
<LI><A NAME="ToC_94" HREF="#HDRCASE">7.2 switch</A>
</MENU>
<P><B><LI><A NAME="ToC_95" HREF="#HDRFILE">8.0 Dateibehandlung</A></B>
<MENU>
<LI><A NAME="ToC_96" HREF="#Header_96">8.1 Datei &ouml;ffnen/schlie&szlig;en</A>
<LI><A NAME="ToC_97" HREF="#Header_97">8.2 Zeichen und Zeichenketten aus Dateien lesen</A>
<LI><A NAME="ToC_98" HREF="#Header_98">8.3 Zeichen in Dateien schreiben</A>
<MENU>
<LI><A NAME="ToC_99" HREF="#Header_99">8.3.1 Zeichenketten in eine Datei schreiben</A>
<LI><A NAME="ToC_100" HREF="#Header_100">8.3.2 Anh&auml;ngen von Daten an eine bereits vorhandene Datei</A>
</MENU>
<LI><A NAME="ToC_101" HREF="#Header_101">8.4 Das Arbeiten mit bin&auml;ren Dateien</A>
<MENU>
<LI><A NAME="ToC_102" HREF="#Header_102">8.4.1 Bin&auml;res Lesen von Integer Daten</A>
<LI><A NAME="ToC_103" HREF="#Header_103">8.4.2 Bin&auml;res Lesen von Flie&szlig;kommadaten</A>
</MENU>
<LI><A NAME="ToC_104" HREF="#Header_104">8.5 Zusammenfassung Lesen/Ausgeben von Daten</A>
</MENU>
<P><B><LI><A NAME="ToC_105" HREF="#HDRMEMORY">9.0 Speicherverwaltung</A></B>
<MENU>
<LI><A NAME="ToC_106" HREF="#Header_106">9.1 Speicherplatz reservieren</A>
<LI><A NAME="ToC_107" HREF="#Header_107">9.2 Speicherplatz reservieren und initialisieren</A>
<LI><A NAME="ToC_108" HREF="#Header_108">9.3 Speicherplatzgr&ouml;&szlig;e ver&auml;ndern</A>
<LI><A NAME="ToC_109" HREF="#Header_109">9.4 Speicherblock freigeben</A>
<LI><A NAME="ToC_110" HREF="#Header_110">9.5 Verkettete Listen</A>
<MENU>
<LI><A NAME="ToC_111" HREF="#Header_111">9.5.1 Doppelt verkettete Liste</A>
<LI><A NAME="ToC_115" HREF="#Header_115">9.5.2 Einfach verkettete Liste</A>
</MENU>
<LI><A NAME="ToC_116" HREF="#Header_116">9.6 Speicherverwaltungsfunktionen f&uuml;r Debugging</A>
</MENU>
<P><B><LI><A NAME="ToC_117" HREF="#HDRBS">10.0 Verbindungen zum Betriebssystem</A></B>
<MENU>
<LI><A NAME="ToC_118" HREF="#Header_118">10.1 Kommandozeilenparameter auswerten</A>
<LI><A NAME="ToC_119" HREF="#Header_119">10.2 Betriebssystembefehle ausf&uuml;hren</A>
<LI><A NAME="ToC_120" HREF="#Header_120">10.3 Programme starten</A>
</MENU>
<P><B><LI><A NAME="ToC_121" HREF="#HDRREGEXP">11.0 Regul&auml;re Ausdr&uuml;cke</A></B>
<MENU>
<LI><A NAME="ToC_122" HREF="#Header_122">11.1 Spezielle Zeichen in Regular Expressions</A>
<LI><A NAME="ToC_123" HREF="#Header_123">11.2 Beispiele f&uuml;r regul&auml;re Ausdr&uuml;cke</A>
<LI><A NAME="ToC_124" HREF="#Header_124">11.3 Quellcodebeispiele f&uuml;r regul&auml;re Ausdr&uuml;cke</A>
</MENU>
<P><B><LI><A NAME="ToC_125" HREF="#HDRPREPROC">12.0 Preprocessor-Anweisungen (Direktiven)</A></B>
<MENU>
<LI><A NAME="ToC_126" HREF="#Header_126">12.1 Symbolische Konstanten - #define</A>
<LI><A NAME="ToC_127" HREF="#Header_127">12.2 Makros - #define</A>
<LI><A NAME="ToC_128" HREF="#Header_128">12.3 &Uuml;bersetzungsabbruch - #error</A>
<LI><A NAME="ToC_129" HREF="#Header_129">12.4 Einf&uuml;gen von Dateien - #include</A>
<LI><A NAME="ToC_130" HREF="#Header_130">12.5 #if</A>
<LI><A NAME="ToC_131" HREF="#Header_131">12.6 #ifdef</A>
<LI><A NAME="ToC_132" HREF="#Header_132">12.7 #ifndef</A>
<LI><A NAME="ToC_133" HREF="#Header_133">12.8 #else</A>
<LI><A NAME="ToC_134" HREF="#Header_134">12.9 #endif</A>
<LI><A NAME="ToC_135" HREF="#Header_135">12.10 #undef</A>
<LI><A NAME="ToC_136" HREF="#Header_136">12.11 #elif</A>
<LI><A NAME="ToC_137" HREF="#Header_137">12.12 #line</A>
<LI><A NAME="ToC_138" HREF="#Header_138">12.13 #pragma</A>
</MENU>
<P><B><LI><A NAME="ToC_139" HREF="#HDRTROUB">13.0 Problembehebung</A></B>
<P><B><LI><A NAME="ToC_140" HREF="#HDROOP">14.0 Unterschiede zwischen C und C++</A></B>
<MENU>
<LI><A NAME="ToC_141" HREF="#Header_141">14.1 Operator&uuml;berladung</A>
<LI><A NAME="ToC_142" HREF="#Header_142">14.2 Funktions&uuml;berladung</A>
<LI><A NAME="ToC_143" HREF="#Header_143">14.3 Klassen</A>
<LI><A NAME="ToC_144" HREF="#Header_144">14.4 Konstruktor und Destruktor</A>
</MENU></MENU>
<HR><P><I><B><A NAME="ToC_145" HREF="#Header_145">Anh&auml;nge</A></B></I><BR>
<MENU>
<P><B><LI><A NAME="ToC_146" HREF="#Header_146">Anhang A. Schl&uuml;sselworte</A></B>
<P><B><LI><A NAME="ToC_147" HREF="#Header_147">Anhang B. &Uuml;bersicht &uuml;ber die Datentypen</A></B>
<P><B><LI><A NAME="ToC_148" HREF="#Header_148">Anhang C. Operatoren</A></B>
<MENU>
<LI><A NAME="ToC_149" HREF="#Header_149">C.1 Arithmetische Operatoren</A>
<LI><A NAME="ToC_150" HREF="#Header_150">C.2 Zusammengesetzte Zuweisungsoperatoren</A>
<LI><A NAME="ToC_151" HREF="#Header_151">C.3 Un&auml;re Operatoren</A>
<LI><A NAME="ToC_152" HREF="#Header_152">C.4 Vergleichende Operatoren</A>
<LI><A NAME="ToC_153" HREF="#Header_153">C.5 Logische Operatoren</A>
<LI><A NAME="ToC_154" HREF="#Header_154">C.6 Hierarchie der Operatoren</A>
</MENU>
<P><B><LI><A NAME="ToC_155" HREF="#Header_155">Anhang D. Formatstring</A></B>
<P><B><LI><A NAME="ToC_156" HREF="#Header_156">Anhang E. Fluchtsymbolzeichen</A></B>
<P><B><LI><A NAME="ToC_157" HREF="#Header_157">Anhang F. Funktionen zur Ein-/Ausgabe von Zeichen(-ketten)</A></B>
<P><B><LI><A NAME="ToC_158" HREF="#Header_158">Anhang G. Funktionen der Standardbibliotheken</A></B>
<P><B><LI><A NAME="ToC_159" HREF="#Header_159">Anhang H. &Uuml;bersicht &uuml;ber die Include-/Header-Dateien</A></B>
<P><B><LI><A NAME="ToC_160" HREF="#Header_160">Anhang I. Bedienung der Compiler Tools</A></B>
<MENU>
<LI><A NAME="ToC_161" HREF="#Header_161">I.1 Compiler</A>
<LI><A NAME="ToC_162" HREF="#Header_162">I.2 Linker</A>
</MENU>
<P><B><LI><A NAME="ToC_163" HREF="#Header_163">Anhang J. Rechnung mit Bits und Bytes</A></B>
<P><B><LI><A NAME="ToC_164" HREF="#Header_164">Anhang K. Zeichens&auml;tze</A></B>
<MENU>
<LI><A NAME="ToC_165" HREF="#HDRSAS">K.1 Standard ASCII</A>
<LI><A NAME="ToC_166" HREF="#HDREAS">K.2 Extended ASCII</A>
<LI><A NAME="ToC_167" HREF="#HDRANSI">K.3 ANSI</A>
<LI><A NAME="ToC_168" HREF="#HDREBCD">K.4 EBCDIC</A>
</MENU>
<P><B><LI><A NAME="ToC_169" HREF="#Header_169">Anhang L. Literaturverzeichnis</A></B>
<P><B><LI><A NAME="ToC_170" HREF="#Header_170">Anhang M. Online Ressourcen</A></B>
<MENU>
<LI><A NAME="ToC_171" HREF="#Header_171">M.1 Ressourcen unter VM</A>
<LI><A NAME="ToC_172" HREF="#Header_172">M.2 Ressourcen im Internet</A>
</MENU>
<P><B><LI><A NAME="ToC_173" HREF="#HDRINDEX_START">Index</A></B>
</MENU><P>
<HR><H1><A NAME="HDRTLIST_START" HREF="#ToC_2">Tabellen</A></H1>
<OL>
<LI><A NAME="FT_Table_1" HREF="#Table_1" >Sonderzeichen</A></LI>
<LI><A NAME="FT_Table_2" HREF="#Table_2" >Schl&uuml;sselworte</A></LI>
<LI><A NAME="FT_Table_3" HREF="#Table_3" >Wahrheitstabelle (logisches NICHT)</A></LI>
<LI><A NAME="FT_Table_4" HREF="#Table_4" >Wahrheitstabelle (logisches UND)</A></LI>
<LI><A NAME="FT_Table_5" HREF="#Table_5" >Wahrheitstabelle (logisches ODER)</A></LI>
<LI><A NAME="FT_Table_6" HREF="#Table_6" >Zusammengesetzte Zuweisungsoperatoren</A></LI>
<LI><A NAME="FT_Table_7" HREF="#Table_7" >Tabelle der Hierarchie der Operatoren</A></LI>
<LI><A NAME="FT_Table_8" HREF="#Table_8" >Zeiger im Speicher</A></LI>
<LI><A NAME="FT_Table_9" HREF="#Table_9" >Funktionen zum Lesen/Ausgeben</A></LI>
<LI><A NAME="FT_Table_10" HREF="#Table_10" >Schl&uuml;sselworte</A></LI>
<LI><A NAME="FT_Table_11" HREF="#Table_11" >Wertebereiche der Datentypen unter OS/2</A></LI>
<LI><A NAME="FT_Table_12" HREF="#Table_12" >Arithmetische Operatoren</A></LI>
<LI><A NAME="FT_Table_13" HREF="#Table_13" >Zusammengesetzte Zuweisungsoperatoren</A></LI>
<LI><A NAME="FT_Table_14" HREF="#Table_14" >Un&auml;re oder monadische Operatoren</A></LI>
<LI><A NAME="FT_Table_15" HREF="#Table_15" >Vergleichende Operatoren</A></LI>
<LI><A NAME="FT_Table_16" HREF="#Table_16" >Logische Zuweisungsoperatoren</A></LI>
<LI><A NAME="FT_Table_17" HREF="#Table_17" >Tabelle der Hierarchie der Operatoren</A></LI>
<LI><A NAME="FT_Table_18" HREF="#Table_18" >Ein-/Ausgabefunktionen</A></LI>
<LI><A NAME="FT_Table_19" HREF="#Table_19" >mathematische Funktionen</A></LI>
<LI><A NAME="FT_Table_20" HREF="#Table_20" >Speicherverwaltungsfunktionen</A></LI>
<LI><A NAME="FT_Table_21" HREF="#Table_21" >Test integer values (ohne deutsche Umlaute)</A></LI>
<LI><A NAME="FT_Table_22" HREF="#Table_22" >Umgebungssteuerung</A></LI>
<LI><A NAME="FT_Table_23" HREF="#Table_23" >Umwandlungsfunktionen</A></LI>
<LI><A NAME="FT_Table_24" HREF="#Table_24" >Zeichenketten- und Speicherfunktionen</A></LI>
<LI><A NAME="FT_Table_25" HREF="#Table_25" >Zeitfunktionen</A></LI>
<LI><A NAME="FT_Table_26" HREF="#Table_26" >Standard ASCII Zeichensatz</A></LI>
<LI><A NAME="FT_Table_27" HREF="#Table_27" >Extended ASCII Zeichensatz</A></LI>
<LI><A NAME="FT_Table_28" HREF="#Table_28" >ANSI Zeichensatz</A></LI>
<LI><A NAME="FT_Table_29" HREF="#Table_29" >EBCDIC Zeichensatz</A></LI>
</OL>
<HR><H1><A NAME="HDRFIGLIST_START" HREF="#ToC_3">Abbildungen</A></H1>
<OL>
<LI><A NAME="FT_FIGEINDIM" HREF="#FIGEINDIM" >Beispiel f&uuml;r ein eindimensionales Feld</A></LI>
<LI><A NAME="FT_FIGTABELLE" HREF="#FIGTABELLE" >Beispiel f&uuml;r ein zweidimensionales Feld</A></LI>
<LI><A NAME="FT_FIGWUERFEL" HREF="#FIGWUERFEL" >Beispiel f&uuml;r ein dreidimensionales Feld</A></LI>
<LI><A NAME="FT_FIGFELD1" HREF="#FIGFELD1" >Initialisierung eines eindimensionalen Feldes</A></LI>
<LI><A NAME="FT_FIGFELD2" HREF="#FIGFELD2" >Initialisierung eines zweidimensionalen Feldes</A></LI>
<LI><A NAME="FT_FIGFELD3" HREF="#FIGFELD3" >Initialisierung eines dreidimensionalen Feldes</A></LI>
<LI><A NAME="FT_FIGSTUDENT" HREF="#FIGSTUDENT" >Datensatz stu_daten</A></LI>
<LI><A NAME="FT_FIGPOINTER" HREF="#FIGPOINTER" >Zeiger</A></LI>
<LI><A NAME="FT_FIGPOINT1" HREF="#FIGPOINT1" >Zeiger</A></LI>
<LI><A NAME="FT_FIGPOINT2" HREF="#FIGPOINT2" >Zeiger</A></LI>
<LI><A NAME="FT_FIGDLISTE" HREF="#FIGDLISTE" >Doppelt verkettete Liste</A></LI>
</OL>
<HR><H1><A NAME="HDREINLEIT" HREF="#ToC_4">1.0 Einleitung</A></H1>
<P>Dieses Handbuch bietet eine Einf&uuml;hrung in die Programmiersprache C sowie
einen umfassenden &Uuml;berblick &uuml;ber viele Standardfunktionen, die in fast
jeder Implementation zu finden sind.
Es wird weder ein Anspruch auf Vollst&auml;ndigkeit
erhoben, noch werden s&auml;mtliche M&ouml;glichkeiten der Programmiersprache
C behandelt, da dies den Rahmen dieses Dokumentes sprengen
w&uuml;rde. Dieses Handbuch ist vielmehr als Erg&auml;nzung zur Einf&uuml;hrungsschulung
gedacht. Funktionen, Elemente, etc., die in den
&Uuml;bungsbeispielen vorkommen, werden hier vollst&auml;ndig behandelt.
Zus&auml;tzlich sind Informationen &uuml;ber wichtige
Funktionen und Elemente enthalten, die im Rahmen der Schulung
nicht erw&auml;hnt werden,
in der Praxis jedoch h&auml;ufig Verwendung finden. Dieses Handbuch orientiert
sich am ANSI-C Standard und dem
IBM C/C<TT>++</TT> Compiler Version 3.6 f&uuml;r OS/2, AIX
und Windows NT(&copy;).
<P>Die folgende Aufstellung beinhaltet die Themen, die in diesem
Handbuch keine Erw&auml;;hnung finden bzw. nicht behandelt werden:
<UL>
<P><LI>Schl&uuml;sselwort <TT>goto</TT>,
<P><LI>Schl&uuml;sselwort <TT>volatile</TT> und
<P><LI>Bit-Operationen
</UL>
<P>
<HR><H2><A NAME="Header_5" HREF="#ToC_5">1.1 Konventionen</A></H2>
<P>In diesem Handbuch werden bestimmte Hervorhebungen
zur Identifikation von Informationen benutzt, die im
folgenden erl&auml;utert werden:
<DL>
<P><DT><B>Schriftart</B>
<DD><B>Verwendung</B>
<P><DT><TT>Monospaced</TT>
<DD>Befehle oder Text, der exakt so eingegeben werden mu&szlig;, wie er
abgebildet ist.
<P><DT><I>kursiv</I>
<DD>Neue Begriffe sind kursiv gedruckt. Diese werden bei ihrem ersten
Vorkommen im Text erl&auml;utert. Ebenfalls kursiv sind Namen und besondere
Begriffe.
<P><DT><B>fett</B>
<DD>Tasten oder Tastenkombinationen werden fett gedruckt.
</DL>
<HR><H2><A NAME="HDRDUMMY" HREF="#ToC_6">1.2 Aufbau des Handbuches</A></H2>
<P>Kapitel <A HREF="#HDREINLEIT">1.0, "Einleitung"</A> enth&auml;lt allgemeine Hinweise zu diesem
Handbuch, wie z.B. Aufbau des Handbuches und Konventionen.
<P>In Kapitel <A HREF="#HDRGRUND">2.0, "Grundlagen der C Programmierung"</A> werden grunds&auml;tzliche
Aspekte der Programmierung in C, wie z.B. der verf&uuml;gbare
Zeichenvorrat, Operatoren, etc., erl&auml;utert.
<P>In Kapitel <A HREF="#HDRTYPEN">3.0, "Datentypen"</A> werden die in C verf&uuml;gbaren
Datentypen aufgef&uuml;hrt und ihre Eigenschaften erl&auml;utert.
<P>In Kapitel <A HREF="#HDRFUNK">4.0, "&Uuml;bersicht &uuml;ber wichtige Funktionen"</A> werden wichtige Standardfunktionen
von C besprochen.
<P>In Kapitel <A HREF="#HDROWN">5.0, "Eigene Funktionen"</A> wird aufgezeigt, wie eigene
Funktionen in C erstellt und angewendet werden k&ouml;nnen.
<P>Kapitel <A HREF="#HDRREPEAT">6.0, "Wiederholungen - Schleifen"</A> beschreibt die M&ouml;glichkeiten,
die C zur Wiederholung von Programmteilen anbietet.
<P>In Kapitel <A HREF="#HDRCHOICE">7.0, "Auswahl"</A> befinden sich Erl&auml;uterungen
zur Programmierung von Auswahlentscheidungen.
<P>Kapitel <A HREF="#HDRFILE">8.0, "Dateibehandlung"</A> beschreibt den Umgang mit Dateien.
Dies umfa&szlig;t z.B. das &Ouml;ffnen, Lesen und Schreiben von Dateien.
<P>Kapitel <A HREF="#HDRBS">10.0, "Verbindungen zum Betriebssystem"</A> geht auf die M&ouml;glichkeiten ein,
Verbindungen zum Betriebssystem aufzubauen, z.B. um Betriebssystembefehle
ausf&uuml;hren zu k&ouml;nnen.
<P>Kapitel <A HREF="#HDRPREPROC">12.0, "Preprocessor-Anweisungen (Direktiven)"</A> f&uuml;hrt die in C verf&uuml;gbaren
Preprocessor-Anweisungen auf.
<P>Kapitel <A HREF="#HDROOP">14.0, "Unterschiede zwischen C und C++"</A> stellt eine Abgrenzung von C zu
C<TT>++</TT>
dar. Es wird auf die grunds&auml;tzlichen Unterschiede und Gemeinsamkeiten von
C und C<TT>++</TT> eingegangen.
<P>Im Anhang befinden sich hilfreiche Aufstellungen, &Uuml;bersichten und
das Literaturverzeichnis.
<HR><H2><A NAME="Header_7" HREF="#ToC_7">1.3 Historie von C</A></H2>
<P>Die Programmiersprache C wurde 1972 von Dennis Ritchie in den
Bell Laboratories in New Jersey (USA) entworfen. Sie basiert auf
der Programmiersprache B, welche von Ken Thompson aus der
Sprache BCPL (<B>b</B>asic <B>c</B>ombined
<B>p</B>rogramming <B>l</B>anguage) abgeleitet wurde.
Beide Programmierer arbeiteten an der Entwicklung
des Betriebssystems <I>Unix</I> und waren mit der verwendeten Sprache
<I>Assembler</I> unzufrieden. Assembler ist sehr schnell, jedoch
umst&auml;ndlich, schwierig und nicht
portabel
<A NAME="Footnote_Used_1" HREF="#Footnote_1" ><SUP>1</SUP></A>
<A NAME="IDX1"></A>
Aus diesen Gr&uuml;nden
entwickelten sie eine schnelle <I>Compilersprache</I>, die auf
vielen verschiedenen Computersystemen einsetzbar ist.
<HR><H2><A NAME="Header_8" HREF="#ToC_8">1.4 Vom Quellcode zum lauff&auml;higen Programm</A></H2>
<A NAME="IDX2"></A>
<A NAME="IDX3"></A>
<P>Als Quellcode bezeichnet man eine endlich lang Folge von Befehlen zur
Umsetzung von Algorithmen.
Ein Algorithmus ist eine endlich lange Vorschrift, bestehend aus
Einzelanweisungen. Eine endlich lange Vorschrift hat nicht zwangsweise
eine endlich lange Laufzeit zur Folge, aber die Beschreibung der
Vorschrift ist endlich.
Ein Beispiel f&uuml;r einen Algorithmus ist ein Kochrezept
("Man nehme...").
Der Durchf&uuml;hrende kennt die Bedeutung der Einzelanweisungen, welche
deterministisch, also nicht zuf&auml;llig, abgearbeitet werden.
<P>Programmiersprachen werden einerseits nach dem Zeitpunkt ihrer
&Uuml;bersetzung in Maschinensprache
(Compiler- oder <I>Interpretersprache</I>),
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>
und andererseits nach ihrer Orientierung (prozedurale oder
objektorientierte Sprache) unterschieden.
<P>Ein, mit einer Compilersprache (z.B. C) erstelltes Programm ist nach dem
sog. Link Vorgang, bei dem die verschiedenen Maschinensprachebestandteile
eines Programms zusammengef&uuml;gt werden, ohne weitere
Zus&auml;tze eigenst&auml;ndig lauff&auml;hig. Im Gegensatz dazu ist ein, mit einer
Interpretersprache (z.B. REXX)
erstelltes Programm nicht ohne den Interpreter selbst
lauff&auml;hig. Dies liegt daran, da&szlig; der Code vom Interpreter erst
w&auml;hrend der Laufzeit des Programms &uuml;bersetzt wird, also immer als
Quellcode vorliegt.
<BR>
Eine Mischform stellen Programme dar, die zwar mit einer
Compilersprache erzeugt werden, aber sogenannte
<I>Laufzeitbibliotheken</I> (<I>Runtime-Libraries</I>)
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
zur eigenst&auml;ndigen Verwendbarkeit ben&ouml;tigen, die
als zus&auml;tzliche Dateien vorliegen m&uuml;ssen.
<P>Um aus einem C Quellcode ein lauff&auml;higes Programm zu erzeugen,
mu&szlig; dieser zun&auml;chst &uuml;bersetzt werden, diese Aufgabe &uuml;bernimmt der
Compiler. Der Compiler durchsucht den Quelltext zun&auml;chst nach
den sog. Preprozessoranweisungen und f&uuml;hrt diese aus. Dies hat
z.B. zur Folge, da&szlig; weitere Dateien in die &Uuml;bersetzung mit
einbezogen werden. Im n&auml;chsten Schritt werden der Quellcode
und alle hinzugezogenen Dateien auf syntaktische Fehler untersucht
und - wenn m&ouml;glich - fast vollst&auml;ndig
in Maschinensprache &uuml;bersetzt. Das Ergebnis
dieses Vorgangs ist der sog. Objektcode.
<A NAME="IDX8"></A>
Nach dem Compilieren mu&szlig; der Linker den erzeugten Objektcode
mit bereits existierendem Objektcode verbinden und erzeugt
letztendlich das lauff&auml;hige Programm. Dieser komplette Ablauf
kann bei komplexen Programmen sehr viel Zeit in Anspruch nehmen,
so da&szlig; h&auml;ufig nur einzelne Programmteile &uuml;bersetzt und
getestet werden. Eine weitere M&ouml;glichkeit bietet das sog.
Prototyping per Interpretersprache. Hierbei werden Algorithmen
zun&auml;chst in einer Interpretersprache (z.B. REXX) implementiert.
Dies hat den Vorteil, da&szlig; das Programm, so unvollst&auml;ndig es
auch ist, aufgerufen und getestet werden kann. Sind die
Algorithmen (logisch) korrekt, werden sie in die Compilersprache
umgesetzt.
<P>Bei C handelt es sich um eine sogenannte
<A NAME="IDX9"></A>
<I>prozedurale Sprache</I>. Bei einer prozeduralen Sprache
unterscheidet man zwischen Daten und Algorithmen, wobei der
Schwerpunkt auf den Algorithmen liegt. Im Gegensatz zu dieser
klassischen Gruppe von Programmiersprachen unterscheidet man die
sogenannten <I>objektorientierten Sprachen</I>, 
<A NAME="IDX10"></A>
bei denen die
Trennung zwischen Daten und Algorithmen aufgehoben ist. Zu dieser Gruppe
von Programmiersprachen geh&ouml;rt die Sprache C<TT>++</TT>,
auf die im Kapitel <A HREF="#HDROOP">14.0, "Unterschiede zwischen C und C++"</A> eingegangen wird.
<P>
<HR><H2><A NAME="Header_9" HREF="#ToC_9">1.5 Argumente f&uuml;r den Einsatz der Sprache C</A></H2>
<P>Die Programmiersprache C bietet dem Programmierer ein
F&uuml;lle von Vorteilen gegen&uuml;ber anderen Programmiersprachen:
<UL>
<P><LI>C ist f&uuml;r fast alle Computersysteme erh&auml;ltlich (PC/PS, Home-Computer,
Mainframe, etc.).
<P><LI>C ist leicht &uuml;bertragbar auf andere Systeme (gute Portabilit&auml;t).
<P><LI>Eine Strukturierung der Programme ist in C m&ouml;glich.
<UL>
<P><LI>Problemstellungen k&ouml;nnen in C durch Untergliederung in Teilaufgaben
bearbeitet werden.
<P><LI>Teilprogramme k&ouml;nnen wieder-/weiterverwendet werden.
<P><LI>Die Lesbarkeit des Quellcodes wird verbessert.
</UL>
<P><LI>Der erzeugte Code ist schnell, aber dennoch kompakt.
<P><LI>C ist f&uuml;r viele Problembereiche einsetzbar.
<P><LI>C ist leicht erlernbar.
</UL>
<P>Der entstehende Eindruck einer
&quot;eierlegenden Wollmilchsau&quot; wird f&uuml;r
diejenigen, die die Sprache erlernen wollen, jedoch durch deren Kryptik
und Inkonsistenz
getr&uuml;bt. C zu erlernen ist grunds&auml;tzlich nicht sehr schwer. Den
Code anderer Programmierer zu verstehen kann jedoch zur Nervenprobe
werden: C-Programmierer sind vermutlich schreibfaul und C bietet viele
M&ouml;glichkeiten, Befehle und Funktionen zu kombinieren und abzuk&uuml;rzen.
<P>Die beiden folgenden Anweisungen leisten das gleiche:
<P>
<PRE>
(1)   return (a &gt; b) ? a : b;
 
(2)   if (a &gt; b) return a;
         else    return b;
</PRE>
<P>&Auml;hnlich ungewohnte Konstruktionen wie (1) erschweren das Verst&auml;ndnis,
sind aber nach einiger Zeit beinahe selbstverst&auml;ndlich.
<HR><H1><A NAME="HDRGRUND" HREF="#ToC_10">2.0 Grundlagen der C Programmierung</A></H1>
<P>In diesem Kapitel werden grundlegende Aspekte der Programmiersprache C
wie z.B. der zur Verf&uuml;gung stehende Zeichensatz und der
strukturelle Aufbau eines C Quellcodes vorgestellt.
Des weiteren wird auf die
Sensibilit&auml;t bez&uuml;glich Gro&szlig;- und Kleinschreibung sowie auf Kommentare,
Schl&uuml;sselw&ouml;rter, Operatoren und Bezeichner eingegangen.
<P>
<HR><H2><A NAME="Header_11" HREF="#ToC_11">2.1 Zeichensatz</A></H2>
<A NAME="IDX11"></A>
<P>Folgende Zeichen sind in einem C Quellcode erlaubt:
<P><PRE><TT>
Kleinbuchstaben       : a b c . . . z                 
<P>                      
Gro&szlig;buchstaben        : A B C . . . Z                 
<P>                      
Ziffern               : 0 1 2 3 4 5 6 7 8 9           
<P>                      
Trennzeichen          : z.B. blank, newline, tab      
</TT></PRE><P>
<BR>
<P><B><A NAME="Table_1" HREF="#FT_Table_1">Tabelle 1. Sonderzeichen</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Zeichen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">englische/amerikanische Bezeichnung
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">+
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">plus sign
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">-
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">minus sign, hyphen
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">*
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">asterisk
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">/
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">forward slash
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">=
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">equal sign
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">(
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">left parenthesis
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">right parenthesis
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">{
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">left (curly) brace
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">}
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">right (curly) brace
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">[
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">left (square) bracket
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">]
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">right (square) bracket
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&lt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">left angle bracket
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">right angle bracket
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">single quotation
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">"
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">double quotation
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">!
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">exclamation mark
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">& 
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">ampersand
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">#
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">hash mark, number sign
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">%
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">percent sign
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&#124;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">vertical bar
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">_
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">underscore
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&#94;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">caret, and symbol
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&#126;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">tilde
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">\
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">backslash
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&#46;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">period, dot
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">,
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">comma
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">semicolon
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&#58;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">colon
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">?
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">question mark
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">$
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">dollar sign
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&#64;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">at sign
</TD></TR></TABLE>
<P>Diese Beschr&auml;nkung gilt prinzipiell nicht f&uuml;r Text, den ein Programm
ausgibt sowie f&uuml;r die Kommentare. Es sollte jedoch aus Gr&uuml;nden der
Portabilit&auml;t auf Sonderzeichen wie z.B. Umlaute verzichtet werden.
<HR><H2><A NAME="Header_12" HREF="#ToC_12">2.2 Gro&szlig;- und Kleinschreibung</A></H2>
<P>Der Compiler ist sehr empfindlich bez&uuml;glich der Gro&szlig;- und
Kleinschreibung, wenn es um Schl&uuml;sselworte,
Variablen
<A NAME="Footnote_Used_2" HREF="#Footnote_2" ><SUP>2</SUP></A>
oder Funktionen geht. Die
Schreibweise, die in der Variablendefinition angewandt wird, mu&szlig;
das gesamte Programm &uuml;ber beibehalten werden. Dies bedeutet, da&szlig; eine
Variable <TT>GROSS</TT> nicht erkannt wird,
wenn sie in der Deklaration
<TT>gROSS</TT> codifiziert wurde.
Weiterhin sollte darauf geachtet
werden, da&szlig; Schl&uuml;sselworte
und Formatspezifikationen immer in
Kleinbuchstaben (Bsp.: <TT>scanf, fakultaet, %d</TT>)
geschrieben werden. Dahingegen wird die &Uuml;bersichtlichkeit und
Lesbarkeit verbessert, indem eigene Typen
(Abschnitt <A HREF="#HDROWNTYPE">3.5, "Eigene Typen - typedef"</A>)
in Gro&szlig;buchstaben deklariert werden (Bsp.: <TT>REAL, INTEGER</TT>).
<P>
<HR><H2><A NAME="HDRKEY" HREF="#ToC_13">2.3 Schl&uuml;sselworte</A></H2>
<A NAME="IDX12"></A>
<P>Schl&uuml;sselworte sind reservierte Worte, die nicht neu definiert
werden k&ouml;nnen.
ANSI-C verwendet folgende:
<PRE>
auto       break     case      char       const        continue   default    do
 
double     else      enum      extern     float        for        goto       if
 
int        long      register  return     short        signed     sizeof     static
 
struct     switch    typedef   union      unsigned     void       volatile   while
</PRE>
<BR>
<P><B><A NAME="Table_2" HREF="#FT_Table_2">Tabelle 2. Schl&uuml;sselworte</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">auto
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung der Speicherklasse <TT>auto</TT>
(siehe <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">break
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beendet die aktuelle Schleife und f&auml;hrt mit der Programmausf&uuml;hrung
bei der n&auml;chsten Anweisung nach der Schleife fort. Beendet auch
Anweisungszweige von <TT>switch</TT> Anweisungen.
(siehe <A HREF="#HDRBRE">6.4, "Die Anweisungen break und continue"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">case
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Anweisungszweig einer <TT>switch</TT> Anweisung.
(siehe <A HREF="#HDRCASE">7.2, "switch"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">char
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Datentyp f&uuml;r Zeichen und Zeichenketten.
(siehe <A HREF="#HDRCHAR">3.1.3, "Textzeichen - char"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">const
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer Konstanten.
(siehe <A HREF="#HDRBEZEI">2.7, "Bezeichner"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">continue
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Bricht den aktuellen Schleifendurchlauf ab und springt zum Ende
der Schleife.
(siehe <A HREF="#HDRBRE">6.4, "Die Anweisungen break und continue"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">default
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Anweisungszweig einer <TT>switch</TT> Anweisung, der ausgef&uuml;hrt wird,
wenn kein <TT>case</TT> Zweig zutrifft bzw. vorher kein <TT>break</TT>
auftrat.
(siehe <A HREF="#HDRCASE">7.2, "switch"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">do
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beginnt eine <TT>do while</TT> Schleife, die Pr&uuml;fung erfolgt am
Ende eines Schleifendurchlaufs.
(siehe <A HREF="#HDRREPEAT">6.0, "Wiederholungen - Schleifen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">double
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer rationellen Zahl.
(siehe <A HREF="#HDRRAT">3.1.2, "Rationale Zahlen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">else
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Alternativzweig einer <TT>if</TT> Anweisung.
(siehe <A HREF="#HDRCHOICE">7.0, "Auswahl"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">enum
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung eines Aufz&auml;hlungstyps.
(siehe <A HREF="#HDRENUM">3.3.2, "enum"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">extern
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung externer Bezeichner.
(siehe <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">float
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer rationellen Zahl.
(siehe <A HREF="#HDRRAT">3.1.2, "Rationale Zahlen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">for
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Schleife mit Pr&uuml;fung am Anfang eines Schleifendurchlaufs und
integriertem Z&auml;hler.
(siehe <A HREF="#HDRREPEAT">6.0, "Wiederholungen - Schleifen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">goto
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Unbedingter Sprung. (wird in diesem Handbuch nicht behandelt)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">if
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Abfrage einer Bedingung.
(siehe <A HREF="#HDRCHOICE">7.0, "Auswahl"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">int
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">long
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">register
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer Speicherklasse wie <TT>auto</TT>, jedoch
Register statt Speicher, falls m&ouml;glich.
(siehe <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">return
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beendet Funktionen und &uuml;bergibt ggf. einen R&uuml;ckgabewert.
(siehe <A HREF="#HDROWN">5.0, "Eigene Funktionen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">short
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">signed
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl oder eines Zeichens mit Vorzeichen.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A> bzw. <A HREF="#HDRCHAR">3.1.3, "Textzeichen - char"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">sizeof
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Ermittlung der L&auml;nge eines Operanden.
(siehe <A HREF="#HDRHIERAR">2.6.6, "Hierarchie der Operatoren"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">static
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer Speicherklasse. Der Speicherbereich wird bei
Programmbeginn zugeordnet.
(siehe <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">struct
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer Struktur.
(siehe <A HREF="#HDRSTRUKT">3.2.2, "Strukturen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">switch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beginn einer Auswahl.
(siehe <A HREF="#HDRCASE">7.2, "switch"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">typedef
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Definition eigener Datentypen.
(siehe <A HREF="#HDROWNTYPE">3.5, "Eigene Typen - typedef"</A> und <A HREF="#HDRSTRDEF">3.2.2.3, "Strukturen mit Typendefinitionen - typedef"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">union
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung verschiedener Datentypen im selben Speicherbereich.
(siehe <A HREF="#HDRUNION">3.2.3, "Unions"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">unsigned
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl oder eines Zeichens ohne Vorzeichen.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A> bzw. <A HREF="#HDRCHAR">3.1.3, "Textzeichen - char"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">void
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung ohne Typ. (Nichts)
(siehe <A HREF="#HDROWN">5.0, "Eigene Funktionen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">volatile
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung eines unbest&auml;ndigen Datentyps.
Dieses Schl&uuml;sselwort teilt dem Compiler mit, da&szlig; die bezeichnete
Variable durch Ereignisse au&szlig;erhalb der Kontrolle des Programms
ver&auml;ndert werden kann. Der Wert der Variablen mu&szlig; deshlab vor
jedem Zugriff neu aus dem Hauptspeicher gelesen werden, d.h. er
darf nicht in einem Prozessorregister gespeichert werden.
(Wird in diesem Handbuch nicht weiter behandelt.)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">while
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beginn einer <TT>while</TT> oder Ende einer <TT>do while</TT> Schleife.
(siehe <A HREF="#HDRCHOICE">7.0, "Auswahl"</A>)
</TD></TR></TABLE>
<P>Eine Reihe dieser Schl&uuml;sselworte wird in diesem Handbuch ausf&uuml;hrlich
erl&auml;utert. Zu beachten ist, da&szlig; s&auml;mtliche Zuweisungen,
Funktionsaufrufe, Variablendeklarationen und eine Reihe der obigen
Schl&uuml;sselworte mit einem Semikolon abgeschlossen werden m&uuml;ssen.
<BR>
Beispiel:
<PRE>
return(ergebnis);
</PRE>
<P>
<HR><H2><A NAME="Header_14" HREF="#ToC_14">2.4 Formale Grundstruktur</A></H2>
<A NAME="IDX13"></A>
<P>Unter der formalen Grundstruktur versteht man den strukturellen
Aufbau, der bei jedem C-Programm, welches nach bestimmten Grunds&auml;tzen
geschrieben wurde, gleich ist. Da C eine relativ
flexible Gestaltung des Quellcodes zul&auml;&szlig;t, kann dies zu stark
unterschiedlich aufgebauten Quellcodes f&uuml;hren. Die Einhaltung gewisser
Standards erh&ouml;ht jedoch die Lesbarkeit des Codes ungemein und sollte
aus diesem Grund ber&uuml;cksichtigt werden.
<P>Die &uuml;bliche Grundstruktur stellt sich folgenderma&szlig;en dar:
<P>
<PRE>
       /* Name, Beschreibung */                                 (1)
 
       #include &lt;stdio.h&gt;                                       (2)
       ...
 
 
       Vereinbarungsteil globaler Variablen                     (3)
       ...
 
 
       [typ] funktionsname ([typ]);                             (4a)
       ...
 
 
       [typ] funktionsname ([typ])                              (4b)
       {
          Vereinbarungsteil lokaler Variablen
          ...
          Anweisungsteil
          ...
       }  /* Ende von xy */
 
 
 
       [typ] main([typ])                                        (5)
 
       {                                                        (6)
          Vereinbarungsteil lokaler Variablen
          ...
          Anweisungsteil
          ...
        } /* Ende von main */                                   (6)
 
 
 
       [typ] funktionsname ([typ])                              (4c)
       {
          Vereinbarungsteil lokaler Variablen
          ...
          Anweisungsteil
          ...
       }  /* Ende von xy */
</PRE>
<P>(1) Alle von  <TT>/*</TT>  und  <TT>*/</TT>
eingeschlossenen Textkomponenten
stellen Kommentare dar. Zur n&auml;heren Erl&auml;uterung siehe Abschnitt
<A HREF="#HDRCOMMENT">2.4.1, "Der Einsatz von Kommentaren"</A>.
<P>(2) <TT>#include</TT> ist eine sog. Preprocessoranweisung.
Alle Anweisungen, die mit einer Raute (<TT>#</TT>)
beginnen, werden vom sogenannten <I>Preprocessor</I> ausgef&uuml;hrt
(siehe auch Abschnitt <A HREF="#HDRPREPROC">12.0, "Preprocessor-Anweisungen (Direktiven)"</A>).
Die Anweisung  <TT>#include &lt;stdio.h&gt;</TT>  bewirkt, da&szlig; an
dieser Stelle im Quelltext vor der &Uuml;bersetzung in maschinenlesbaren
Code die C-Definitionsdatei <TT>stdio.h</TT> eingef&uuml;gt wird. Die
Definitionsdatei <TT>stdio.h</TT>
(<B>st</B>an<B>d</B>ard-<B>i</B>nput-<B>o</B>utput)
bef&auml;higt den Compiler, die korrekte Verwendung der Funktionen zur Ein-
und Ausgabe zu &uuml;berpr&uuml;fen.
<P>(3) Der Vereinbarungsteil f&uuml;r globale Variablen schlie&szlig;t an
die  <TT>#include</TT>-Anweisungen an und
steht noch vor <TT>main()</TT>.
Weiterf&uuml;hrende Erl&auml;uterungen
sind im Abschnitt <A HREF="#HDREXTERN">3.6.3, "Extern"</A> zu finden.
<P>(4a) In diesem Bereich werden sog. Prototypen f&uuml;r Funktionen
aufgelistet.
In C wird f&uuml;r Programmteile, die eine definierte Teilaufgabe
ausf&uuml;hren, der Begriff <I>function</I> verwendet. In diesem
Dokument wird die direkte deutsche &Uuml;bersetzung <I>Funktion</I>
verwendet.
<P>Eine Funktion ist ein Teilprogramm, das
im Programmablauf aufgerufen wird, eine bestimmte Aufgabe
eigenst&auml;ndig ausf&uuml;hrt und dann die Kontrolle wieder an die
aufrufende Funktion zur&uuml;ckgibt. Sind diese Teilaufgaben auf
verschiedene, getrennt voneinander compilierbare Dateien
verteilt, so nennt man jede Datei ein <I>Modul</I> und nicht
Funktion.
<P>Es handelt sich bei einer Funktion um ein Unterprogramm, nicht
um eine mathematische Funktion. In C sind alle Funktionen
gleichberechtigt, das hei&szlig;t, jede Funktion kann jede andere
Funktion, mit Ausnahme von <TT>main()</TT>, aufrufen.
Ruft eine Funktion sich selbst auf, so nennt man das <I>Rekursion</I>.
<P>Die Prototypen dienen zun&auml;chst einmal dem Compiler als
Pr&uuml;fliste f&uuml;r s&auml;mtliche Funktionsaufrufe im Hinblick auf korrekte
Anzahl und Typisierung von Parametern. Funktionsprototypen
werden durch ein Semikolon nach der Parameterliste abgeschlossen.
Der eigentliche Funktionscode kann nun folgen (4b) oder am Ende
der Datei (4c).
<P>(4b) Eigene Funktionen k&ouml;nnen vor der Hauptfunktion
<TT>main()</TT> stehen, allerdings spricht einiges dagegen
(siehe auch <A HREF="#HDROWN">5.0, "Eigene Funktionen"</A>).
<P>(4c) Eigene Funktionen sollten nach <TT>main()</TT>
aufgef&uuml;hrt werden und stehen somit hinter der Hauptfunktion.
Auf jeden Fall ben&ouml;tigen diese Funktionen einen Prototypen (4a).
<P>(5) <TT>main()</TT> ist ein Beispiel f&uuml;r eine solche Funktion.
Die Besonderheit besteht darin, da&szlig; <TT>main()</TT> die Verbindung zum
Betriebssystem herstellt. Bei Aufruf des Programms von der
Betriebssystemebene aus wird die Funktion
<TT>main()</TT> gestartet. Diese
gibt die Kontrolle an untergeordnete Funktionen weiter und
erh&auml;lt sie zum Schlu&szlig; zur&uuml;ck, um sie an das Betriebssystem
zur&uuml;ckzugeben. Des weiteren ist <TT>main()</TT> die einzige Funktion,
die Kommandozeilenparameter empfangen kann.
<P>(6) Die geschweiften Klammern <TT>{ }</TT> (engl. curly braces,)
fassen in C mehrere Anweisungen zu einem Block zusammen und k&ouml;nnen diese
einem Befehl (z.B. <TT>if</TT>) oder einer Funktion zuordnen. Wird der
Block einer Funktion zugeordnet, so k&ouml;nnen in dem Block auch Variablen
deklariert werden.
Die Funktion der Klammern &auml;hnelt der von <TT>Begin</TT> und
<TT>End</TT> in Pascal oder Cobol.
Jede Anweisung (Befehl/Schl&uuml;sselwort oder Funktionsaufruf) mu&szlig; durch ein
Semikolon abgeschlossen werden.
<P>
<P><H3><A NAME="HDRCOMMENT" HREF="#ToC_15">2.4.1 Der Einsatz von Kommentaren</A></H3>
<P>Der C-Compiler ist an einer Formatierung des Quellcodes nicht
interessiert. Er k&uuml;mmert sich nicht darum, wie der Text im Editor
eingegeben wurde. Er liest von Semikolon zu Semikolon und von
Funktion zu Funktion. Dabei ist auch die Menge der Leerzeichen
unwichtig, sie werden einfach bis auf jeweils eins &uuml;berlesen. Da der
Compiler keinerlei Anforderungen an die Art und Weise der
Formatierung des Quellcodes stellt, ist die Gefahr gro&szlig;,
f&uuml;r Menschen schlecht lesbaren Code zu schreiben.
<P>Ein Beispiel:
<PRE>
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;float.h&gt;
#define FALSE 0
void main(void){float a,xalt,xneu;printf("%s,%s,%s","Berechnung der
Quadratwurzel einer Zahl a\n","nach einem Iterationsverfahren:\n\n",
"a=\n");scanf("%f",&a);xneu=a;do{xalt=xneu;
xneu=(xalt+a/xalt)/2.0;}while(fabs(xalt-xneu)&gt;FLT_EPSILON);
printf("\nWurzel aus a= %8.4f\n",xneu);}
</PRE>
<P>Selbst dieses kurze Programm ist nicht ohne weiteres
f&uuml;r den, der es nicht selbst geschrieben hat, verst&auml;ndlich.
Durch einfache und wenig aufwendige Ma&szlig;nahmen, insbesondere
durch Kommentare, l&auml;&szlig;t sich dieses Programm in der Lesbarkeit
stark verbessern. Die Befehle werden in sp&auml;teren Kapiteln
erl&auml;utert.
<P>Das oben abgebildete Beispiel in formatierter Form:
<PRE>
/* wurzel.c
----------------------------------------------------------
Author: Daniel Wolkenhauer, Sascha Kliche
Datum : September 1994
Datei : WURZEL.C
Beschreibung:
berechnet die Quadratwurzel einer Zahl gem&auml;&szlig; einer von
Archimedes stammenden Iterationsformel
----------------------------------------------------------
*/
 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;
 
#define FALSE 0
 
void main (void)
{
 
   float a, xalt, xneu;
 
   printf("%s,%s,%s",
          "Berechnung der Quadratwurzel einer Zahl a\n",
          "nach einem Iterationsverfahren :\n\n",
          "a = \n");
   scanf("%f",&a);
 
   xneu=a;
 
   do
   {
      xalt = xneu;
      xneu = ( xalt + a/xalt) / 2.0;
   } while (fabs ( xalt - xneu ) &gt; FLT_EPSILON);
 
   printf("\n Wurzel aus a= %8.4f\n", xneu);
 
}  /* Ende von main */
</PRE>
<P>
<P><H4><A NAME="Header_16">2.4.1.1 Gestaltung von Kommentaren</A></H4>
<A NAME="IDX14"></A>
<P>Im folgenden werden einige Beispiele f&uuml;r die m&ouml;gliche Verwendung
von Kommentaren im Quellcode gezeigt. Zu beachten sind hierbei
die Zeichenfolgen <TT>/*</TT> und <TT>*/</TT>, die Anfang und
Ende des Kommentars kennzeichnen.
<PRE>
 
/* Kommentare */
 
/***************************************************************/
/* Trennlinie als Kommentar */
 
/*
 * Kommentar kann auch in dieser
 * Form geschrieben werden, um ihn
 * vom Code abzuheben.
 */
 
/******************************************************
 *                                                    *
 *        Kommentar in einer Kommentarbox             *
 *                                                    *
 ******************************************************/
</PRE>
<P>Manche Compiler erlauben auch die Verwendung der Zeichenfolge
<TT>//</TT> zur Einleitung eines einzeiligen Kommentars. Diese,
der Sprache C<TT>++</TT> entstammende Notation l&auml;&szlig;t sich bei
den IBM C/C<TT>++</TT> FirstStep Tools Version 2.01
durch den Parameter <TT>/Ss+</TT> aktivieren.
<PRE>
// Jeglicher Text nach den Schr&auml;gstrichen wird als
// Kommentar interpretiert.
</PRE>
<P><H4><A NAME="Header_17">2.4.1.2 Was sollte kommentiert werden?</A></H4>
<P>Folgendes sollte unbedingt kommentiert werden:
<UL>
<P><LI>Dateiname, Versionsnummer, Autor, Datum, Datum der letzten &Auml;nderung,
Zweck des Programms (zu Beginn)
<P><LI>der Zweck der verwendeten Variablen (bei deren Deklaration)
<P><LI>die Aufgabe von einzelnen Programmabschnitten, insbesondere von
Funktionen
<P><LI>besondere Anweisungen
<P><LI>spezielle Algorithmen
</UL>
<P>Nicht kommentiert werden sollte, was ohnehin offensichtlich ist. In
den Kommentaren sollten nicht nur die Namen der Variablen auftauchen,
sondern ebenfalls ihre Aufgabe.
<P>Zum Abschlu&szlig; soll ein Beispiel den sinnvollen Einsatz eines
Kommentars zur Information am Programmkopf veranschaulichen:
<P>
<PRE>
/********************************************************************/
/*        Programm: comment.c                                       */
/*        Version : 4.2.6b                                          */
/*        Autor   : Sascha Kliche, Daniel Wolkenhauer               */
/*        Datum   : September 1994                                  */
/* letzte &Auml;nderung: 02.09.1994, 14.37h EST                          */
/*    Beschreibung: Dieses Programm besteht aus diesem Teil und     */
/*                  zwei weiteren externen Modulen                  */
/*                  (leerzeil.c/copyride.c). Es demonstriert die    */
/*                  Verwendung von Kommentaren.                     */
/********************************************************************/
</PRE>
<P><H3><A NAME="Header_18" HREF="#ToC_18">2.4.2 Formatierung</A></H3>
<P>Zus&auml;tzlich zum Einsatz von Kommentaren gibt es einige
M&ouml;glichkeiten, die Lesbarkeit des Programmcodes zu steigern.
Dazu geh&ouml;rt das Einf&uuml;gen von Leerzeilen und Leerzeichen sowie
eine klare Strukturierung (Prototypen vor main(), Funktionscode
nach main()).
<P>Grunds&auml;tzlich sollte jeder Variablendeklaration mind. eine
Leerzeile folgen.
Leerzeichen sollten dazu benutzt werden, eine b&uuml;ndige
Formatierung der Zeilen sicherzustellen.
Jede Verschachtelung sollte durch mind. zwei Leerzeichen nach
rechts einger&uuml;ckt werden.
<P>Der folgende Programmausschnitt demonstriert den sinnvollen
Einsatz von Kommentaren, Leerzeilen und Leerzeichen.
<PRE>
/*------------------------------------------------------------------*/
/*        Programm: menue.c                                         */
/*        Version : 1.0.0                                           */
/*        Autor   : Sascha Kliche                                   */
/*        Datum   : April 1997                                      */
/* letzte &Auml;nderung: 02.05.1997, 14.00h EST                          */
/*    Beschreibung: Dieses Programm stellt Funktionen zum Zeichnen  */
/*                  und Abfragen von Bildschirmmasken zur           */
/*                  Verf&uuml;gung, die Men&uuml;s mit Auswahlbalken          */
/*                  enthalten k&ouml;nnen.                               */
/*------------------------------------------------------------------*/
 
 
/*------------------------------------------------------------------*/
/* Include-Dateien und Makros/symbolische Konstanten definieren     */
/*------------------------------------------------------------------*/
 
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;os2.h&gt;                              /* OS/2 CP Definition */
 
#define INCL_DOSGETDATETIME                   /* OS/2 CP Zeit/Datum */
 
#define ESC 27                                /* Tastaturcodes      */
#define cursor_up 72
#define cursor_down 80
#define cursor_left 75
#define cursor_right 77
#define page_up 73
#define page_down 81
#define home 71
#define end 79
#define insert 82
#define del 83
 
 
/*------------------------------------------------------------------*/
/* Globale Variablen deklarieren                                    */
/*------------------------------------------------------------------*/
 
/* Men&uuml;punkte f&uuml;r Hauptauswahlmen&uuml; */
char mpunkt[5][25]={" 1.   Men&uuml;punkt 1  \0"," 2.   Men&uuml;punkt 2  \0",
                    " 3.   Men&uuml;punkt 3  \0"," 4.   Men&uuml;punkt 4  \0",
                    " 5.   Men&uuml;punkt 5  \0"};
 
/* Farben f&uuml;r Textvorder- und -hintergrund; hintergrund+=10 */
enum cols { black=30, red, green, yellow,
            blue, magenta, cyan,  white } colors;
 
 
/*------------------------------------------------------------------*/
/* Funktionsprototypen                                              */
/*------------------------------------------------------------------*/
 
void gotoxy(int, int);          /* Cursor plazieren, x=1-80, y=1-25 */
void clrscr(void);                            /* Bildschirm l&ouml;schen */
 
/*--- helle Textfarben setzen ---*/
void color(enum cols forcolors, enum cols backcolors);
/*--- matte Textfarben setzen ---*/
void mcolor(enum cols forcolors, enum cols backcolors);
 
/*--- Maske mit Zeit/Datum zeichnen ---*/
void maske(void);
/*--- Balken zeichnen; Position neuer balken, Position alter balken */
void balken(int, int);
 
 
/*------------------------------------------------------------------*/
/* Anfang Hauptprogramm (main)                                      */
/*------------------------------------------------------------------*/
 
void main(void)
{
  /*--- Deklaration lokaler Variablen ---*/
  int taste=0,           /* Tastencode gedr&uuml;ckte Taste  */
      position=0,        /* Position des Auswahlbalkens */
      i=0,               /* Z&auml;hlvariable f&uuml;r Schleifen  */
      max=5-1;           /* Anzahl Men&uuml;punkte           */
 
  /*--- Bildschirmmaske "Haupschirm" ausgeben ---*/
  clrscr();
  color(white,blue);
  maske();
  gotoxy(3,23);
  printf("Beliebige Taste dr&uuml;cken. Ende mit x.");
  fflush(stdout);
 
  for(i=0;i&lt;=max;i++)    /* Men&uuml;punkte ausgeben */
  {
     gotoxy(5,8+i);
     printf("%24s",mpunkt[i]);
  }                      /* Ende Men&uuml;punkte ausgeben */
 
  balken(0,0);           /* balken auf erste position setzen */
 
  ...
 
} /* ende main */
 
/*------------------------------------------------------------------*/
/* Ende Hauptprogramm (main)                                        */
/*------------------------------------------------------------------*/
 
 
/*------------------------------------------------------------------*/
/* Anfang Funktionen                                                */
/*------------------------------------------------------------------*/
 
 ...
 
/*------------------------------------------------------------------*/
/* Ende Funktionen                                                  */
/*------------------------------------------------------------------*/
</PRE>
<P>
<HR><H2><A NAME="Header_19" HREF="#ToC_19">2.5 Ausdr&uuml;cke</A></H2>
<A NAME="IDX15"></A>
<P>Ausdr&uuml;cke setzen sich aus einem oder mehreren Operanden
<A NAME="IDX16"></A>
und einem
Operator zusammen. Operanden k&ouml;nnen Variablen oder Konstanten sein,
wobei ein Ausdruck sowohl Variablen als auch Konstanten beinhalten kann.
Die Operatoren werden im folgenden erl&auml;utert.
<P>Jeder vergleichende Ausdruck (z.B. <TT>if(tag==4)</TT>) wird
auf die beiden Zust&auml;nde wahr bzw. falsch abgebildet. Da C keine
Wahrheitsvariablen (sog. boolsche Variablen)
<A NAME="IDX17"></A>
unterst&uuml;tzt, werden diese Zust&auml;nde wiederum auf Integerwerte 
abgebildet. Falsch
<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
wird auf den Wert Null abgebildet und wahr auf einen beliebigen Wert
ungleich Null. Dies hat zur Folge, da&szlig; bei vergleichenden
Ausdr&uuml;cken auch direkt Wahrheitswerte benutzt werden k&ouml;nnen:
z.B.
<PRE>
int tag=4;
 
if(tag) printf("Tag ist &lt;&gt; 0.\n");
else    printf("Tag ist gleich Null.\n");
</PRE>
<P>Dementsprechend liefern folgende Ausdr&uuml;cke unterschiedliche
Wahrheitswerte:
<PRE>
int tag=0;
 
(1) if(tag==0) ... else ...
 
(2) if(tag) ... else ...
 
(3) if(!tag) ... else ...
</PRE>
<P>Ausdruck (1) pr&uuml;ft, ob <TT>tag</TT> den Wert Null enth&auml;lt.
Da dies der Fall ist, ist der Ausdruck wahr, also ungleich Null
und der Ausdruck nach <TT>if</TT> wird ausgef&uuml;hrt.
Ausdruck (2) wird als Wahrheitswert Null, also falsch, betrachtet.
Dementsprechend wird der Ausdruck nach <TT>else</TT>
ausgef&uuml;hrt. Ausdruck (3) wird als Wahrheitswert 'nicht falsch'
(!0), also wahr, betrachtet. Ausgef&uuml;hrt wird der Ausdruck nach
<TT>if</TT>. Alles klar?
<HR><H2><A NAME="Header_20" HREF="#ToC_20">2.6 Operatoren</A></H2>
<A NAME="IDX20"></A>
<P>Die Gruppe der Operatoren wird in vier Untergruppen aufgeteilt:
<UL>
<P><LI>a) arithmetische Operatoren
<P><LI>b) un&auml;re oder monadische Operatoren
<P><LI>c) vergleichende Operatoren
<P><LI>d) logische Operatoren
</UL>
<P>Im Anschlu&szlig; an die Erl&auml;uterung der einzelnen Operatoren wird
die Hierarchie der Operatoren untereinander aufgezeigt.
<P>
<P><H3><A NAME="Header_21" HREF="#ToC_21">2.6.1 Arithmetische Operatoren</A></H3>
<A NAME="IDX22"></A>
<P>Mit Hilfe der arithmetischen Operatoren sind
Gleitkomma-, Festkomma- und ganzzahlige Ausdr&uuml;cke
zu verarbeiten. In C sind die folgenden f&uuml;nf definiert:
<PRE>
                   Addition       :  +
                   Subtraktion    :  -
                   Multiplikation :  *
                   Division       :  /
                 ( Restwert       :  % )
</PRE>
<P>Der Restwert-Operator ist in Klammern gesetzt, weil er nur f&uuml;r
ganzzahlige Ausdr&uuml;cke verwendet werden darf. Hierbei liefert er
den ganzzahligen Rest einer Division:
<P>
<PRE>
     10 / 5 = 2      3 / 2 = 1.5     36 / 5 = 7.2
     10 % 5 = 0      3 % 2 = 1       36 % 5 = 1
</PRE>
<P>Wird der Divisions-Operator mit zwei Integer-Werten verkn&uuml;pft,
so liefert er als Ergebnis wieder einen ganzzahligen Wert zur&uuml;ck:
<P>
<PRE>
      8 / 2 = 4     10 / 4 = 2        1 / 2 = 0
</PRE>
<P>
<P><H3><A NAME="Header_22" HREF="#ToC_22">2.6.2 Un&auml;re oder monadische Operatoren</A></H3>
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>
<P>Un&auml;re oder monadische Operatoren beziehen sich nur auf einen Operaden.
Normalerweise stehen diese vor dem Operanden, k&ouml;nnen aber auch
hinter dem Operanden stehen.
<P>Beispiele f&uuml;r diese Art von Operatoren sind
<UL>
<P><LI>das un&auml;re Minus -
<P><LI>der Autoinkrement-Operator ++
<P><LI>der Autodekrement-Operator --
<P><LI>sizeof
<P><LI>der Typecast
</UL>
<P>Steht der Autoinkrement-/Autodekrement-Operator vor dem Operanden,
so handelt es sich um einen Pr&auml;inkrement bzw. -dekrement. 
In diesem Fall wird der Wert des Operanden ge&auml;ndert, bevor er
verwendet wird.
Steht er nach dem Operanden, so handelt es sich um einen Postinkrement
bzw. -dekrement.
In diesem Fall wird der Wert des Operanden ge&auml;ndert, nachdem er
verwendet wird.
<BR>
Beispiele:
<PRE>
a = 10;  /* a wird der Wert 10 zugewiesen */
b = --a; /* b wird der Wert  9 zugewiesen */
c = a++; /* c wird der Wert  9 zugewiesen, erst dann erhaelt a den wert 10 */
</PRE>
<P><H3><A NAME="HDRVEROP" HREF="#ToC_23">2.6.3 Vergleichende Operatoren</A></H3>
<A NAME="IDX27"></A>
<P>Die vergleichenden Operatoren pr&uuml;fen auf Gleichheit
und Ungleichheit:
<P><PRE><TT>
a)     Gleichheit:              Ausdruck == Ausdruck                                
b)     Ungleichheit:            Ausdruck != Ausdruck                                
a)     Kleiner als:             Ausdruck &lt; Ausdruck                                 
b)     Kleiner oder gleich:     Ausdruck &lt;= Ausdruck                                
c)     Gr&ouml;&szlig;er:                  Ausdruck &gt; Ausdruck                                 
d)     Gr&ouml;&szlig;er oder gleich:      Ausdruck &gt;= Ausdruck                                
</TT></PRE><P>
Die Relation liefert den wahr (true) oder falsch (false) zur&uuml;ck. Da es
in C keine boolschen Variablen gibt, wird f&uuml;r wahr ein Wert ungleich Null (0)
und f&uuml;r falsch der Wert Null (0) vom Typ Integer zur&uuml;ckgegeben.
<DL>
<P><DT><B>Anmerkung zu a)&#58;
</B><DD>Das einfache Gleichheitszeichen (=)
erh&auml;lt in C die Aufgabe einer Zuweisung. 
Der linke Operator einer Zuweisung mu&szlig; ein "Lvalue"
(eine g&uuml;ltige Speicherstelle wie z.B. eine Variable) sein.
<BR>
Bsp.: <TT>a = 4</TT> weist a den Wert vier zu.
</DL>
<P>
<P><H3><A NAME="Header_24" HREF="#ToC_24">2.6.4 Logische Operatoren</A></H3>
<A NAME="IDX29"></A>
<P>Bei logischen Operatoren liefert die Relation
den Wert wahr oder falsch zur&uuml;ck.
<P>Die logischen Operatoren werden nicht zum Vergleich von Werten,
sondern zum Vergleich von Wahrheitswerten verwendet:
<P><PRE><TT>
a)     !      (logisches NICHT)     
b)     &amp;&amp;     (logisches UND)       
c)     &#124;&#124;     (logisches ODER)      
</TT></PRE><P>
<P>Die Charakteristik der einzelnen Operatoren wird mit Hilfe der
Wahrheitstabelle dargestellt (wahr=1, falsch=0).
<P>zu a) Das logische NICHT ist ein un&auml;rer Operator. Das
bedeutet, da&szlig; sich der Operator nur auf einen Operanden bezieht.
<BR>
<P><B><A NAME="Table_3" HREF="#FT_Table_3">Tabelle 3. Wahrheitstabelle (logisches NICHT)</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">x
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">!x
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">1
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">0
</TD></TR></TABLE>
<P>zu b) Das logische UND verkn&uuml;pft Ausdr&uuml;cke folgenderma&szlig;en
miteinander:
<BR>
<P><B><A NAME="Table_4" HREF="#FT_Table_4">Tabelle 4. Wahrheitstabelle (logisches UND)</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Wert 1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Wert 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Ergebnis
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD></TR></TABLE>
<P>zu c) Das logische ODER wird durch folgende Wahrheitstabelle
dargestellt:
<BR>
<P><B><A NAME="Table_5" HREF="#FT_Table_5">Tabelle 5. Wahrheitstabelle (logisches ODER)</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Wert 1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Wert 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Ergebnis
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">1
</TD></TR></TABLE>
<P>
<P><H3><A NAME="Header_25" HREF="#ToC_25">2.6.5 Zusammengesetzte Zuweisungsoperatoren</A></H3>
<A NAME="IDX31"></A>
<P>Die zusammengesetzten Zuweisungsoperatoren dienen nicht nur
einer verk&uuml;rzten Schreibweise, sie werden auch in
schnelleren Assemblercode &uuml;bersetzt als die jeweils
&auml;quivalenten Ausdr&uuml;cken.
<BR>
<P><B><A NAME="Table_6" HREF="#FT_Table_6">Tabelle 6. Zusammengesetzte Zuweisungsoperatoren</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Operator
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Beispiel
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&Auml;quivalenter Ausdruck
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">+=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index += 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index + 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">-=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index -= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index - 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">*=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index *= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index * 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">/=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index /= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index / 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">%=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index %= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index % 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&lt;&lt;=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">result &lt;&lt;= num
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">result = rsult &lt;&lt; num
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&gt;&gt;=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">form &gt;&gt;= 1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">form = form &gt;&gt; 1
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">mask &= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">mask = mask & 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&#94;=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">test &#94;= pre_text
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">test = test &#94;pre_test
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">|=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">flag |= on
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">flag = flag | on
</TD></TR></TABLE>
<P>
<P><H3><A NAME="HDRHIERAR" HREF="#ToC_26">2.6.6 Hierarchie der Operatoren</A></H3>
<A NAME="IDX33"></A>
<P>Beim Zusammentreffen mehrerer Operatoren in einer Relation mu&szlig;
definiert sein, welche Vorrangregeln gelten. Kommen mehrere
Operatoren gleicher Priorit&auml;t zusammen, so ist in der nachstehenden
Tabelle die Auswertungsrichtung festgeschrieben.
<P>Selbst wenn sich jemand diese Priorit&auml;ten merken kann, sollten
zur besseren Lesbarkeit Klammern gesetzt werden.
<BR>
<P><B><A NAME="Table_7" HREF="#FT_Table_7">Tabelle 7. Tabelle der Hierarchie der Operatoren</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Operatoren
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Verwendung
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Auswertungsrichtung
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">( )
<BR>
[]
<BR>
-&gt;
<BR>
&#46;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">bildet einen Ausdruck
<BR>
bezeichnet ein Feldelement
<BR>
w&auml;hlt eine Strukturkomponente aus
<BR>
w&auml;hlt eine Strukturkomponente per Zeiger aus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">++
<BR>
--
<BR>
-
<BR>
+
<BR>
!
<BR>
&#126;
<BR>
&amp;
<BR>
*
<BR>
sizeof
<BR>
(typ)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Inkrementieren
<BR>
Dekrementieren
<BR>
bildet negativen Wert
<BR>
?
<BR>
logische Negierung
<BR>
bitweises Negieren
<BR>
liefert Adresse einer Variablen/Konstanten
<BR>
greift &uuml;ber Zeiger auf Variable/Konstante zu
<BR>
liefer Gr&ouml;&szlig;e eines Speicherbereiches
<BR>
wandelt in angegebenen Typ um (type cast)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">rechts nach links
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">*
<BR>
/
<BR>
%
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Multiplizieren
<BR>
Dividieren
<BR>
Restwert bilden
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">+
<BR>
-
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Addieren
<BR>
Subtrahieren
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&lt;&lt;
<BR>
&gt;&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">verschiebt Bits nach links
<BR>
verschiebt Bits nach rechts
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&lt;
<BR>
&lt;=
<BR>
&gt;
<BR>
&gt;=
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Vergleich auf kleiner
<BR>
Vergleich auf kleiner gleich
<BR>
Vergleich auf gr&ouml;&szlig;er
<BR>
Vergleich auf gr&ouml;&szlig;er gleich
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">==
<BR>
!=
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Vergleich auf gleich
<BR>
Vergleich auf nicht gleich
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&amp;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Bitweises UND
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#94;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Bitweises XOR
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#124;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Bitweises ODER
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&& 
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Logisches UND
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">||
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Logisches ODER
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">? :
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Bedingung
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">rechts nach links
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">=
<BR>
+=
<BR>
-=
<BR>
*=
<BR>
/=
<BR>
&lt;&lt;=
<BR>
&gt;&gt;=
<BR>
&=
<BR>
&#94;=
<BR>
&#124;=
<BR>
%=
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">einfache Zuweisung
<BR>
Addieren und Zuweisen
<BR>
Subtrahieren und Zuweisen
<BR>
Multiplizieren und Zuweisen
<BR>
Dividieren und Zuweisen
<BR>
Bits nach links verschieben und zuweisen
<BR>
Bits nach rechts verschieben und zuweisen
<BR>
Bitweise UND verkn&uuml;pfen und zuweisen
<BR>
Bitweise XOR verkn&uuml;pfen und zuweisen
<BR>
Bitweise ODER verkn&uuml;pfen und zuweisen
<BR>
Restwert bilden und Zuweisen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">rechts nach links
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">,
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Operanden trennen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR></TABLE>
<P>
<P><H3><A NAME="Header_27" HREF="#ToC_27">2.6.7 Beispiele zur Verkn&uuml;pfung der Operatoren</A></H3>
<P>Im folgenden sind einige Beispiele f&uuml;r die Verkn&uuml;pfung mehrerer
Operatoren und deren Bedeutung aufgef&uuml;hrt:
<P><PRE><TT>
a)     (c &gt;= 'a') && (c &lt;= 'z')     pr&uuml;ft, ob ein Zeichen ein Kleinbuchstabe ist        
b)     (d &gt;= 0) && (d &lt;= 9)         pr&uuml;ft, ob ein Zeichen eine Ziffer ist               
c)     (x &gt; 0) && (y &gt; 0)           pr&uuml;ft, ob x- und y-Koordinate positiv sind          
</TT></PRE><P>
<P>
<HR><H2><A NAME="HDRBEZEI" HREF="#ToC_28">2.7 Bezeichner</A></H2>
<A NAME="IDX34"></A>
<P>Ein Bezeichner dient dazu, einer Variablen oder einer Konstanten
einen eindeutigen Namen zuzuweisen. Variablen und Konstanten
dienen zum Speichern und Bearbeiten von Daten, wobei die Daten von
Konstanten w&auml;hrend des Programmlaufes nicht ge&auml;ndert werden k&ouml;nnen.
In C k&ouml;nnen Konstanten f&uuml;r die Datentypen der ganzen Zahlen, der
rationalen Zahlen und der Zeichen definiert werden. Der Deklaration
von Konstanten geht das Schl&uuml;sselwort <TT>const</TT> voran.
Variablen und Konstanten sind Objekte, die mit Hilfe ihrer Namen
(Bezeichner), ihrer
Datentypen und ihrer Gr&ouml;&szlig;e in Byte einen bestimmten
Speicherbereich im Hauptspeicher ansprechbar macht. F&uuml;r die
Vergabe der Bezeichner gibt es in C bestimmte Restriktionen:
<OL TYPE=1>
<P><LI>Es d&uuml;rfen nur Buchstaben, Ziffern und der Unterstrich benutzt
werden, keine Umlaute und keine Sonderzeichen. Der Unterstrich sollte
nach M&ouml;glichkeit nur f&uuml;r eigene Typdefinitionen, nicht aber f&uuml;r eigentliche
Variablen oder Konstanten benutzt werden, da dieser i.d.R. kennzeichnet,
da&szlig; der Bezeichner von der Entwicklungsumgebung selbst bereitgestellt wird.
<P><LI>Das erste Zeichen mu&szlig; immer ein Buchstabe oder der Unterstrich
sein.
<P><LI>Ein Bezeichner darf beliebig lang sein. Allerdings sind nach
ANSI-C nur die ersten 31 Zeichen signifikant, das hei&szlig;t der
C-Compiler l&auml;&szlig;t weitere Zeichen unber&uuml;cksichtigt.
<P><LI>Es werden Klein- und Gro&szlig;buchstaben unterschieden.
<P><LI>Die unter Punkt <A HREF="#HDRKEY">2.3, "Schl&uuml;sselworte"</A>
angegebenen Schl&uuml;sselw&ouml;rter d&uuml;rfen nicht als
Bezeichner verwendet werden, da der Compiler sonst nicht
unterscheiden kann, ob eine Variable bzw. Konstante oder ein Schl&uuml;sselwort
gemeint ist.
<P><LI>Ein Bezeichner darf in einem Anweisungsblock
(eingegrenzt durch geschweifte Klammern) nur einmal vergeben
werden. Es ist zwar m&ouml;glich, in jedem Anweisungsblock gleiche Bezeichner
zu benutzen, dies sollte i.d.R. aus Gr&uuml;nden der &Uuml;bersichtlichkeit und
Verst&auml;ndlichkeit jedoch vermieden werden, wenn es sich nicht um eine
Z&auml;hlvariable handelt.
</OL>
<BR>
Beispiele:
<P>
<PRE>
        Richtig                      Falsch
 
        wort                         wort
        buchSTABE56                  2buchSTABE
        skanf_var                    scanf
</PRE>
<P>Die verschiedenen, in C zur Verf&uuml;gung stehenden, Datentypen werden
im Kapitel <A HREF="#HDRTYPEN">3.0, "Datentypen"</A> vorgestellt.
<HR><H1><A NAME="HDRTYPEN" HREF="#ToC_29">3.0 Datentypen</A></H1>
<A NAME="IDX35"></A>
<P>Die Aufgabe von Datentypen besteht darin, Speicherbereiche in Bezug
auf ihre Inhalte zu interpretieren. Der Inhalt dieses Speicherbereiches
ist zum Beispiel der Wert einer Variablen. Der
Compiler ben&ouml;tigt nun Informationen dar&uuml;ber, wieviel
Speicherplatz er f&uuml;r die Variable reservieren mu&szlig;. Dazu mu&szlig; der
Programmierer ihm den Datentyp der Variablen mitteilen.
<P>Die L&auml;nge in Bytes, die die einzelnen Datentypen im Speicher
beanspruchen,
h&auml;ngt von der verwendeten Hardware und Softwareentwicklungsumgebung ab.
Die jeweiligen Gr&ouml;&szlig;en sind in den Dateien <TT>LIMITS.H</TT> und
<TT>FLOAT.H</TT> der verwendeten Entwicklungsumgebung festgelegt. Alle
hier angegebenen Gr&ouml;&szlig;en gelten f&uuml;r den Compiler der
IBM C/C<TT>++</TT> FirstStep Tools Version 2.01.
Die Ermittlung der dezimalen Zahlen aus den bin&auml;ren Angaben
erfolgt mittels 2<SUP>x</SUP>, wobei x die Anzahl der verwendeten
Bits darstellt.
<P>Wie viele andere Programmiersprachen auch, verf&uuml;gt C &uuml;ber
<I>einfache Datentypen</I> und
<I>h&ouml;here Datentypen</I>. Bei den
einfachen Datentypen unterscheidet man die ganzen Zahlen (Integer),
die rationalen Zahlen (Float) und die Textzeichen
(Char(acter)), welche in jeweils unterschiedlichen Formen auftreten
k&ouml;nnen.
Bei den h&ouml;heren Datentypen unterscheidet man
Felder (Array), Strukturen, Unions und Pointer.
H&ouml;here Datentypen werden h&auml;ufig auch als
<I>komplexe</I> oder <I>strukturierte</I> Datentypen
bezeichnet. Felder und Strukturen werden auch als zusammengesetzte
Datentypen bezeichnet.
<P>
<HR><H2><A NAME="Header_30" HREF="#ToC_30">3.1 Einfache Datentypen</A></H2>
<A NAME="IDX37"></A>
<P>In diesem Abschnitt werden die einfachen Datentypen, ihr
Verwendungszweck und ihre Deklaration erl&auml;utert.
<P>
<P><H3><A NAME="HDRINT" HREF="#ToC_31">3.1.1 Ganze Zahlen - Integer</A></H3>
<A NAME="IDX38"></A>
<A NAME="IDX40"></A>
<P>Der Wertebereich der ganzen Zahlen besteht aus den
nat&uuml;rlichen Zahlen. Die Integertypen sind weiter untergliedert in
<BR>
<PRE>
     - short int
 
     - int
</PRE>
und
<PRE>
     - long int
</PRE>
<P>Alle Integertypen lassen sich mit Vorzeichen (<TT>signed</TT>)
oder ohne Vorzeichen (<TT>unsigned</TT>) definieren.
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">Integertypen</TH><TR><TD>
<PRE>
                                        
>>--+----------+--+-+-------+--int-+--><
    |-unsigned-|  | |-short-|      |    
    |          |  | |       |      |    
    +-signed---+  | +-long--+      |    
                  |                |    
                  +-+-short-+------+    
                    |       |           
                    +-long--+           
</PRE>
</TD></TR></TABLE>
<P>Ganze Zahlen k&ouml;nnen nicht nur in der &uuml;blichen
dezimalen Schreibweise (z.B. 18), sondern z.B. auch
in hexadezimaler Schreibweise (z.B. 0xFFFF bzw. 0XFFFF)
angegeben werden.
<P><H4><A NAME="Header_32">3.1.1.1 short int</A></H4>
<A NAME="IDX42"></A>
<A NAME="IDX45"></A>
<P>Der Typ <TT>short int</TT> entspricht in der Regel dem Typ
<TT>int</TT>. Da&szlig; dennoch ein eigener Typ existiert, hat seine
Ursache darin, da&szlig; in C folgendes definiert ist:
<P>Gr&ouml;&szlig;e von <TT>short int</TT> &lt;= Gr&ouml;&szlig;e von
<TT>int</TT>  &&  Gr&ouml;&szlig;e
von <TT>int</TT> &lt;= Gr&ouml;&szlig;e von <TT>long int</TT>.
<P>Dies erm&ouml;glicht dem Compilerhersteller festzulegen, ob f&uuml;r
<TT>short int</TT> weniger Speicherplatz benutzt wird als f&uuml;r
<TT>int</TT>. Der Compiler der IBM C/C<TT>++</TT>
FirstStep Tools
Version 2.01 reserviert zwei Byte (16 Bit) f&uuml;r
<TT>short int</TT> Daraus resultiert, da&szlig; <TT>signed short int</TT>
einen Wertebereich von
-32.768 bis 32.767 (-2<SUP>15</SUP> bis 2<SUP>15</SUP>, das
16. Bit wird f&uuml;r das Vorzeichen verwendet)
und <TT>unsigned short int</TT> einen Wertebereich von
0 bis 65.535 (2<SUP>16</SUP>) zur Verf&uuml;gung stellen.
<P>
<P><H4><A NAME="Header_33">3.1.1.2 int</A></H4>
<A NAME="IDX47"></A>
<A NAME="IDX50"></A>
<P>Die Variablen des Typs <TT>int</TT> werden mit vier Byte (32 Bit)
dargestellt und haben einen Wertebereich von
-2.147.483.648 bis 2.147.483.647 und somit 2<SUP>31</SUP> Zahlen.
Mittels der symbolischen Konstante <TT>INT_MIN</TT> kann der
kleinste Wert (-2.147.483.648) angesprochen werden.
<PRE>
                int x;
</PRE>
oder
<PRE>
                signed int x;
</PRE>
<P>Vorzeichenlos:
<PRE>
                unsigned int x;
</PRE>
<P>Der Wertebereich dieses Datentyps erstreckt sich von 0 bis
4.294.967.295.
<P>
<P><H4><A NAME="Header_34">3.1.1.3 long int</A></H4>
<A NAME="IDX52"></A>
<A NAME="IDX55"></A>
<P>Der Wertebereich des Typs <TT>long int</TT> entspricht dem Wertebereich
von <TT>int</TT>, da auch dieser Typ mit vier Byte (32 Bit) dargestellt wird.
<BR>
Die Deklaration hat folgende Form:
<P>
<PRE>
                long int x;
</PRE>
oder
<PRE>
                signed int x;
</PRE>
<P><TT>long int</TT> kann ebenfalls vorzeichenlos deklariert werden:
<PRE>
                unsigned long int x;
</PRE>
<P>Einer Konstante des Typs <TT>long int</TT> folgt unmittelbar
das Zeichen L, z.B. <TT>518346L</TT>, um zu kennzeichnen, da&szlig;
es sich nicht um eine Variable des Typs <TT>int</TT> handelt.
<P><H4><A NAME="Header_35">3.1.1.4 long long int</A></H4>
<A NAME="IDX57"></A>
<A NAME="IDX60"></A>
<P>Dieser Datentyp ist nicht vom C Standard abgedeckt, steht aber unter einigen
Compilern zur Verf&uuml;gung. "IBM C and C++ Compilers" definieren diesen Typ mit
einer L&auml;nge von 8 Bytes.
<P><H3><A NAME="HDRRAT" HREF="#ToC_36">3.1.2 Rationale Zahlen</A></H3>
<A NAME="IDX61"></A>
<A NAME="IDX62"></A>
<P>Bei den rationalen Zahlen unterscheidet man ebenfalls verschiedene
Genauigkeitsstufen, Gr&ouml;&szlig;en- und Wertebereiche):
<TT>float</TT>, <TT>double</TT> und <TT>long double</TT>
<P><TT>double</TT> wurde erst durch den ANSI-C-Standard definiert,
vorher hie&szlig; dieser Datentyp <TT>longfloat</TT>.
Aus diesem Grund ist der Bezeichner f&uuml;r die
Formatspezifikation nach wie vor <TT>%lf</TT>.
<P>Variablen f&uuml;r rationale
Zahlen sollten stets bei ihrer Deklaration initialisiert
werden, da f&uuml;r sie nur bestimmte Bitkombinationen erlaubte Werte
darstellen. Wird dies nicht beachtet, kann es unter OS/2 zum
Programmabbruch mit dem Fehlercode c009a kommen.
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">Flie&szlig;kommatypen</TH><TR><TD>
<PRE>
                       
>>--+-float-------+--><
    |             |    
    |-double------|    
    |             |    
    +-long double-+    
</PRE>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_37">3.1.2.1 Der Typ float</A></H4>
<A NAME="IDX64"></A>
<A NAME="IDX67"></A>
<P>Der Typ <TT>float</TT> wird mit 32 Bit (4 Byte) dargestellt und
ergibt einen Wertebereich von 1.175*10<SUP>-38</SUP>
bis 3.4*10<SUP>38</SUP>. Es gibt drei verschiedene M&ouml;glichkeiten
der Darstellung:
<OL TYPE=1>
<P><LI>die Festkomma-Darstellung (z.B. 3.456),
<P><LI>die Gleit- oder Flie&szlig;komma-Darstellung (z.B. 3.423e7) und
<P><LI>die Darstellung, bei der der Compiler entscheidet, welche die k&uuml;rzere
ist.
</OL>
<BR>
Die Darstellungsform hat nur bei der Ein-/Ausgabe von rationalen
Zahlen Auswirkungen und wird &uuml;ber den Formatstring festgelegt.
<P>
Die Deklaration hat folgende Form:
<P>
<PRE>
                float x=0.0;
</PRE>
<P>Dieser Typ ist nicht f&uuml;r pr&auml;zise Berechnungen geeignet, da seine
Genauigkeit bereits nach wenigen Nachkommastellen nachl&auml;&szlig;t. In
diesem Fall sind die Typen <TT>double</TT> bzw.
<TT>long double</TT> zu benutzen.
Beispiel:
<PRE>
      float zahl1=0.0, zahl2=0.0, ergebnis=0.0;
 
      scanf("%f+%f",&zahl1,&zahl2);
      ergebnis=zahl1+zahl2;
      printf("%f+%f=%f",zahl1,zahl2,ergebnis);
 
 
      Eingabe: 85.439+234.34
      Ausgabe: 85.439003+234.339996=319.778992
</PRE>
<P><H4><A NAME="Header_38">3.1.2.2 Der Typ double</A></H4>
<A NAME="IDX69"></A>
<A NAME="IDX72"></A>
<P>Der Typ <TT>double</TT> wird mit 64 Bit (8 Byte) dargestellt und
erm&ouml;glicht einen Wertebereich von 2.2*10<SUP>-308</SUP> bis
1.798*10<SUP>308</SUP>.
<BR>
Die Deklaration hat folgende Form:
<P>
<PRE>
                double x=0.0;
</PRE>
<P>Bei Operationen mit rationalen Zahlen mu&szlig; mindestens eine Zahl ein
Komma enthalten, da sonst in
Integer gerechnet wird! Die Rechnung 2700 * 4096 liefert unter DOS ein
falsches Ergebnis, 2700.0 * 4096 dagegen liefert ein korrektes Ergebnis.
<P>
<P><H4><A NAME="Header_39">3.1.2.3 Der Typ long double</A></H4>
<A NAME="IDX74"></A>
<A NAME="IDX77"></A>
<P>Der Typ <TT>long double</TT> wird mit 128 Bit (16 Byte) dargestellt
und hat einen
Wertebereich von 3.36*10<SUP>-4932</SUP> bis 1.1897*10<SUP>4932</SUP>.
<P>
<P><H4><A NAME="Header_40">3.1.2.4 Floating Point Konstanten</A></H4>
<A NAME="IDX79"></A>
<A NAME="IDX81"></A>
<P>Floating Point Konstanten bestehen aus
<UL>
<P><LI>einem integralen Teil
<P><LI>einem Dezimalpunkt
<P><LI>einem Bruchteil
<P><LI>einem Exponenten
<P><LI>einem optionalen Suffix
</UL>
<P>Ein Plus oder ein Minus kann der Konstante vorangehen, ist jedoch nicht
Teil der Konstante.
<PRE>
Floating Point Konstante                        Wert
     5.3876e4                                   53876
       4e-11                                0.00000000004
       1e+5                                    100000
     7.321E-3                                 0.007321
      3.2E+4                                    32000
      0.5e-6                                 0.0000005
       0.45                                      0.45
      6.e10                                  60000000000
</PRE>
<P><H3><A NAME="HDRCHAR" HREF="#ToC_41">3.1.3 Textzeichen - char</A></H3>
<A NAME="IDX82"></A>
<A NAME="IDX84"></A>
<P>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">Chartypen</TH><TR><TD>
<PRE>
                          
>>--+----------+--char--><
    |-unsigned-|          
    |          |          
    +-signed---+          
</PRE>
</TD></TR></TABLE>
<P>Ein Textzeichen wird in C mit 8 Bit verarbeitet. Dies ergibt
2<SUP>8</SUP> = 256 verschiedene Zeichen. Diesen
256 M&ouml;glichkeiten ist unter OS/2 der erweiterte
ASCII
<A NAME="Footnote_Used_3" HREF="#Footnote_3" ><SUP>3</SUP></A>
<A NAME="IDX85"></A>
<A NAME="IDX87"></A>
Zeichensatz zugeordnet. Er gliedert sich wie folgt:
<P>
<PRE>
   Zeichen 0   ...  31   Steuerzeichen
   Zeichen 32  ...  47   Sonderzeichen
   Zeichen 48  ...  57   Ziffern 0-9
   Zeichen 58  ...  64   Sonderzeichen
   Zeichen 65  ...  90   Gro&szlig;buchstaben
   Zeichen 91  ...  96   Sonderzeichen
   Zeichen 97  ... 122   Kleinbuchstaben
   Zeichen 123 ... 127   Sonderzeichen
   Zeichen 128 ... 255   Zeichen des erweiterten Zeichensatzes
</PRE>
<P>Die Zeichen 128 bis 255 h&auml;ngen vom jeweiligen System und der
verwendeten Code-Tabelle ab. Diese Zeichen werden auch als
Extended ASCII
<A NAME="IDX89"></A>
<A NAME="IDX91"></A>
(siehe auch <A HREF="#HDREAS">K.2, "Extended ASCII"</A>)
bezeichnet und umfassen i.d.R. nationale Umlaute
und Sonderzeichen.
<P>Im C Quellcode sollten immer die entsprechenden Zeichen
anstatt der Zeichencodes (z.B. '2' statt 50) verwendet werden,
da auf vielen Systemen andere Zeichens&auml;tze verwendet werden
und die Zeichencodes dort eine andere Bedeutung haben.
Weitere verbreitete Zeichens&auml;tze sind z.B. EBCDIC
<A NAME="Footnote_Used_4" HREF="#Footnote_4" ><SUP>4</SUP></A>
<A NAME="IDX92"></A>
<A NAME="IDX94"></A>
(Gro&szlig;rechnersysteme,
z.B. VM), ANSI
<A NAME="Footnote_Used_5" HREF="#Footnote_5" ><SUP>5</SUP></A>
(z.B. Windows), Unicode (z.B. diverse UNIX Varianten) und
ISO Latin 1
<A NAME="IDX96"></A>
(z.B. diverse UNIX Varianten).
<P>Da einige Zeichens&auml;tze wie z.B. Unicode wesentlich mehr
als nur 256 Zeichen verwalten, existiert noch der Typ
<TT>wchar_t</TT>,
<A NAME="IDX97"></A>
<A NAME="IDX99"></A>
der mit bis zu vier Byte dargestellt wird,
um universelle Zeichens&auml;tze abbilden zu k&ouml;nnen.
<P>Die Deklaration von Variablen oder Konstanten des Typs
<TT>char</TT> hat folgende Form:
<P>
<PRE>
                unsigned char buchstabe;
</PRE>
<P><TT>char</TT> mu&szlig; <TT>unsigned</TT> deklariert werden, wenn
Zeichen mit einem Code gr&ouml;&szlig;er 127 benutzt werden sollen! Wird
<TT>char buchstabe;</TT> deklariert, k&ouml;nnen nur Zeichen mit
Codes von 0 bis 127 benutzt werden. Manche Entwicklungsumgebungen
definieren <TT>char</TT> grunds&auml;tzlich als <TT>unsigned
char</TT>.
<P>
<P><H4><A NAME="Header_42">3.1.3.1 Zeichenkonstanten und Zeichenkettenkonstanten</A></H4>
<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
<A NAME="IDX103"></A>
<A NAME="IDX104"></A>
<P>Konstanten sind Werte, die sich w&auml;hrend des Programmdurchlaufs nicht
&auml;ndern sollen. Sie k&ouml;nnen bei jedem Datentyp auftreten.
Bei den Zeichen- und
den Zeichenkettenkonstanten ist jedoch eine Besonderheit zu beachten.
<P>(1) Zeichenkonstanten werden in einfache Hochkommata eingeschlossen.
<BR>
Beispiele:
<PRE>
   'd'
   'C'
   '2'
</PRE>
<P>
Diese Zeichenkonstanten werden zum Beispiel in der
<TT>switch</TT>-Anweisung (siehe dazu Abschnitt <A HREF="#HDRCASE">7.2, "switch"</A>)
und in Vergleichen verwendet.
<P>(2) Zeichenkettenkonstanten werden dahingegen in
Anf&uuml;hrungszeichen eingefa&szlig;t:
<BR>
Beispiele:
<PRE>
  "Fehler beim &Ouml;ffnen der Datei aufgetreten!"
  "rc=0"
  "Bitte eine Zahl eingeben!"
</PRE>
<P>Zeichenkettenkonstanten finden besonders h&auml;ufig in der
<TT>printf</TT>-Anweisung (<A HREF="#HDRPRF">4.1, "printf - formatierte Ausgabe auf dem Bildschirm"</A>) Verwendung. Sie
k&ouml;nnen beliebige Zeichen enthalten und
laut ANSI-C-Standard 509 Zeichen lang sein. Diese Zahl ist jedoch
abh&auml;ngig vom verwendeten Compiler. Es k&ouml;nnen auch
sog. Fluchtsymbolzeichen (<A HREF="#HDRFLUCHT">4.1.2, "Fluchtsymbolzeichen"</A>)
aufgenommen werden. Diese gelten nur als ein einzelnes Zeichen. Beim
Ablegen im Speicher wird das Ende einer Zeichenkettenkonstanten durch
eine bin&auml;re Null (\0) gekennzeichnet, die automatisch angef&uuml;gt wird.
<P>
<HR><H2><A NAME="Header_43" HREF="#ToC_43">3.2 H&ouml;here Datenstrukturen</A></H2>
<P>In diesem Abschnitt werden die h&ouml;heren Datentypen Feld, Struktur,
Union und Pointer anhand von ausf&uuml;hrlichen Beispielen vorgestellt.
<P>
<P><H3><A NAME="HDRFELD" HREF="#ToC_44">3.2.1 Felder - Array - Vektoren</A></H3>
<A NAME="IDX105"></A>
<A NAME="IDX106"></A>
<A NAME="IDX108"></A>
<P>Felder sind der erste Variablentyp der h&ouml;heren Datentypen.
Sie stellen eine aufeinanderfolgende Anordnung von Elementen des
gleichen Typs dar. Der Zugriff auf die Elemente
erfolgt mit Hilfe eines Index. Dabei umfa&szlig;t der Wertebereich des
Index die positiven ganzen Zahlen inklusive der Null.
Eindimensionale Felder haben genau einen Index,
mehrdimensionale zwei oder mehr Indizes.
<P>
<P><H4><A NAME="Header_45">3.2.1.1 Eindimensionale Felder</A></H4>
<A NAME="IDX110"></A>
<P>Ein Feld wird &uuml;ber seine Anfangsadresse im Speicher, die Gr&ouml;&szlig;e
der Elemente und die Menge der Elemente vollst&auml;ndig definiert.
<BR>
Beispiel:
<P>
<PRE>
   int x[3];
</PRE>
definiert ein Feld x mit drei Elementen vom Typ Integer
und der Gr&ouml;&szlig;e 3*4 Byte.
<P><B><A NAME="FIGEINDIM" HREF="#FT_FIGEINDIM">Abbildung 1. Beispiel f&uuml;r ein eindimensionales Feld</A></B><BR>
<B><BR><CENTER><IMG SRC="feld1.gif" ALT="Figure feld1 not displayed."></CENTER><BR></B><BR>
<P>Die Deklaration <TT>int x[3];</TT> bewirkt,
da&szlig; die Elemente <TT>x[0], x[1]</TT> und
<TT>x[2]</TT> zur Verf&uuml;gung stehen.
<TT>x</TT> ist dabei definiert als <TT>x = &x[0]</TT>.
Es beinhaltet die Speicheradresse des ersten Elementes <TT>x[0]</TT>,
also einen Zeiger auf die Position des Inhaltes der ersten
Komponente im Speicher.
<P>
<P><H4><A NAME="Header_46">3.2.1.2 Mehrdimensionale Felder</A></H4>
<A NAME="IDX112"></A>
<P>F&uuml;r mehrdimensionale Felder werden mehrere Indizes verwendet.
Typisch ist das zweidimensionale Feld, es wird auch <I>Matrize</I>
oder <I>Tabelle</I> genannt.
<P>Die Definition mehrdimensionaler Felder erfolgt, im Gegensatz zu
den meisten Programmiersprachen, &uuml;ber mehrere, voneinander
getrennte, eckige Klammern.
<BR>
Beispiele:
<P>(1)
<PRE>
              int bildschirm [25] [80];
</PRE>
<P>Mit dieser Anweisung wird ein zweidimensionales Feld mit dem
Namen <I>bildschirm</I> erstellt. Es beinhaltet 25 Zeilen und
80 Spalten, gen&uuml;gend Platz, um einen kompletten Textbildschirm
aufzunehmen:
<P><B><A NAME="FIGTABELLE" HREF="#FT_FIGTABELLE">Abbildung 2. Beispiel f&uuml;r ein zweidimensionales Feld</A></B><BR>
<B><BR><CENTER><IMG SRC="feld2.gif" ALT="Figure feld2 not displayed."></CENTER><BR></B><BR>
<P>(2)
<PRE>
              int karten [5][4][3];
</PRE>
<P>vereinbart ein dreidimensionales Feld mit den Dimensionen
f&uuml;nf, vier und drei:
<P><B><A NAME="FIGWUERFEL" HREF="#FT_FIGWUERFEL">Abbildung 3. Beispiel f&uuml;r ein dreidimensionales Feld</A></B><BR>
<B><BR><CENTER><IMG SRC="feld3.gif" ALT="Figure feld3 not displayed."></CENTER><BR></B><BR>
<P>
<P><H4><A NAME="Header_47">3.2.1.3 Initialisierung und Ansprache von Feldern</A></H4>
<A NAME="IDX114"></A>
<P>Die folgenden Beispiele illustrieren die Initialisierung ein-, zwei-
und dreidimensionaler Felder bei deren Deklaration. Am Ende dieses
Abschnittes befindet sich ein Beispiel f&uuml;r die Initialisierung eines
zweidimensionalen Feldes mittels einer Schleife.
<PRE>
(1)   int datensatz[3] = {28,17,43};
 
                                   /*       Feldelement 0: 28;
                                            Feldelement 1: 17;
                                            Feldelement 2: 43;       */
</PRE>
<P><B><A NAME="FIGFELD1" HREF="#FT_FIGFELD1">Abbildung 4. Initialisierung eines eindimensionalen Feldes</A></B><BR>
<B><BR><CENTER><IMG SRC="feld1a.gif" ALT="Figure feld1a not displayed."></CENTER><BR></B><BR>
<PRE>
(2)   int matrix[2][3] = {{28,17,43},{9,12,13}};
 
                            /* Feldelemente 0,0 - 0,2: 28,17,43        */
                            /* Feldelemente 1,0 - 1,2: 9,12,13         */
</PRE>
<P><B><A NAME="FIGFELD2" HREF="#FT_FIGFELD2">Abbildung 5. Initialisierung eines zweidimensionalen Feldes</A></B><BR>
<B><BR><CENTER><IMG SRC="feld2a.gif" ALT="Figure feld2a not displayed."></CENTER><BR></B><BR>
<PRE>
(3)   int karten[5][4][3] = {0};   /* alle Feldelemente werden 0 * /
</PRE>
<P><B><A NAME="FIGFELD3" HREF="#FT_FIGFELD3">Abbildung 6. Initialisierung eines dreidimensionalen Feldes</A></B><BR>
<B><BR><CENTER><IMG SRC="feld3a.gif" ALT="Figure feld3a not displayed."></CENTER><BR></B><BR>
<P>Bei der Ansprache von Feldern mu&szlig; ber&uuml;cksichtigt werden,
da&szlig; einzelne Elemente angesprochen werden und nicht das gesamte Feld.
<P>Beispiel:
<P>Dem Element '0,2' eines Feldes <TT>a</TT>, das zun&auml;chst mittels
einer Schleife initialisiert wird, wird ein Wert zugewiesen:
<P>
<PRE>
 int a[3][8], i, j;        /* Deklaration eines zweidimensionalen Feldes mit */
                           /* drei Zeilen mit je acht Spalten                */
 
 for(i=0; i &lt; 3; i++)      /* Start der &auml;u&szlig;eren Schleife f&uuml;r die Zeilen      *
/
 {
    for(j=0; j &lt; 8; j++)   /* Start der inneren Schleife f&uuml;r die Spalten     */
        a[i][j] = 0;       /* Initialisierung der Spalten + Ende der inneren */
 }                         /* Ende der &auml;u&szlig;eren Schleife                      */
 a[0][2] = 6;              /* Zuweisung des Wertes                           */
</PRE>
<P>
<P><H4><A NAME="Header_48">3.2.1.4 &Uuml;bergabe von Feldern an Funktionen</A></H4>
<P>Bei der &Uuml;bergabe eines Feldes an eine Funktion
(siehe auch Kapitel <A HREF="#HDROWN">5.0, "Eigene Funktionen"</A>)
ist zu beachten, da&szlig; nicht das gesamte
Feld kopiert und &uuml;bergeben werden sollte, sondern nur die Adresse
des ersten Elementes. Dies hat zur Folge, da&szlig;
die Menge der Elemente als
eigenst&auml;ndiger Wert &uuml;bergeben werden mu&szlig;, was die
Angabe der Menge der Elemente innerhalb der Klammern ( [ ] )
&uuml;berfl&uuml;ssig macht.
<P>Beispiel:
<P>
<PRE>
  /*********************************************************************/
  /*** SUMME.C      summiert die Werte eines Feldes und &uuml;bergibt das ***/
  /***              Ergebnis an die aufrufende Funktion              ***/
  /*********************************************************************/
  #include &lt;stdio.h&gt;
  double summieren (double a[], int n)      /* Deklarationskopf der    */
  {                                         /* Funktion 'summieren'    */
     int i;                                 /* Deklaration der lokalen */
     double summe=0.0;                      /* Variablen i und s       */
 
     for (i=0; i&lt;n; i++)                    /* Start der Schleife      */
          summe = summe + a[i];             /* Werte aufsummieren      */
 
  /* for (i=0; i&lt;n; summe +=a[i++]);           w&auml;re auch m&ouml;glich       */
 
     return(summe);                         /* Summe zur&uuml;ckgeben       */
  }                                         /* Ende der Funktion       */
 
  void main(void)                           /* Start des Hauptprogramms*/
  {
   double x1[3] = {2, 4, 9};                /* Deklaration und Initi-  */
                                            /* alisierung des Feldes   */
   printf("\nSumme %f\n", summieren(x1,3)); /* Funktionsaufruf und Aus-*/
                                            /* gabe des Ergebnisses    */
  }
</PRE>
<P>
<P><H4><A NAME="HDRCHAIN">3.2.1.5 Zeichenketten - Strings</A></H4>
<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
<A NAME="IDX118"></A>
<P>
In C gibt es keinen eigenen Datentyp f&uuml;r Zeichenketten. Sie werden als
Felder (Kapitel <A HREF="#HDRFELD">3.2.1, "Felder - Array - Vektoren"</A>) von <TT>char</TT>-Werten
behandelt. Die Deklaration
<P>
<PRE>
  char zeichenkette[9];
</PRE>
definiert ein Feld mit Speicherplatz f&uuml;r neun Zeichen. Sie k&ouml;nnen wie
alle Felder mit <TT>zeichenkette[0], zeichenkette[1]</TT>
bis <TT>zeichenkette[8]</TT> angesprochen werden.
<P>Zu beachten ist, da&szlig; die letzte Feldkomponente f&uuml;r die bin&auml;re Null
(\0) reserviert sein mu&szlig;, wenn mit Funktionen zur
Zeichenkettenbearbeitung
(z.B. <TT>strcpy()</TT>) gearbeitet werden soll.
Die obige Deklaration w&uuml;rde dann nur Platz f&uuml;r acht Zeichen bieten!
Aus diesem Grund sollte immer folgenderma&szlig;en deklariert werden:
<PRE>
 
  char zeichenkette[9+1];    /* 9 Zeichen + bin&auml;re Null \0 */
  char zeichenkette2[10];    /* dito                       */
</PRE>
<P>
<P><H3><A NAME="HDRSTRUKT" HREF="#ToC_50">3.2.2 Strukturen</A></H3>
<A NAME="IDX119"></A>
<A NAME="IDX121"></A>
<A NAME="IDX122"></A>
<P>Im Gegensatz zum Feld werden in einer Struktur Daten
verschiedenen Typs verbunden.  Diese Verbindungen nach logischen
Gesichtspunkten werden auch <I>Datensatz</I> genannt.
<P>Beispiele:
<P>
Spielkarte
<BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Farbe
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Karte
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Punkte
</TD></TR></TABLE>
Pferd
<BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">Alter
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Geschlecht
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">Herkunft
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">Stall
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">Besitzer
</TD></TR></TABLE>
<P>Die Datentypen sind unterschiedlich: Alter = int, Geschlecht =
char, etc.
<P>
<P><P>
<P><H4><A NAME="Header_51">3.2.2.1 Deklaration von Strukturen</A></H4>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">struct expression</TH><TR><TD>
<PRE>
                                                     
>>--struct--+-identifier------------------------+--><
            |                                   |    
            |                    <---------<    |    
            +-+------------+--{--V-member--+--}-+    
              +-identifier-+                         
</PRE>
</TD></TR></TABLE>
<P>Im Vereinbarungsteil kennzeichnet das Schl&uuml;sselwort <TT>struct</TT>
den Beginn einer Strukturdefinition. Die Deklaration der Komponenten
wird in geschweifte Klammern (<TT>{ }</TT>) eingefa&szlig;t:
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">struct member</TH><TR><TD>
<PRE>
                                       
                    <-,-----------<    
>>--type specifier--V-declarator--+--><
</PRE>
</TD></TR></TABLE>
<P>
Beispiel:
<P>
<PRE>
   struct student {
          char         name[40+1];               /* Nachname           */
          char         vorname[40+1];            /* Vorname            */
          int          post_leit_zahl;           /* Postleitzahl       */
          char         wohnort[40+1];            /* Wohnort            */
          char         strasse_nr[40+1];         /* Strasse,Hausnummer */
          char         geb_dat[8+1];             /* Geb_Datum ttmmjjjj */
          int          mat_nr;                   /* Matrikelnr:        */
          float        noten[10];                /* Pr&uuml;fungsnoten      */
   };
</PRE>
<P>In dem obigen Beispiel wird ein Datensatz <I>student</I>
definiert, allerdings noch
kein Speicherplatz reserviert. Dem Compiler wird hierdurch nur
der Name <I>student</I> und der Aufbau der Struktur bekannt gemacht.
<P>Wird eine Variable dieser Struktur ben&ouml;tigt, so kann sie mit
<P>
<PRE>
   struct student stu_daten;
</PRE>
<P>
definiert werden. Es wurde der Datensatz
<I>stu_daten</I> unter Verwendung der Datenstruktur
<I>student</I> mit einer
Gr&ouml;&szlig;e von 221 Byte vereinbart. Die acht Elemente des Datensatzes
<I>stu_daten</I> sind somit folgende:
<P><B><A NAME="FIGSTUDENT" HREF="#FT_FIGSTUDENT">Abbildung 7. Datensatz stu_daten</A></B><BR>
<B><BR><CENTER><IMG SRC="student.gif" ALT="Figure student not displayed."></CENTER><BR></B><BR>
<P>Um die beiden Schritte Strukturdefinition und
Datensatzvereinbarung zusammenzufassen, kann folgende Form
gew&auml;hlt werden:
<P>
<PRE>
   struct student {
          char         name[40+1];               /* Nachname           */
          char         vorname[40+1];            /* Vorname            */
          int          post_leit_zahl;           /* Postleitzahl       */
          char         wohnort[40+1];            /* Wohnort            */
          char         strasse_nr[40+1];         /* Strasse,Hausnummer */
          char         geb_dat[8+1];             /* Geb_Datum ttmmjjjj */
          int          mat_nr;                   /* Matrikelnr:        */
          float        noten[10];                /* Pr&uuml;fungsnoten      */
    } <B>stu_daten</B>&#59;
</PRE>
<P>Sollen mehrere Datens&auml;tze mit der gleichen Struktur definiert
werden, so k&ouml;nnen die Namen dieser Datens&auml;tze durch Kommata
getrennt hintereinander angegeben werden.
<P>
<PRE>
   struct student {
          char         name[40+1];               /* Nachname           */
          char         vorname[40+1];            /* Vorname            */
          int          post_leit_zahl;           /* Postleitzahl       */
          char         wohnort[40+1];            /* Wohnort            */
          char         strasse_nr[40+1];         /* Strasse,Hausnummer */
          char         geb_dat[8+1];             /* Geb_Datum ttmmjjjj */
          int          mat_nr;                   /* Matrikelnr:        */
          float        noten[10];                /* Pr&uuml;fungsnoten      */
    } <B>stu_daten1</B>, <B>stu_daten2</B>,
      <B>stu_daten3</B>&#59;
</PRE>
<P><H4><A NAME="Header_52">3.2.2.2 Felder von Strukturen</A></H4>
<A NAME="IDX124"></A>
<P>Soll ein Feld von Strukturen definiert werden, so ist dem Namen der
Strukturvariablen die Felddefinition anzuf&uuml;gen:
<P>
<PRE>
   struct student {
          char         name[40+1];               /* Nachname           */
          char         vorname[40+1];            /* Vorname            */
          int          post_leit_zahl;           /* Postleitzahl       */
          char         wohnort[40+1];            /* Wohnort            */
          char         strasse_nr[40+1];         /* Strasse,Hausnummer */
          char         geb_dat[8+1];             /* Geb_Datum ttmmjjjj */
          int          mat_nr;                   /* Matrikelnr:        */
          float        noten[10];                /* Pr&uuml;fungsnoten      */
    } <B>stu_daten[10]&#59;</B>
</PRE>
<P>
<P><H4><A NAME="HDRSTRDEF">3.2.2.3 Strukturen mit Typendefinitionen - typedef</A></H4>
<A NAME="IDX125"></A>
<A NAME="IDX127"></A>
<P>Wem diese zusammengefa&szlig;te Schreibweise zu un&uuml;bersichtlich ist,
kann der Struktur auch einen eigenen Typ zuweisen:
<P>
<PRE>
   <B>typedef</B>
 
   struct {
          char         name[40+1];               /* Nachname           */
          char         vorname[40+1];            /* Vorname            */
          int          post_leit_zahl;           /* Postleitzahl       */
          char         wohnort[40+1];            /* Wohnort            */
          char         strasse_nr[40+1];         /* Strasse,Hausnummer */
          char         geb_dat[8+1];             /* Geb_Datum ttmmjjjj */
          int          mat_nr;                   /* Matrikelnr:        */
          float        noten[10];                /* Pr&uuml;fungsnoten      */
   } <B>STUDENT</B>&#59;
</PRE>
<P>Mit dieser Anweisung wird der Typ <I>Student</I> definiert
und dem Compiler der Name und der Aufbau bekannt gemacht. Variablen
k&ouml;nnen jetzt durch
<P>
<PRE>
   STUDENT stu_daten;
</PRE>
<P>vereinbart werden. Es ist somit ein neuer Datentyp angelegt
worden. Um deutlich zu machen, da&szlig; es sich um
einen neu definierten Typ handelt, sollte der Name
(z.B. <I>STUDENT</I>) gro&szlig; geschrieben werden.
<P>
<P><H4><A NAME="Header_54">3.2.2.4 Zugriff auf Strukturkomponenten</A></H4>
<A NAME="IDX129"></A>
<P>Der Zugriff auf einzelne Komponenten einer Struktur in C ist an
die Vorgehensweise der vollqualifizierten Ansprache in
Programmiersprachen wie z.B. PL/1 oder Cobol angelehnt:
<P>
<PRE>
   strukturvariable.strukturkomponente
</PRE>
<BR>
Beispiel:
<P>
<PRE>
   strcpy(stu_daten.name, "Meyer");
   stu_daten.noten[0] = 2;
</PRE>
<P>Dem Element <TT>stu_daten.name</TT> wird die Zeichenkette
<TT>Meyer</TT> und dem Element <TT>stu_daten.noten[0]</TT> wird
die Zahl 2 zugewiesen.
<P>Wenn &uuml;ber einen Zeiger (siehe <A HREF="#HDRZEI">3.2.4, "Zeiger - Pointer"</A>) auf
Strukturkomponenten zugegriffen werden sollen, mu&szlig; folgende
Syntax verwendet werden:
<P>
<PRE>
   zeiger_auf_struktur-&gt;strukturkomponente
</PRE>
<P><H4><A NAME="Header_55">3.2.2.5 Initialisierung von Strukturen</A></H4>
<A NAME="IDX131"></A>
<P>Eine Struktur kann entweder direkt bei der Deklaration der
Struktur oder bei der Deklaration der Strukturvariablen mit
Werten initialisiert werden.
<BR>
Beispiel:
<P>
(1)   Bei der Deklaration einer Strukturvariablen:
<P>
<PRE>
   struct datum {
       int  tag;
       char monat[10+1];
       int  jahr;
   };
 
   struct datum jahr_tag = {1,"Januar",1994};
</PRE>
<P>
(2)   Bei der Deklaration der Struktur:
<P>
<PRE>
   struct datum {
          int  tag;
          char monat[10+1];
          int  jahr;
   } jahr_tag = {1,"Januar",1994};
</PRE>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">Hinweis</TH><TR><TD>
Nur als extern oder static (siehe
Abschnitt <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>)
definierte Strukturen d&uuml;rfen direkt im Anschlu&szlig; an die Deklaration
der Struktur initialisiert werden.
</TD></TR></TABLE>
<P><P>
<P><H3><A NAME="HDRUNION" HREF="#ToC_56">3.2.3 Unions</A></H3>
<A NAME="IDX132"></A>
<A NAME="IDX134"></A>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">union expression</TH><TR><TD>
<PRE>
                                                
                              <---------<       
>>--union--+------------+--{--V-member--+--}--><
           +-identifier-+                       
</PRE>
</TD></TR></TABLE>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">union member</TH><TR><TD>
<PRE>
                                       
                    <-,-----------<    
>>--type specifier--V-declarator--+--><
</PRE>
</TD></TR></TABLE>
<P>Unions bestehen wie Strukturen aus mehreren Komponenten
unterschiedlichen Datentyps. F&uuml;r eine
Struktur wird Speicherplatz zur Verf&uuml;gung gestellt, der in seiner Gr&ouml;&szlig;e
der Summe der Gr&ouml;&szlig;e der Strukturkomponenten entspricht. F&uuml;r eine Union
wird nur die Speicherkapazit&auml;t reserviert, die notwendig ist, um die
speicheraufwendigste der Union-Komponenten
speichern zu k&ouml;nnen. Der Sinn besteht
darin, Speicherplatz zur Verf&uuml;gung zu stellen, der zu verschiedenen
Zeiten Werte verschiedenen Datentyps aufnehmen kann.
<P>Der Speicherplatz jeder Union-Komponente beginnt an der gleichen
Speicheradresse. Das bedeutet, da&szlig; immer nur der Wert einer
Union-Komponente gespeichert werden kann,
der vorherige Wert wird &uuml;berschrieben. Syntaktisch
unterscheiden sich die Unions nur durch das Schl&uuml;sselwort
<TT>union</TT> von
den Strukturen, die Variablendeklaration erfolgt nach dem Muster der
Strukturvariablendefinition
und auch der Zugriff erfolgt wie bei den Strukturen &uuml;ber den
Punktoperator (vollqualifizierte Ansprache). Das folgende Beispiel
zeigt, wie derselbe Speicherplatz einmal einen Integerwert und einmal
einen Floatwert zugewiesen bekommt:
<P>
<PRE>
/*******************************************************************/
/* Programm: Union_1.c                                             */
/* Datum   : September 1994                                        */
/* Autor   : Sascha Kliche, Daniel Wolkenhauer                     */
/* Beschreibung:                                                   */
/* Die Wirkungsweise und die Verwendung von UNIONS wird an der     */
/* Zuweisung eines float- und eines integer-Wertes auf denselben   */
/* Speicherplatz demonstriert.                                     */
/*******************************************************************/
 
#include &lt;stdio.h&gt;
 
/*
 * Deklaration der Komponenten der Union
 */
union my_union
{
   float float_num;
   int   int_num;
};
 
void main(void)
{
   /*
    * Deklaration einer Union-Variablen mit der Struktur my_union
    */
   union my_union union_komp;
 
   /*
    * Zuweisung eines Integerwertes und Ausgabe
    */
   union_komp.int_num = 23;
   printf("Der aktuelle Wert der Union-Variablen ist: %d \n",
           union_komp.int_num);
 
   /*
    * Zuweisung eines Floatwertes und Ausgabe
    */
   union_komp.float_num = 19.87;
   printf("Der aktuelle Wert der Union-Variablen ist: %f \n",
           union_komp.float_num);
}
</PRE>
<P>
<P><H3><A NAME="HDRZEI" HREF="#ToC_57">3.2.4 Zeiger - Pointer</A></H3>
<A NAME="IDX135"></A>
<A NAME="IDX136"></A>
<A NAME="IDX138"></A>
<P>Zeiger haben in C eine besondere Stellung, sie werden
intensiver genutzt als in anderen Programmiersprachen.
Das besondere an ihnen ist,
da&szlig; sie als Inhalt bzw. Wert die Speicheradresse einer
anderen Variablen
<A NAME="Footnote_Used_6" HREF="#Footnote_6" ><SUP>6</SUP></A>
eines bestimmten Typs aufnehmen.
Die Variablen eines Programmes stehen im Datenbereich
ihres Prozesses. Der Proze&szlig;
sieht die Adressen nicht absolut zum Anfang des
Hauptspeichers, sondern relativ zur Anfangsadresse
des Datenbereichs des Prozesses. F&uuml;r einen Proze&szlig;
ist demnach die Adresse einer Variablen die Nummer
des ersten Bytes der Variablen relativ zum Beginn des
Datenbereiches. Ein Pointer hat als Wert diese
Adresse einer Variablen.
Pointer werden vereinbart wie Variablen und erhalten
wie diese Speicherplatz reserviert.
<P><B><A NAME="FIGPOINTER" HREF="#FT_FIGPOINTER">Abbildung 8. Zeiger</A></B><BR>
<B><BR><CENTER><IMG SRC="pointer.gif" ALT="Figure pointer not displayed."></CENTER><BR></B><BR>
<BR>
<P><B><A NAME="Table_8" HREF="#FT_Table_8">Tabelle 8. Zeiger im Speicher</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="31%">Wert an der Speicheradresse
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">...
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">
<BR></TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">100
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">
<BR></TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">...
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">
<BR></TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">354
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">
<BR></TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">...
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="31%">Speicheradresse
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">...
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">46
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">50
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">54
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">...
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">96
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">100
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">104
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="8%">...
</TD></TR></TABLE>
<P>Aus diesem Beispiel ergibt sich:
<UL>
<P><LI>p ist ein Zeiger.
<P><LI>Der Wert von p ist 100, dieser Wert wird als Adresse
interpretiert.
<P><LI>Der Zeiger p zeigt auf den Wert 354, der an der Adresse 100
gespeichert ist.
</UL>
<P>Zeiger k&ouml;nnen einerseits sehr hilfreich sein, stellen
andererseits ein hohes Risiko dar, da durch Fehler bei der
Benutzung von Zeigern auf ung&uuml;ltige Speicheradressen
zugegriffen werden kann. Diese Zugriffe f&uuml;hren unter
Betriebssystemen mit gesch&uuml;tzten Adre&szlig;r&auml;umen sofort zum
Programmabsturz. Das einzig sichere ist ein Zeiger auf
NULL,
<A NAME="IDX139"></A>
hier wird garantiert, da&szlig; der Zeiger definitiv auf
keine Speicherstelle zeigt.
<P><H4><A NAME="Header_58">3.2.4.1 Vereinbarung von Zeigern</A></H4>
<A NAME="IDX141"></A>
<P>Zeiger m&uuml;ssen wie Variablen im Vereinbarungsteil definiert werden.
Um deutlich zu machen, da&szlig; es sich um einen Zeiger handelt, sollte
der Bezeichner mit einem p f&uuml;r Pointer oder z f&uuml;r Zeiger beginnen.
Ein Zeiger wird durch das Zeichen <TT>*</TT> vor dem Bezeichner von
Variablen unterschieden (Pflicht):
<P>
<PRE>
   int   *zi;    /* Zeiger auf int    */
   float *zf;    /* Zeiger auf float  */
</PRE>
<P>Auch Zeigern wird ein Datentyp zugewiesen. Dieser
interpretiert den Datentyp der
Variablen, auf die der Zeiger zeigt, und nicht den eigenen
Datentyp des Zeigers. Alle Adressen sind vom Typ Integer.
<P><H4><A NAME="Header_59">3.2.4.2 Anwendung von Zeigern</A></H4>
<A NAME="IDX143"></A>
<P>Um die Adresse einer Variablen zu ermitteln und sie dem
Zeiger zu &uuml;bergeben, verwendet C den un&auml;ren Operator
<TT>&amp;</TT>.
<A NAME="IDX144"></A>
Nach der obigen Vereinbarung ergibt sich nun folgende 
m&ouml;gliche Zuweisung:
<P>
<PRE>
   int   n, *pi;
   float x, *pf;
 
      pi = &n;
      pf = &x;
</PRE>
<P>Nach dieser Zuweisung enth&auml;lt <TT>pi</TT> die Adresse
von <TT>n</TT> und <TT>pf</TT> die Adresse von <TT>x</TT>.
Den Zugriff auf den Inhalt einer Adresse nennt man
Dereferenzierung. Mit
Hilfe der Dereferenzierung ist es m&ouml;glich, nur unter Nutzung der
Adresse eines anderen Objektes, dessen Wert zu &auml;ndern.
<P>Beispiel:
<P>
<PRE>
/********************************************************************/
/* Programm: zeiger.c                                               */
/* Autor   : Sascha Kliche, Daniel Wolkenhauer                      */
/* Datum   : September 1994                                         */
/* Beschreibung:                                                    */
/* Dieses Programm verdeutlich die Dereferenzierung: den Zugriff    */
/* auf den Inhalt einer Speicheradresse.                            */
/********************************************************************/
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
 
   void main(void)
   {
   int  objekt = 0;          /* Int-Variable mit 0 initialisieren      */
   int *zeiger;              /* Zieger auf Int deklarieren             */
 
      zeiger  = &objekt;     /* (1) Speicheradresse (objekt) an zeiger */
      objekt  = 4;           /* normale Zuweisung mit dem Wert 4       */
 
      *zeiger = 5;           /* (2) Speicherplatz von objekt = 5       */
   }
</PRE>
<P>In Zeile (1) wird der Zeigervariablen <TT>zeiger</TT> die
Speicheradresse eines Objekts (hier: der Integervariablen
<TT>objekt</TT>) &uuml;bergeben. Dem Objekt wird dazu der un&auml;re
Adre&szlig;operator (&) vorangestellt. Mit seiner Hilfe wird nicht der Wert
der Variablen <TT>objekt</TT> (zu dieser Zeit = 0) zugewiesen,
sondern, die Adresse, an der der Wert im Speicher abgelegt ist.
<P>Die eigentliche Dereferenzierung findet in Zeile (2) statt. Nur mit
Hilfe der Adresse wird auf einen Speicherinhalt 'zugegriffen'. In
diesem Fall wird der Inhalt (4) mit einem neuen Wert (5) &uuml;berschrieben.
<P>Folgende Zuweisungen sind beispielsweise erlaubt:
<PRE>
int zahl=3; zahl2=0, *ptr_zahl=NULL, *ptr_zahl2=NULL;
 
ptr_zahl=&zahl;         /* adresse von zahl zuweisen   */
ptr_zahl2=ptr_zahl;     /* adresse von zahl &uuml;bernehmen */
zahl=(int)ptr_zahl;     /* adresse von zahl an zahl &uuml;bergeben */
 
*ptr_zahl=5;            /* zahl den wert 5 zuweisen, entspricht zahl=5 */
zaehl2=*ptr_zahl;       /* wert von zahl an zahl2 &uuml;bergeben            */
 
ptr_zahl2=(int *)*ptr_zahl; /* inhalt von zahl als adresse an
                               ptr_zahl2 &uuml;bergeben */
</PRE>
<P>Ung&uuml;ltig sind beispielsweise folgende Zuweisungen:
<PRE>
int zahl=3; zahl2=0, *ptr_zahl=NULL, *ptr_zahl2=NULL;
 
zahl=ptr_zahl;           /* eine adresse kann nicht einer int
                            variablen &uuml;bergeben werden         */
*ptr_zahl=&zahl;         /* dito                               */
 
ptr_zahl=*zahl;          /* zahl enth&auml;lt keine adresse         */
 
ptr_zahl2=*ptr_zahl;     /* einem zeiger mu&szlig; eine adresse
                            &uuml;bergeben werden                   */
</PRE>
<P>Beispielprogramm:
<PRE>
void main(void)
{
  int zahl=3, *ptr_zahl=NULL;
 
  ptr_zahl=&zahl;
 
  printf("\nAdresse von ptr_zahl = %d",&ptr_zahl);
  printf("\nInhalt von ptr_zahl = %d",ptr_zahl);
  printf("\nAdresse von zahl = %d",&zahl);
  printf("\nInhalt von zahl = %d",zahl);
  printf("\nWert von *ptr_zahl = %d",*ptr_zahl);
}
/*
Ausgabe: (Adressenangaben &auml;ndern sich)
 
Adresse von ptr_zahl = 166004
Inhalt von ptr_zahl = 166008
Adresse von zahl = 166008
Inhalt von zahl = 3
Wert von *ptr_zahl = 3
*/
</PRE>
<P><H4><A NAME="Header_60">3.2.4.3 Zeiger und Felder</A></H4>
<A NAME="IDX146"></A>
<P>Zeiger und Felder sind eng miteinander verbunden. Die Deklaration
eines Feldes bewirkt, da&szlig; im Heap ein Speicherbereich der angegebenen
Gr&ouml;&szlig;e reserviert und im Stack ein Zeiger auf diesen Speicherbereich
hinterlegt wird.
<PRE>
char zeichen[10];
char ptr;
</PRE>
<P><TT>zeichen</TT> enth&auml;lt die Adresse von <TT>zeichen[0]</TT>.
<TT>&zeichen[0];</TT> entspricht also <TT>ptr</TT>.
<TT>zeichen</TT> entspricht ebenfalls <TT>ptr</TT>.
Daraus ergibt sich, da&szlig; <TT>&zeichen[0];</TT>
<TT>zeichen</TT> entspricht. Die Adresse einer Zeichenkette kann
einem Zeiger auf Zeichen also nur als Adresse eines Elementes der
Zeichenkette &uuml;bergeben werden (z.B. <TT>ptr=zeichen;</TT> oder
<TT>ptr=&zeichen[0];</TT> oder <TT>ptr=&zeichen[8];</TT>).
Hier ist auf die korrekte Benutzung des Adre&szlig;operators (&) zu
achten.
<P>&Auml;quivalente Ausdr&uuml;cke:
<PRE>
ptr           &zeichen[0]
ptr           zeichen
*ptr          zeichen[0]
*(ptr+1)      zeichen[1]
*(ptr+n)      zeichen[n]
 
zeichen       &zeichen[0]
</PRE>
<P>Das folgende Beispiel demonstriert, wie mittels Zeigerarithmetik
ein Zeichenfeld mit der Deklaration <TT>char **argv</TT> bzw.
<TT>char *argv[]</TT> 
<A NAME="IDX148"></A>
analysiert werden kann. Das Beispiel
nutzt Zeiger intensiv und sollte nur dann angewendet werden,
wenn man es wirklich versteht, da es auch einige Fallstricke
beinhaltet.
<P>
<PRE>
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
void main(int argc, char *argv[])
{
  int anzparms=0, t_parameter=0;
  char name_in[255+1], name_out[255+1];
  char usage[35]="Hier steht ein Hilfekommentar.\0";
 
  argv++;                            /* auf zweiten parameter wechseln    */
                                     /* erster Parameter ist Programmname */
  argc--;                            /* anzahl parameter dekrementieren   */
  while(argc&gt;0)
  {
    if (**argv=='-' &#124;&#124; **argv=='/')  /* erstes Zeichen gleich - oder / ?  */
    {
      (*argv)++;                     /* ein zeichen weiter                */
      if(**argv!='\0')               /* zugriff auf zeichen nach - oder / */
        switch(**argv)
        {
          case 'h':
          {
            printf("%s",usage);
            exit(1);
            break;
          }
          case 't': t_parameter=1;
                    break;
          default : printf("Unrecognized parameter '-%c' ignored.",**argv);
                    break;
        }                            /* ende switch                       */
    }                                /* ende - oder / im parameter        */
    else
    {                                /* dateinamen zuweisen               */
       anzparms++;
       if(anzparms&lt;3)
       {
         if(anzparms==1) strcpy(name_in,*argv);
         if(anzparms==2) strcpy(name_out,*argv);
       }
       else
         printf("Unrecognized parameter '%s' ignored.\n",*argv);
    }                                /* ende dateinamen zuweisen          */
    argv++;
    argc--;
  }                                  /* while argc&gt;0                      */
}                                    /* ende main                         */
</PRE>
<P><B><A NAME="FIGPOINT1" HREF="#FT_FIGPOINT1">Abbildung 9. Zeiger</A></B><BR>
<B><BR><CENTER><IMG SRC="point1.gif" ALT="Figure point1 not displayed."></CENTER><BR></B><BR>
<P><B><A NAME="FIGPOINT2" HREF="#FT_FIGPOINT2">Abbildung 10. Zeiger</A></B><BR>
<B><BR><CENTER><IMG SRC="point2.gif" ALT="Figure point2 not displayed."></CENTER><BR></B><BR>
<P><P>
<HR><H2><A NAME="Header_61" HREF="#ToC_61">3.3 Weitere Datentypen</A></H2>
<P><H3><A NAME="HDRVOID" HREF="#ToC_62">3.3.1 void</A></H3>
<A NAME="IDX149"></A>
<A NAME="IDX151"></A>
<P>Der Datentyp <TT>void</TT> hat keinen Wertebereich und kommt
immer dann zum Einsatz, wenn kein bestimmter Datentyp erforderlich
ist bzw. um zu kennzeichnen, da&szlig; Funktionen keine Parameter
erwarten oder keinen Wert zur&uuml;ckgeben.
<P><H3><A NAME="HDRENUM" HREF="#ToC_63">3.3.2 enum</A></H3>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>
<A NAME="IDX155"></A>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">enum</TH><TR><TD>
<PRE>
                                                   
                             <-,-----------<       
>>--enum--+------------+--{--V-enumerator--+--}--><
          +-identifier-+                           
</PRE>
</TD></TR></TABLE>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">enumerator</TH><TR><TD>
<PRE>
                                             
>>--identifier--+-----------------------+--><
                +-= constant expression-+    
</PRE>
</TD></TR></TABLE>
<P>Eine Enumeration (Aufz&auml;hlung)
repr&auml;sentiert eine bestimmte Menge an Werten, die
der Programmierer definiert. Eine Enumeration ist in C immer vom Typ
<TT>int</TT>. Die definierten Werte einer Enumeration werden nacheinander
durchnumeriert und somit auf den Datentyp <TT>int</TT> umgelegt.
Die Deklaration umfa&szlig;t das Schl&uuml;sselwort <TT>enum</TT> gefolgt von
einem Bezeichner und einer Liste der Aufz&auml;hlungen (enumerators).
Die Elemente der Aufz&auml;hlung werden auch enumeration constants genannt.
Die Liste der Aufz&auml;hlungen wird in geschweifte Klammern eingefa&szlig;t und jede
Aufz&auml;hlung ist durch ein Komma abgetrennt.
<BR>
Beispiel:
<PRE>
enum monate { Januar=1, Februar, Maerz, April, Mai, Juni, Juli,
              August, September, Oktober, November, Dezember };
</PRE>
<P>Die Monatsbezeichnungen werden, bei eins beginnend, aufsteigend
numeriert, Januar=1 bis Dezember=12. Normalerweise beginnt die
Numerierung mit dem ersten Element bei Null.
Diese Numerierung erm&ouml;glicht die Benutzung
der Bezeichnungen anstatt der Nummern im Programmcode. Jedes
Aufz&auml;hlungselement darf in seinem G&uuml;ltigkeitsbereich nur einmal definiert
werden.
<P>Die Numerierung kann bei jedem Element der Aufz&auml;hlungsliste beeinflu&szlig;t
werden:
<PRE>
 enum status { run, create, delete=5, suspend };
</PRE>
 Der Datentyp <TT>status</TT> repr&auml;sentiert die folgenden Werte:
<PRE>
 Enumeration         Integer
 Constant            Representation
 
 run                 0
 create              1
 delete              5
 suspend             6
</PRE>
<P>Enumeration Variablen werden wie folgt definiert:
<PRE>
enum monate { Januar=1, Februar, Maerz, April, Mai, Juni, Juli,
              August, September, Oktober, November, Dezember } monat1, monat2;
 
enum monate monat3 = April;
</PRE>
<P>In diesem Beispiel werden die Variablen <TT>monat1, monat2</TT> und
<TT>monat3</TT> definiert, wobei der Variablen <TT>monat3</TT> der
Wert <TT>April</TT> (repr&auml;sentiert die Nummer 4) zugewiesen wird.
<HR><H2><A NAME="Header_64" HREF="#ToC_64">3.4 Datentypumwandlung</A></H2>
<A NAME="IDX156"></A>
<P>Bei der Datentypumwandlung wird danach unterschieden, ob der
Programmierer regelnd eingreift (explizit) oder ob das System
von sich aus (implizit) ohne Dazutun des Programmierers eine
Umwandlung durchf&uuml;hrt.
<P>
<P><H3><A NAME="Header_65" HREF="#ToC_65">3.4.1 Implizite Datentypumwandlung</A></H3>
<A NAME="IDX158"></A>
<P>Der C-Compiler wandelt verschiedene Datentypen
grunds&auml;tzlich in festgelegte andere Datentypen um,
um die M&ouml;glichkeiten des jeweils verwendeten
Computersystems maximal ausnutzen zu k&ouml;nnen. Welche
Datentypen in welche umgewandelt werden, ist der Dokumentation
der jeweiligen Entwicklungsumgebung zu entnehmen.
<P>Weiterhin gilt, da&szlig; bei der Verwendung von verschiedenen
Datentypen bei einer Zuweisung das Ergebnis der Berechnung
rechts vom Gleichheitszeichen immer in den Datentyp des Operanden links
vom Gleichheitszeichen umgewandelt wird. Dies gilt auch, wenn links mit
<TT>int</TT>-Werten und rechts mit rationalen Zahlen gerechnet
wird!
<P>Abschlie&szlig;end ist zu beachten, da&szlig; beim Zusammentreffen
verschiedener Datentypen in einer Berechnung immer mit dem
speicheraufwendigeren gerechnet wird.
<P>
<P><H3><A NAME="Header_66" HREF="#ToC_66">3.4.2 Explizite Datentypumwandlung</A></H3>
<A NAME="IDX159"></A>
<A NAME="IDX160"></A>
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>
<P>Der Programmierer kann einen Operanden allerdings auch bewu&szlig;t
ver&auml;ndern. Dazu kann ein sogenannter <I>Cast</I> benutzt werden. Ein
Cast ist eine Datentypbezeichnung, die dem zu ver&auml;ndernden Operanden
vorangestellt wird.
<BR>
Beispiel:
<P>
<PRE>
   int ganz_1, ganz_2;
   double  dopp;
 
   dopp = (float)ganz_1 * (long)ganz_2;
</PRE>
<P>Die Variablen <TT>ganz_1</TT> und
<TT>ganz_2</TT> werden als normal-integer
definiert. Durch den Cast-Operator wird <TT>ganz_1</TT> in eine
rationale Zahl und <TT>ganz_2</TT> in eine ganze Zahl mit doppelter
Genauigkeit explizit umgewandelt. Allerdings ver&auml;ndert der
C-Compiler <TT>ganz_2</TT> eigenst&auml;ndig in den speicheraufwendigeren
Typ (<TT>float</TT>). <TT>float</TT> wird allerdings gleich
in <TT>double</TT> konvertiert.
Das Ergebnis der Berechnung <TT>ganz_1 * ganz_2</TT> w&auml;re
ohnehin implizit in <TT>double</TT> umgewandelt worden, da es
sich bei dem links vom Gleichheitszeichen stehenden Operanden um eine
Gleitkommavariable mit doppelter Genauigkeit handelt.
<P>
<HR><H2><A NAME="HDROWNTYPE" HREF="#ToC_67">3.5 Eigene Typen - typedef</A></H2>
<A NAME="IDX164"></A>
<A NAME="IDX166"></A>
<P>Es besteht in C die M&ouml;glichkeit, eigene Datentypen zu
deklarieren (siehe auch Beispiel in <A HREF="#HDRSTRDEF">3.2.2.3, "Strukturen mit Typendefinitionen - typedef"</A>).
Dies dient vor allem der &Uuml;bersichtlichkeit, da nicht wirklich neue
Datentypen erzeugt werden, sondern lediglich alte Datentypen einen
neuen Namen erhalten. Dazu wird das Schl&uuml;sselwort <TT>typedef</TT>
verwendet. Der neu vereinbarte Name kann daraufhin als neuer
Datentypbezeichner verwendet werden.
<P>
<PRE>
   typedef float REAL;
   typedef int INTEGER;
   typedef int *PTR_TO_INT;
</PRE>
<P>Dadurch werden die Typbezeichner REAL, INTEGER und PTR_TO_INT
vereinbart. Sie k&ouml;nnen in nachfolgenden Vereinbarungen als
Datentypbezeichner verwendet werden:
<P>
<PRE>
   REAL x, y;               /* entspr.: float x, y;   */
   INTEGER a, b,;           /* entspr.: int a, b      */
   PTR_TO_INT p1, p2;       /* entspr.: int *p1, *p2  */
</PRE>
<P>Die Gro&szlig;schreibung dient der Unterscheidung zwischen eigenen und
C-Datentypbezeichnern und sollte beibehalten werden.
<HR><H2><A NAME="HDRCLASSES" HREF="#ToC_68">3.6 Speicherklassen</A></H2>
<A NAME="IDX167"></A>
<P>Die Speicherklassen definieren genaue Bedingungen f&uuml;r die Art
und Weise der Speicherung der Daten eines Programmes. Durch diese
Bedingungen werden
<UL>
<P><LI>der G&uuml;ltigkeitsbereich (Programm, Modul, Lokal),
<P><LI>die Lebensdauer (dauerhaft, Blockdurchlauf) und
<P><LI>der Speicherort (Stack, Heap)
<A NAME="IDX168"></A>
<A NAME="IDX169"></A>
</UL>
vorgegeben.
<P>
<P><P>
<P><H3><A NAME="Header_69" HREF="#ToC_69">3.6.1 Automatic</A></H3>
<A NAME="IDX170"></A>
<A NAME="IDX172"></A>
<BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%">G&uuml;ltigkeitsbereich:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">Blocklokal
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%">Lebensdauer:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">Dauer des Blockdurchlaufs
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%">Speicherort:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">Stack (Stapel)
</TD></TR></TABLE>
<P>Datenelemente, die nicht explizit einer anderen Speicherklasse
angeh&ouml;ren und innerhalb eines Blockes, der durch geschweifte Klammern
eingefa&szlig;t ist, vereinbart werden, werden
vom Compiler automatisch der Speicherklasse <TT>auto</TT> zugewiesen.
Diese Datenelemente sind nur in dem Programmteil (Block)
verf&uuml;gbar, in dem sie definiert werden. Erst bei Aufruf des
Programmteils wird f&uuml;r sie Speicher auf dem sog. Stack
reserviert, der beim
Verlassen allerdings wieder freigegeben wird. Der Inhalt dieses
Datenelements bleibt nicht bis zum n&auml;chsten Blockaufruf erhalten.
<P>Hinweis: In der Regel kann der Begriff Block mit dem Begriff
Funktion
gleichgesetzt werden, da innerhalb einer Funktion normalerweise kein
neuer Block definiert wird, was jedoch zul&auml;ssig ist und bei einigen
Problemstellungen von Vorteil ist. Ein Datenelement
der Speicherklasse
<TT>auto</TT> ist somit in der Regel f&uuml;r die Dauer eines
Funktionsdurchlaufes und nur innerhalb dieser Funktion verf&uuml;gbar.
<P>Beispiel:
<P>
<PRE>
   auto int a,b,c;    oder
 
        int a,b,c;
</PRE>
<P>
<P><H3><A NAME="HDRSTATIC" HREF="#ToC_70">3.6.2 Static</A></H3>
<A NAME="IDX173"></A>
<A NAME="IDX175"></A>
<P>Bei Datenelementen der Speicherklasse <TT>static</TT>
unterscheidet man, wo diese definiert wird:
<P>(1) Innerhalb einer Funktion
<BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">G&uuml;ltigkeitsbereich:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Blocklokal
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Lebensdauer:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">gesamter Programmdurchlauf
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Speicherort:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Heap
</TD></TR></TABLE>
<P>(2) Au&szlig;erhalb einer Funktion
<BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">G&uuml;ltigkeitsbereich:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Modul
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Lebensdauer:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">gesamter Programmdurchlauf
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Speicherort:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"> Heap
</TD></TR></TABLE>
<P><TT>static</TT> (=dauerhafte) Datenelemente
k&ouml;nnen innerhalb oder
au&szlig;erhalb von Funktionen definiert werden.
Ein weiterer Unterschied zu <TT>auto</TT> Datenelementen
besteht darin, da&szlig; <TT>static</TT>-Variablen,
die innerhalb einer
Funktion vereinbart wurden, nicht aus dem Speicher gel&ouml;scht
werden, wenn die Funktion beendet wird. Damit stehen die Werte
bei einem erneuten Funktionsaufruf wieder zur Verf&uuml;gung und
werden auf dem sog. Heap abgelegt.
<P>Ein au&szlig;erhalb einer Funktion definiertes
<TT>static</TT> Datenelement, ist
in dem ganzen Modul - nicht aber in anderen Modulen, wie
<TT>extern</TT> Datenelemente - verf&uuml;gbar.
<P><TT>static</TT> Datenelemente sollten direkt nach den
Preprozessoranweisungen (z.B. <TT>#include</TT>)
deklariert werden.
<P>
<P><H3><A NAME="HDREXTERN" HREF="#ToC_71">3.6.3 Extern</A></H3>
<A NAME="IDX176"></A>
<A NAME="IDX178"></A>
<BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">G&uuml;ltigkeitsbereich:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Programm
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Lebensdauer:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">gesamter Programmdurchlauf
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Speicherort:
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Heap
</TD></TR></TABLE>
<P>Es besteht die M&ouml;glichkeit, globale Datenelemente in allen
Modulen zu benutzen. Diese Datenelemente gelten dann f&uuml;r alle
Module und sind von der
Speicherklasse <TT>extern</TT>. Innerhalb von anderen
Modulen kann auf extern definierte Elemente mit einem Verweis
(siehe Beispiel unten) zugegriffen werden.
<P>Auch Funktionen sind vom Typ <TT>extern</TT>.
<P>Beispiel:
<P>
<PRE>
Datei fc1.c
 
   #include &lt;stdio.h&gt;
 
   static int x=99;      /* nur im aktuellen Modul g&uuml;ltig        */
   int a=1, b=2, c=3;    /* Externe Variablen f&uuml;r alle Module    */
 
   int addieren(void);   /* Funktionsprototyp                    */
 
   void main(void)
   {
 
      printf("a=%3d b=%3d c=%3d\n", a,b,c);          /* 1  2  3 */
      printf("a+b+c=%3d\n",addieren());              /*    6    */
      printf("a=%3d b=%3d c=%3d\n", a,b,c);          /* ?  ?  3 */
 
   }  /* Ende von main */
 
 
Datei fc2.c
 
   int addieren(void)
   {
      extern int a, b, c;     /* Variablen aus anderem Modul          */
      static int g;           /* Wert der Var. bleibt erhalten        */
      int ergebnis;           /* Lokale Variable                      */
 
      g++;
      ergebnis=a+b+c;
      a=g;
      b+=g;
      return (a+b+c);
   }  /* Ende addieren */
 
</PRE>
<P>
<P><H3><A NAME="Header_72" HREF="#ToC_72">3.6.4 Register</A></H3>
<A NAME="IDX179"></A>
<A NAME="IDX181"></A>
<P>F&uuml;r Datenelemente der Speicherklasse <TT>register</TT>
gilt dasselbe wie f&uuml;r Datenelemente der Speicherklasse
<TT>auto</TT>, allerdings werden diese, sofern die Hardware
dies zul&auml;&szlig;t, in den Prozessorregistern gespeichert. Der
Zugriff auf die Prozessorregister ist um ein Vielfaches
schneller, als der Zugriff auf den Hauptspeicher.
<HR><H1><A NAME="HDRFUNK" HREF="#ToC_73">4.0 &Uuml;bersicht &uuml;ber wichtige Funktionen</A></H1>
<P>Im folgenden sollen einige Beispiele f&uuml;r wichtige Funktionen
vorgestellt werden, die C bereits mitliefert.
Bei diesen, bereits mitgelieferten Funktionen, handelt es sich um
sogenannte <I>Standardbibliotheksfunktionen</I>.
Standardbibliotheksfunktionen sind Funktionen, die C vordefiniert zur
L&ouml;sung bestimmter Aufgaben zur Verf&uuml;gung stellt. Sie sind in den
Definitionsdateien
(auch Include- oder Headerdateien, Dateien mit
der Erweiterung <TT>h</TT>)
festgelegt. Einige Verwirrung kann dadurch entstehen, da&szlig;
es so scheint, als handele es sich um einen Befehl. Dies
ist leider nicht zu vermeiden, da C auf dem Prinzip der Teilung
eines Problems in kleine L&ouml;sungsgruppen aufgebaut ist. Dies
wurde so konsequent durchgehalten, da&szlig; auch die scheinbaren
Befehle Funktionen darstellen, die aus einem kleinsten
Grundbefehlssatz (den Schl&uuml;sselw&ouml;rtern, siehe <A HREF="#HDRKEY">2.3, "Schl&uuml;sselworte"</A>) zusammengesetzt sind und durch
die Eingabe des scheinbaren Befehls nur die Definition der
Standardbibliotheksfunktion aus der Definitionsdatei eingef&uuml;gt wird.
Erst beim Linkvorgang wird der entsprechende Code eingebunden.
<P>
<HR><H2><A NAME="HDRPRF" HREF="#ToC_74">4.1 printf - formatierte Ausgabe auf dem Bildschirm</A></H2>
<A NAME="IDX182"></A>
<P>Die Funktion <TT>printf()</TT> dient zur formatierten Ausgabe von
Daten jeglicher Art. Es ist z.B. m&ouml;glich, die Form, in der Zahlen
ausgegeben werden zu beeinflussen.
<P>Die Syntax von <TT>printf()</TT> lautet:
<P>
<STRONG>
printf(const char <VAR>*format-string</VAR>, <VAR>argument-list</VAR>);
</STRONG>
<UL>
<P><LI><TT>const char</TT> stellt eine Zeichenkonstante dar, die so
ausgegeben wird, wie sie als Konstante vorliegt. Diese Konstante kann
sogenannte Fluchtsymbolzeichen (s.u.) beinhalten. Soll das
Prozentzeichen ausgegeben werden, mu&szlig; es doppelt (%%) in
der Zeichenkonstante vorkommen, da es ansonsten einen
Formatstring einleitet.
<BR>
<TT>*format string</TT> stellt die Formatspezifikation dar, die
festlegt, in welchem Format das jeweilige Argument ausgegeben werden
soll. Diese Formatstrings werden innerhalb der Zeichenkonstante
verwendet.
<P><LI>Die <TT>argument-list</TT> benennt die Variablen, die mit der
Anweisung ausgegeben werden sollen. Die Zuordnung Formatstring zu
Variable verl&auml;uft von links nach rechts. Das bedeutet, da&szlig; der zuerst
auftauchende Formatstring dem ersten Datenelement der argument-list
zugeordnet wird, der zweite Formatstring dem zweiten
Datenelement u.s.w. Die einzelnen Datenelemente
werden durch Kommata voneinander getrennt.
</UL>
<P>Beispiel:
<PRE>
           printf("Das %d. Ergebnis ist : %d\n", nummer, ergebnis);
</PRE>
<P><TT>Das Ergebnis ist &#58;</TT> stellt die
Zeichenkonstante dar, die unver&auml;ndert ausgegeben wird.
<P><TT>%d</TT> stellt den Formatstring
dar, der sich aus dem Prozentzeichen (<TT>%</TT>) und
dem Umwandlungszeichen <TT>d</TT> zusammensetzt.
Das Prozentzeichen kennzeichnet den Beginn einer
Formatspezifikation. Das <TT>d</TT> bedeutet, da&szlig; die hinter dem
Komma stehende Variable als Integervariable
interpretiert und da&szlig; der Wert der Variablen an der
durch <TT>d</TT> bezeichneten Stelle ausgegeben werden soll.
Der Formatstring kann noch weitere Zeichen enthalten, die weiter unten
vorgestellt werden.
<P>Dem ersten <TT>%d</TT> wird <TT>nummer</TT> zugeordnet, dem
zweiten <TT>%d</TT> wird <TT>ergebnis</TT> zugeordnet.
<P>Wenn Nummer den Wert 4 und Ergebnis den Wert 20 enth&auml;lt, sieht
die Ausgabe wie folgt aus:
<P>
<PRE>
Das 4. Ergebnis ist : 20
</PRE>
<P>Der Cursor steht nach der Ausgabe am Anfang der n&auml;chsten Zeile.
<P>
<P><H3><A NAME="HDRSPEZI" HREF="#ToC_75">4.1.1 Erl&auml;uterung des Formatstrings</A></H3>
<A NAME="IDX184"></A>
<P>
<P>Die folgende Formatspezifikation stellt den Aufbau des
Formatstrings dar.
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">printf() - Formatspezifikation</TH><TR><TD>
<PRE>
                                                                     
>>--%--+---------+--+----------+--+----------------+--+---+--type--><
       |         |  |          |  |                |  |-h-|          
       +--flags--+  +--Breite--+  +--.Genauigkeit--+  |   |          
                                                      |-L-|          
                                                      |   |          
                                                      +-l-+          
</PRE>
</TD></TR></TABLE>
<P>Die Formatspezifikationen beginnen mit einem Prozentzeichen (%) und
enden mit dem Umwandlungszeichen (<I>type</I>; z.B. d, s, c, f oder
e). Dazwischen k&ouml;nnen folgende Zeichen angef&uuml;hrt werden:
<OL TYPE=1>
<P><LI>Folgende Steuerzeichen (<I>flags</I>) in beliebiger Reihenfolge
<OL TYPE=a>
<P><LI>'-': linksb&uuml;ndige Ausgabe des Datenelements
<P><LI>'+': Zahlen werden immer mit Vorzeichen ausgegeben
<P><LI>'0': leere Stellen im Ausgabefeld mit f&uuml;hrenden/angeh&auml;ngten Nullen
f&uuml;llen
</OL>
<P><LI>eine Zahl, die die minimale Feldbreite festlegt (bei Bedarf
wird die Feldbreite vergr&ouml;&szlig;ert)
<P><LI>einen Punkt, der die Feldbreite von der Genauigkeit trennt und
eine Zahl f&uuml;r die Genauigkeit mit folgender Bedeutung:
<OL TYPE=a>
<P><LI>maximale Anzahl von Zeichen f&uuml;r eine Zeichenkette
<P><LI>Anzahl der Nachkommastellen f&uuml;r Flie&szlig;kommazahlen (z.B. 
<TT>%.0lf</TT>
<P><LI>die minimale Anzahl von Ziffern f&uuml;r Ganzzahlenwerte
</OL>
<P><LI>die Gr&ouml;&szlig;e des Argumentes
<UL>
<P><LI>h - Pr&auml;fix f&uuml;r die Integertypen (d, i, n, o, u, x und X),
der festlegt, da&szlig; das Argument <TT>short int</TT> oder
<TT>unsigned short int</TT> ist.
<P><LI>l - Pr&auml;fix f&uuml;r die Typen d, i, n, o, u, x und X, der festlegt,
da&szlig; das Argument <TT>long int</TT> oder
<TT>unsigned long int</TT> ist. Dieser Pr&auml;fix kann ebenfalls
bei den Typen e, f und g benutzt werden (<TT>double</TT> Typen).
<P><LI>L - Pr&auml;fix f&uuml;r die Typen e, f und g, der festlegt, da&szlig; das
Argument <TT>long double</TT> ist.
</UL>
<P><LI>Der <I>type</I> kann aus folgenden Zeichen bestehen:
<DL>
<P><DT>c
<DD>f&uuml;r char
<P><DT>d
<DD>f&uuml;r signed int (dezimal)
<P><DT>e
<DD>f&uuml;r float-Variablen, allerdings wird der Wert in
Exponentenschreibweise ausgegeben.
<P><DT>E
<DD>wie e, aber E f&uuml;r den Exponent statt e
<P><DT>f
<DD>f&uuml;r float-Variablen, Ausgabe in Festkommaschreibweise
<P><DT>g
<DD>f&uuml;r float-Variablen. Der Compiler entscheidet abh&auml;ngig
von der L&auml;nge, ob Exponential- oder Festkommadarstellung gew&auml;hlt wird.
<P><DT>G
<DD>wie g, aber E f&uuml;r den Exponent statt e
<P><DT>i
<DD>f&uuml;r signed int (dezimal)
<P><DT>n
<DD>Nummer der Zeichen, die bis jetzt erfolgreich auf die Ausgabe
geschrieben wurde.
<P><DT>o
<DD>f&uuml;r signed int (oktal)
<P><DT>p
<DD>f&uuml;r Zeigervariablen
<P><DT>s
<DD>f&uuml;r Zeichenketten (char-Felder)
<P><DT>u
<DD>f&uuml;r unsigned int (dezimal)
<P><DT>x
<DD>f&uuml;r unsigned int (hexadezimal, a-f)
<P><DT>X
<DD>f&uuml;r unsigned int (hexadezimal, A-F)
</DL>
</OL>
<P>Die grunds&auml;tzliche Verwendungsweise soll mit Hilfe einiger Beispiele
an einer Zeichenkette verdeutlicht werden, die Feldbreite der
Zeichenkette betr&auml;gt 21 Zeichen:
<TT>EIN-, AUSGABEFUNKTION</TT>
<P>Die Beispiele sind folgenderma&szlig;en aufgebaut: Nummer des Beispiels,
Formatstring, Ausgabe. Eine Beschreibung folgt in der jeweils n&auml;chsten
Zeile. Leerzeichen, die ausgegeben werden, werden durch den
Unterstrich (<TT>_</TT>) gekennzeichnet.
<P>
<PRE>
(1)  %s            EIN-, AUSGABEFUNKTION
</PRE>
<P>Ist kein Feldformat verlangt, hat das Feld die Breite der
Zeichenkettenkonstante.
<P>
<PRE>
(2)  %21s          EIN-, AUSGABEFUNKTION
</PRE>
<P>
<P>Die Feldbreite entspricht der L&auml;nge der Zeichenkonstante.
<P>
<P>
<PRE>
(3)  %-21s         EIN-, AUSGABEFUNKTION
</PRE>
<P>
<P>Eine Linksausrichtung ist nicht m&ouml;glich, da die Feldbreite der
L&auml;nge der Zeichenkettenkonstanten entspricht.
<P>
<P>
<PRE>
(4)  %15s          EIN-, AUSGABEFUNKTION
</PRE>
<P>
<P>Die Feldbreite von 15 gibt nur den minimalen Wert der Feldbreite
an.
<P>
<P>
<PRE>
(5)  %-15s         EIN-, AUSGABEFUNKTION
</PRE>
<P>Eine Linksausrichtung ist nicht m&ouml;glich.
<P>
<PRE>
(6)  %25s          ____EIN-, AUSGABEFUNKTION
</PRE>
<P>Da die Feldbreite gr&ouml;&szlig;er als die L&auml;nge der
Zeichenkettenkonstanten ist, wird diese rechtsb&uuml;ndig eingef&uuml;gt.
<P>
<PRE>
(7)  %-25s         EIN-, AUSGABEFUNKTION____
</PRE>
<P>Linksausrichtung der Zeichenkettenkonstanten.
<P>
<PRE>
(8)  %25.10s       _______________EIN-, AUSG
</PRE>
<P>In ein Feld mit 25 Elementen werden die ersten 10 Zeichen der
Zeichenkettenkonstanten rechtsb&uuml;ndig ausgegeben.
<P>
<PRE>
(9)  %-25.10s      EIN-, AUSG_______________
</PRE>
<P>10 Zeichen der Zeichenkettenkonstanten werden linksb&uuml;ndig
ausgegeben.
<P>
<PRE>
(10)  %-025.10s     EIN-, AUSG000000000000000
</PRE>
<P>Wie oben, allerdings werden Leerstellen mit Nullen aufgef&uuml;llt.
<P>
<PRE>
(11)  %.10s         EIN-, AUSG
</PRE>
<P>Die Feldbreite entspricht der geforderten Zeichenanzahl.
<P>
<P><H3><A NAME="HDRFLUCHT" HREF="#ToC_76">4.1.2 Fluchtsymbolzeichen</A></H3>
<A NAME="IDX185"></A>
<P>In den obigen Beispielen ist mehrfach die Zeichenfolge
<TT>\n</TT> aufgetreten. Sie
ist eines von mehreren Fluchtsymbolzeichen,
auch <I>Escape-Sequenz</I> genannt, die der
Formatierung der Ausgabe dienen und aus einem Backslash
(<TT>\</TT>) und einem nachfolgenden Buchstaben bestehen.
M&ouml;gliche Zeichenfolgen sind:
<DL>
<P><DT>- \\
<DD>gibt den Backslash aus
<P><DT>- \'
<DD>gibt das einfache Hochkomma (') aus
<P><DT>- \"
<DD>gibt die Anf&uuml;hrungszeichen bzw. das doppelte Hochkomma (") aus
<A NAME="IDX186"></A>
<P><DT>- \0
<DD>Die bin&auml;re Null schlie&szlig;t eine Zeichenkette ab, wird von Funktionen
zur Zeichenkettenbearbeitung automatisch generiert.
<P><DT>- \a
<DD><I>alarm</I>; gibt einen Warnton aus.
<P><DT>- \b
<DD><I>backspace</I>; bewegt den Cursor um eine Stelle nach links.
<P><DT>- \f
<DD><I>formfeed</I>; veranla&szlig;t einen Seitenvorschub, d.h. da&szlig; der
nachfolgende Text auf einer neuen Seite ausgegeben wird.
<A NAME="IDX187"></A>
<P><DT>- \n
<DD>markiert einen Zeilenvorschub (<I>new line</I>). Die
nachfolgende Ein- oder Ausgabe wird in einer neuen Zeile begonnen.
<A NAME="IDX188"></A>
<P><DT>- \r
<DD><I>carriage return</I>/Wagenr&uuml;cklauf; bewegt den Cursor in
derselben Zeile an den Zeilenanfang.
<P><DT>- \t
<DD>setzt ein Tabulatorzeichen. Der folgende Text wird um einen
definierten Wert, der in der Entwicklungsumgebung eingestellt
wird, nach rechts verschoben.
</DL>
<DL>
<P><DT><B>Anmerkung:
</B><DD>Um die Zeichen  <TT>\</TT> und <TT>%</TT>
darzustellen, werden sie doppelt eingegeben.
<P><DT><B>Bsp:
</B><DD><TT>printf("Wechsel in das directory \"C:\\OS2\\APPS\"
verl&auml;uft ...");</TT> ergibt folgende Ausgabe: <TT>Wechsel
in das directory "C:\OS2\APPS"</TT> verl&auml;uft...
</DL>
<P>
<HR><H2><A NAME="Header_77" HREF="#ToC_77">4.2 scanf - formatiertes Lesen vom Standardeingabeger&auml;t</A></H2>
<A NAME="IDX189"></A>
<P>
<STRONG>
scanf(const char <VAR>*format-string</VAR>, <VAR>argument-list</VAR>);
</STRONG>
<P>Die Bedeutung der einzelnen Komponenten
entspricht der von <TT>printf()</TT> (siehe oben).
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">scanf() - Formatspezifikation</TH><TR><TD>
<PRE>
                                             
>>--%--+-----+--+----------+--+---+--type--><
       |     |  |          |  |-h-|          
       +--*--+  +--Breite--+  |   |          
                              |-l-|          
                              |   |          
                              +-L-+          
</PRE>
</TD></TR></TABLE>
<P>Der Aufbau soll anhand des folgenden Beispiels erl&auml;utert werden:
<PRE>
   Bsp.&#58; scanf("%d", &ergebnis);
</PRE>
<P><TT>%d</TT> bezeichnet wie bei der <TT>printf()</TT>-Funktion
eine Formatspezifikation. Theoretisch gelten alle bei <TT>printf()</TT>
angesprochenen Formatierungsm&ouml;glichkeiten auch f&uuml;r <TT>scanf()</TT>.
Dem Benutzer sollte jedoch vor der Eingabe mitgeteilt werden, wieviele
Zeichen und in welchem Format er die Zeichen eingeben soll.
<P>Die einzigen Unterschiede liegen bei der Breite des Eingabefeldes,
des optionalen Sterns (*) und
den Typen <TT>X, E</TT> und <TT>G</TT>. Die Angabe der Breite bei
<TT>printf()</TT> gibt die Mindestbreite des Ausgabefeldes
an. Bei <TT>scanf()</TT> wird hier die maximale Breite des
Eingabefeldes festgelegt.
Der optionale Stern nach dem Prozentzeichen unterdr&uuml;ckt die
Zuweisung des n&auml;chsten Eingabefeldes. Das Feld wird analysiert,
aber nicht gespeichert.
Die Typen <TT>X, E</TT> und <TT>G</TT>
stehen bei <TT>scanf()</TT> nicht zur Verf&uuml;gung.
<P><TT>&ergebnis</TT> ist zusammengesetzt aus
<TT>&</TT> und der Variablen <TT>ergebnis</TT>,
die den zu lesenden Wert aufnimmt. Das <TT>&</TT>-Zeichen
markiert in C den Zugriff auf eine Adresse
(siehe auch <A HREF="#HDRZEI">3.2.4, "Zeiger - Pointer"</A>). Die Argumente bei
<TT>scanf()</TT> m&uuml;ssen Zeiger sein, da sonst die Werte der Variablen
und nicht deren
Adressen an <TT>scanf()</TT> &uuml;bergeben werden. Bezeichnern
von Felder (siehe Abschnitt <A HREF="#HDRFELD">3.2.1, "Felder - Array - Vektoren"</A>) wird kein
<TT>&</TT> vorangestellt, da sie stets einen Zeiger auf den
eigentlichen Inhalt darstellen.
<P>Beispiele
<PRE>
1)     int x;
 
       scanf("%5d", &x);
       Eingabe: 1234567
</PRE>
<P><TT>x</TT> bekommt nur die ersten f&uuml;nf Ziffern (12345)
der Eingabe zugewiesen, da die Feldbreite nicht &uuml;berschritten werden
darf. Die Ziffern 67 befinden sich jedoch noch im Eingabepuffer der
Standardeingabe (stdin). Folgt der oben angegebenen Anweisung eine
weitere, so wartet diese nicht eine erneute Eingabe ab, sondern
nimmt lediglich das, was bereits im Eingabepuffer steht!
<P>
<PRE>
2)     float zahl1=0.0, zahl2=0.0;
 
       scanf("%5f+%5f", &zahl1, &zahl2);
       1. Eingabe: 12345+6789
       2. Eingabe: 123456+123456
</PRE>
<P>Die erste Eingabe weist den Variablen die entsprechenden Werte zu.
Zu beachten ist, da&szlig; hierbei eine komplette Addition eingegeben wird
und nicht mehrere Werte nacheinander. Diese Form erscheint zun&auml;chst
sehr komfortabel, birgt aber einige Gefahren in sich. Bei der zweiten
Eingabe werden lediglich die ersten f&uuml;nf Ziffern (12345) zugewiesen,
da die Feldbreite nur f&uuml;nf Zeichen betr&auml;gt. Die Zahl 6, das
Additionszeichen und die Zahlen 123456 befinden sich
noch im Eingabepuffer. Der Variablen <TT>zahl2</TT> wird jedoch
kein Wert zugewiesen, sie beh&auml;lt den Initialisierungswert Null.
<P>
<PRE>
3)     char ch;
 
       scanf("%c", &ch);
       Eingabe: IBM
</PRE>
<P><TT>ch</TT> bekommt nur <TT>I</TT> &uuml;bergeben, da eine Variable
des Typs <TT>char</TT> nur ein Zeichen aufnehmen kann.
<P>
<HR><H2><A NAME="Header_78" HREF="#ToC_78">4.3 Eingabe- und Ausgabepuffer leeren</A></H2>
<A NAME="IDX190"></A>
<A NAME="IDX191"></A>
<P>Syntax: <TT>fflush(FILE *);</TT>
<P>Die Funktion <TT>fflush()</TT> dient zum Leeren der
Eingabe- bzw. Ausgabepuffer. Beim Leeren des Ausgabepuffers werden
die noch enthaltenen Daten auf den Bildschirm geschrieben.
<P>Eingabepuffer leeren:
<PRE>
fflush(stdin);
</PRE>
<P>Ausgabepuffer leeren:
<PRE>
fflush(stdout);
</PRE>
<P>Puffer einer Datei leeren:
<PRE>
fflush(FILE *);       /* Dateizeiger angeben, z.B. fflush(quelle); */
</PRE>
<P>Das Leeren des Ausgabepuffers empfiehlt sich vor jeder
<TT>scanf()</TT> (oder vergleichbaren)
Anweisung und das Leeren des Eingabepuffers
empfiehlt sich nach jeder <TT>scanf()</TT>
(oder vergleichbaren) Anweisung.
<HR><H2><A NAME="Header_79" HREF="#ToC_79">4.4 Funktionen zur Bearbeitung von Zeichenketten</A></H2>
<P>In diesem Abschnitt wird detailliert auf
die Bearbeitung von Zeichenkettenkonstanten eingegangen.
Am Ende dieses Abschnittes befindet sich eine
&Uuml;bersicht &uuml;ber die gebr&auml;uchlichsten Funktionen zur
Zeichenkettenmanipulation.
<P>In einem Zeichenfeld soll die Zeichenkette
<TT>Hallo</TT> gespeichert werden. Im Speicher
ergibt sich dann folgendes Bild:
<BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">Element
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">3
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">4
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">5
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">Inhalt
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">H
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">a
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">l
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">l
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">o
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">\0
</TD></TR></TABLE>
<P>Die bin&auml;re Null wird von der jeweiligen Zeichenkettenfunktion
selbstt&auml;tig an das Ende der Zeichenkette gesetzt. Wird eine
Zeichenkette manuell erzeugt, sollte die bin&auml;re Null aus
Sicherheitsgr&uuml;nden manuell angef&uuml;gt werden.
<P>
<PRE>
/********************************************************************/
/* Programm: zeichen.c                                              */
/* Autor   : Sascha Kliche, Daniel Wolkenhauer                      */
/* Datum   : September 1994                                         */
/* Beschreibung:                                                    */
/* Dieses Programm verdeutlich die automatische Benutzung der       */
/* bin&auml;ren Null und f&uuml;hrt in einzelne Zeichenkettenfunktionen       */
/* ein.                                                             */
/********************************************************************/
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;                                              (1)
 
void main(void)
{
   /* Vereinbarungsteil der lokalen Variablen */
   char satz[80];                                                (2)
 
   /* Lesen der Zeichenkette */
   printf("Bitte einen Satz eingeben!\n");
   gets(satz);                                                   (3)
 
   /* Ausgabe der Zeichenkette */
   printf("%s\n", satz);
 
   /* Ermitteln der L&auml;nge der Zeichenkette und L&auml;nge ausgeben */
   printf("Der Satz beinhaltet %i Zeichen!\n", strlen(satz));    (4)
   printf("satz[4] wird jetzt mit der bin&auml;ren Null gef&uuml;llt.");
 
   /* Das f&uuml;nfte Element mit der bin&auml;ren Null f&uuml;llen. */
   satz[4]='\0';                                                 (5)
   printf("%s", satz);
 
   /* Neue L&auml;nge der Zeichenkette ermitteln und ausgeben. */
   printf("Der Satz besteht nun nur noch aus %i Zeichen!", strlen(satz));
}
</PRE>
<P>(1) F&uuml;r einige der Zeichenketten-Funktionen wird eine eigene
Standardbibliotheksdatei ben&ouml;tigt. Die entsprechende
Definitionsdatei hat den Namen <TT>string.h</TT>.
<P>(2) Die Anweisung <I>char satz[80]&#59;</I> reserviert
Speicherplatz f&uuml;r 80 Zeichen. Bei der Arbeit mit Funktionen zur
Zeichenkettenverarbeitung sollte jedoch bedacht werden, da&szlig; diese
automatisch
die bin&auml;re Null an das Ende der Zeichenkette anh&auml;ngen. Soll eine
Zeichenkette mit 80 Zeichen mit Funktionen zur
Zeichenkettenverarbeitung
bearbeitet werden, mu&szlig; die Deklaration <TT>char satz[81];</TT>
lauten.
<P>(3) Die Funktion <TT>gets()</TT> liest Zeichenketten
von der Standardeingabe (Tastatur) in das innerhalb der Klammern
angegebene
char-Feld. Zus&auml;tzlich setzt es bei Eingabe von <B>ENTER</B>
automatisch die bin&auml;re Null an das Ende der Zeichenkette.
<P>(4) Mit Hilfe der Funktion <TT>strlen()</TT> ist es m&ouml;glich, die
L&auml;nge einer Zeichenkette zu ermitteln. Dabei werden alle Zeichen
einschlie&szlig;lich der Leerzeichen exklusive der bin&auml;ren Null gez&auml;hlt.
<P>(5) Durch das F&uuml;llen des f&uuml;nften Elementes mit der bin&auml;ren Null
wird das Ende der Zeichenkette verlegt. S&auml;mtliche Zeichen hinter dem
f&uuml;nften Element werden nicht mehr ausgegeben.
<P>
<P><H3><A NAME="Header_80" HREF="#ToC_80">4.4.1 Die Funktionen strcpy() und strcat()</A></H3>
<P>Die Funktionen <TT>strcpy()</TT> und <TT>strcat()</TT> dienen
zum Kopieren von Zeichenketten in andere Zeichenketten.
<TT>strcpy()</TT> kopiert Zeichenketten immer an den Anfang von
Zeichenketten und <TT>strcat()</TT> h&auml;ngt Zeichenketten
an das Ende anderer Zeichenketten an.
<P>Die Syntax von <TT>strcpy()</TT> lautet:
<P>
<STRONG>
char *strcpy(char <VAR>*zeichenkette1</VAR>, const char
<VAR>*zeichenkette2</VAR>);
</STRONG>
<P>
<A NAME="IDX192"></A>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">strcpy()</TH><TR><TD>
<PRE>
                                                     
>>--strcpy--(--zeichenkette1, zeichenkette2--)--&#59;--><
</PRE>
</TD></TR></TABLE>
<P><TT>zeichenkette2</TT> wird in
<TT>zeichenkette1</TT> kopiert.
Nach der Anweisung <TT>strcpy(satz, "Sahne");</TT>
hat der reservierte Platz im Speicher folgendes Aussehen
(vorausgesetzt,
die Vereinbarung hatte die Form: <TT>char satz[9]</TT>):
<BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="18%">Element
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">3
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">4
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">5
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">6
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">7
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">8
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="18%">Inhalt
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">S
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">a
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">h
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">n
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">e
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">\0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD></TR></TABLE>
<P>Die Funktion <TT>strcpy()</TT> h&auml;ngt die bin&auml;re Null automatisch
an das Ende der Zeichenkette an.
<P>Um an <TT>zeichenkette1</TT> die Zeichenkette <TT>eis</TT>
anzuh&auml;ngen, wird die Funktion <TT>strcat</TT> benutzt, die folgende
Syntax hat:
<P>
<STRONG>
char *strcat(char <VAR>*zeichenkette1</VAR>, const char
<VAR>*zeichenkette2</VAR>);
</STRONG>
<P>
<A NAME="IDX193"></A>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">strcat()</TH><TR><TD>
<PRE>
                                                     
>>--strcat--(--zeichenkette1, zeichenkette2--)--&#59;--><
</PRE>
</TD></TR></TABLE>
<P>Das Ergebnis von
<P>
<PRE>
   strcat(satz, "eis");
</PRE>
<P>hat folgende Auswirkung:
<BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="18%">Element
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">3
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">4
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">5
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">6
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">7
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">8
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="18%">Inhalt
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">S
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">a
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">h
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">n
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">e
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">e
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">i
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">s
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">\0
</TD></TR></TABLE>
<P>Mit dem ersten Zeichen des anzuh&auml;ngenden Textes wird die bin&auml;re Null
&uuml;berschrieben und an das neue Ende gesetzt. Die gleiche Anweisung
mit <TT>strcpy()</TT> h&auml;tte die ersten vier
Speicherstellen durch
<TT>eis\0</TT> ersetzt. Die Speicherstellen f&uuml;nf bis
neun behalten ihren Wert, werden jedoch von vielen Funktionen nicht
mehr beachtet, da eine bin&auml;re Null davor steht.
<P>Wird dem Feld ein Wert zugewiesen, der l&auml;nger als der reservierte
Speicherplatz ist, so werden
diese &uuml;berz&auml;hligen Zeichen nicht abgeschnitten, sondern in den
angrenzenden Speicherbereich geschrieben, so da&szlig; dort andere
Variablenwerte verloren gehen k&ouml;nnen.
Der C-Compiler pr&uuml;ft nicht auf ausreichende L&auml;nge der Variable!
Der Programmierer mu&szlig; daf&uuml;r sorgen, da&szlig; der reservierte
Speicherbereich gro&szlig; genug f&uuml;r die Aufnahme der Zeichenkette ist,
anderenfalls kann es zu unvorhergesehenen Fehlern bis hin zu
Programmabst&uuml;rzen kommen.
<P><H3><A NAME="Header_81" HREF="#ToC_81">4.4.2 Auswahl h&auml;ufig benutzter Funktionen zur Zeichenkettenbearbeitung</A></H3>
<P>Die Programmiersprache C bietet in ihren Standardbibliotheken
verschiedene Funktionen zur Manipulation von Zeichen(ketten) an
(Auswahl):
<DL>
<P><DT><B> C-Funktion</B>
<DD><B> Erkl&auml;rung</B>
<A NAME="IDX194"></A>
<P><DT><TT>tolower (zeichen)</TT>
<DD>Wandelt <TT>zeichen</TT> in einen Kleinbuchstaben
um, wenn es ein Gro&szlig;buchstabe ist. Ansonsten wird der
Kleinbuchstabe unver&auml;ndert zur&uuml;ckgeliefert. (Definitionsdatei:
<TT>ctype.h</TT>)
<PRE>
char klein = 0;
klein = tolower ('A');
</PRE>
<A NAME="IDX195"></A>
<P><DT><TT>toupper (zeichen)</TT>
<DD>Wandelt <TT>zeichen</TT> in einen Gro&szlig;buchstaben um, wenn es
sich um einen Kleinbuchstaben handelt. Ansonsten wird der Gro&szlig;buchstabe
unver&auml;ndert zur&uuml;ckgeliefert. (Definitionsdatei: <TT>ctype.h</TT>)
<PRE>
char gross = 0;
gross = toupper ('a');
</PRE>
<A NAME="IDX196"></A>
<P><DT><TT>strcat (kette1, kette2)</TT>
<DD>Kopiert die Zeichenkette <TT>kette2</TT> an das Ende der
Zeichenkette <TT>kette1</TT>, &uuml;berschreibt dabei die bin&auml;re Null und
setzt sie an das neue Ende. <TT>strcat</TT> geht davon aus, da&szlig; in
<TT>kette1</TT> gen&uuml;gend Platz vorhanden ist. Die Funktion liefert
einen Zeiger auf den Anfang der Gesamtkette als Ergebnis zur&uuml;ck.
(Definitionsdatei: <TT>string.h</TT>)
<A NAME="IDX197"></A>
<P><DT><TT>strncat (kette1, kette2, n)</TT>
<DD>Kopiert n Zeichen von <TT>kette2</TT> an
das Ende von <TT>kette1</TT>.
(Definitionsdatei: <TT>string.h</TT>)
<A NAME="IDX198"></A>
<P><DT><TT>strcmp (kette1, kette2)</TT>
<DD>Vergleicht <TT>kette1</TT> und <TT>kette2</TT>
byteweise. Es wird ein positiver Wert zur&uuml;ckgeliefert, wenn
<TT>kette1</TT> gr&ouml;&szlig;er ist als <TT>kette2</TT>,
ein negativer, wenn sie kleiner ist und Null, wenn sie identisch
sind. Siehe auch stricmp und strnicmp.
(Definitionsdatei: <TT>string.h</TT>)
<A NAME="IDX199"></A>
<P><DT><TT>strncmp(kette1, kette2, n)</TT>
<DD>Vergleicht nur n Zeichen in <TT>kette1</TT>
und <TT>kette2</TT>. Die Bedeutung der R&uuml;ckgabewerte ist identisch
mit denen von <TT>strcmp</TT>.
(Definitionsdatei: <TT>string.h</TT>)
<A NAME="IDX200"></A>
<P><DT><TT>strlen (kette)</TT>
<DD>Liefert als R&uuml;ckgabewert die L&auml;nge der Zeichenkette <TT>kette</TT>
zur&uuml;ck, ohne die bin&auml;re Null mitzuz&auml;hlen.
(Definitionsdatei: <TT>string.h</TT>)
<PRE>
length = strlen(string);
</PRE>
<A NAME="IDX201"></A>
<P><DT><TT>strcpy (kette1, kette2)</TT>
<DD>Kopiert <TT>kette2</TT> in <TT>kette1</TT>.
(Definitionsdatei: <TT>string.h</TT>)
</DL>
<P>
<HR><H1><A NAME="HDROWN" HREF="#ToC_82">5.0 Eigene Funktionen</A></H1>
<A NAME="IDX202"></A>
<P>Es wurde bereits erw&auml;hnt, da&szlig; Funktionen eigenst&auml;ndig eine definierte
Aufgabe ausf&uuml;hren und dann die Kontrolle wieder an die
aufrufende Funktion zur&uuml;ckgeben. Sie sind somit sehr n&uuml;tzlich,
wenn es darum geht, eine Aufgabe mehrmals innerhalb eines oder
verschiedener Programme zu erledigen.
<P>Die Programmierung einer eigenen Funktion wird anhand einer Funktion
zur Berechnung der Fakult&auml;t dargestellt.
Der verwendete C-Compiler bietet unter Umst&auml;nden
keine Funktion zur Berechnung der Fakult&auml;t.
Diese Berechnung wird jedoch h&auml;ufig ben&ouml;tigt. Die einfachste
M&ouml;glichkeit besteht nun darin, eine eigene Funktion zu
formulieren und die L&ouml;sung des Problems somit auszulagern.
<P>
<HR><H2><A NAME="Header_83" HREF="#ToC_83">5.1 Definition eigener Funktionen</A></H2>
<P>Bei der Definition von eigenen Funktionen ist auf den
G&uuml;ltigkeitsbereich der Variablen zu achten. Siehe dazu auch
Speicherklassen im Abschnitt <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>.
<P>Eine Funktion besteht aus dem <I>Funktionskopf</I> und dem
<I>Funktionsrumpf</I>. Der Funktionskopf beinhaltet Informationen
&uuml;ber den Namen der Funktion, den Typ des R&uuml;ckgabewertes und die
Parameter, die an die Funktion &uuml;bergeben werden sollen. Der
Funktionsrumpf beinhaltet die Deklaration lokaler Variablen (optional),
die Anweisungen, die die Funktion ausf&uuml;hren soll, und die Anweisung zur
Beendigung der Funktion, die die R&uuml;ckgabevariable enth&auml;lt (optional).
<P>Ein Beispiel:
<P>
<PRE>
   int fakultaet (int n)         /* Funktionskopf                 */
   {                             /* Beginn Funktionsrumpf         */
      int i=0, produkt=1;        /* Deklaration der lokalen Var.  */
 
      for (i=1; i &lt;= n; ++i)
      produkt *= i;              /* entspricht: produkt=produkt*i */
      return(produkt);           /* Funktion beenden und den      */
                                 /* R&uuml;ckgabewert zur&uuml;ckgeben      */
   }                             /* Ende Funktionsrumpf           */
</PRE>
<P><TT>int fakultaet</TT> vereinbart den Typ des Resultats, das von
der Funktion an die aufrufende Funktion zur&uuml;ckgegeben wird, und den
Namen der Funktion. Wird kein Resultat zur&uuml;ckgegeben, mu&szlig; vor dem
Funktionsnamen <TT>void</TT> stehen.
<P><TT>(int n)</TT> stellt die Parameterliste dar.
Die Parameterliste beschreibt diejenigen Variablen, die von der
aufrufenden Funktion an die Funktion <TT>fakultaet</TT> &uuml;bergeben
werden sollen. Der Funktion <TT>fakultaet</TT> wird
ein Argument vom Typ <TT>int</TT> beim Aufruf mitgegeben.
Mehrere Parameter werden durch Kommata getrennt.
<P>W&uuml;rde es sich um eine Funktion handeln, die keine Variablen &uuml;bergeben
bekommt, m&uuml;&szlig;te in den Klammern <TT>void</TT> stehen. Dies w&uuml;rde
bedeuten, da&szlig; die Paramaterliste leer ist.
<A NAME="IDX203"></A>
<P>Mit <TT>return(produkt);</TT> wird die Funktion beendet und das
Resultat  <TT>produkt</TT>  an die aufrufende Funktion zur&uuml;ckgegeben.
<P>Ein m&ouml;glicher Aufruf w&auml;re:
<P>
<PRE>
fak = fakultaet(7);
</PRE>
<P>Das Resultat des Funktionsaufrufes <TT>fakultaet(7)</TT> wird
durch das Schl&uuml;sselwort <TT>return</TT> an die aufrufende Funktion
zur&uuml;ckgegeben und dabei der Variablen <TT>fak</TT> zugewiesen.
<P>Folgt dem Schl&uuml;sselwort <TT>return</TT> kein geklammerter Ausdruck,
so wird die Funktion beendet und kein Wert zur&uuml;ckgegeben.
<P>Ein weiteres Beispiel soll die Verwendung des Schl&uuml;sselwortes
<TT>void</TT> verdeutlichen:
<P>
<PRE>
   void copyright (void)
 
   {
      printf("%s\n,%s\n,%s\n,%s\n,%s\n",
      " /***************************************/",
      " /* Copyright by    DaKliSaWo           */",
      " /* BAB Hannover    IBM intern          */",
      " /* (c) 1994                            */",
      " /***************************************/");
   }
</PRE>
<P>Das erste <TT>void</TT> legt fest, da&szlig; die Funktion
<TT>copyright</TT> kein Resultat an die aufrufende Funktion zur&uuml;ckgibt.
Da&szlig; die Funktion keine Argumente erwartet, wird durch das zweite
<TT>void</TT> in der Parameterliste festgelegt. Der Aufruf lautet:
<P>
<PRE>
   copyright();
</PRE>
<P>
<HR><H2><A NAME="Header_84" HREF="#ToC_84">5.2 Call by value und call by reference</A></H2>
<A NAME="IDX205"></A>
<A NAME="IDX206"></A>
<P>Bei Funktionen unterscheidet man "call by value" Funktionen
und "call by reference" Funktionen. Die oben vorgestellte
Funktion <TT>fakultaet</TT> ist eine "call by value"
Funktion, da an sie der Wert einer Variablen &uuml;bergeben wird.
Eine "call by reference" Funktion erwartet nicht den Wert
einer Variablen, sondern deren Adresse in Form eines Zeigers.
In diesem Fall wird der Wert der Variablen nicht ein zweites
Mal im Speicher abgelegt und mit dieser Kopie gearbeitet, sondern
es wird direkt mit dem Original gearbeitet.
<P>Beispiel f&uuml;r "call by value":
<PRE>
int add(int, int);
 
void main(void)
{
   int a=3, b=7, ergebnis;
 
   ergebnis = add(a,b);
   printf("Ergebnis von %d + %d = %d\n",a,b,ergebnis);
}
 
int add(int x, int y)
{
   int ergebnis;
 
   ergebnis = x + y;
   return(ergebnis);
}
</PRE>
<P>Beispiel f&uuml;r "call by reference" mit R&uuml;ckgabewert per
<TT>return</TT>:
<PRE>
int add(int *, int *);
 
void main(void)
{
   int a=3, b=7, ergebnis;
 
   ergebnis = add(&a, &b);
   printf("Ergebnis von %d + %d = %d\n",a,b,ergebnis);
}
 
int add(int *x, int *y)
{
   int ergebnis;
 
   ergebnis = *x + *y;
   return(ergebnis);
}
</PRE>
<P>Beispiel f&uuml;r "call by reference" mit R&uuml;ckgabewert per
Zeiger:
<PRE>
void add(int *, int *, int *);
 
void main(void)
{
   int a=3, b=7, ergebnis;
 
   add(&a, &b, &ergebnis);
   printf("Ergebnis von %d + %d = %d\n",a,b,ergebnis);
}
 
void add(int *x, int *y, int *ergebnis)
{
   *ergebnis = *x + *y;
}
</PRE>
<HR><H2><A NAME="Header_85" HREF="#ToC_85">5.3 Prototypen</A></H2>
<A NAME="IDX208"></A>
<P>Bei der Definition von Funktionen ist darauf zu achten,
wo man sie im Quelltext
definiert. Funktionen, die man vor dem Ort ihres Aufrufes definiert,
bereiten keine Probleme. Der Compiler, der den Quelltext von oben
nach unten durchgeht, hat zum Zeitpunkt des Aufrufes die
Funktionsdefinition bereits analysiert und wei&szlig;, welchen Typ der
R&uuml;ckgabewert der Funktion hat und wieviele Parameter welchen Typs
in welcher Reihenfolge von dieser Funktion erwartet werden.
<P>Wird die Funktion erst nach ihrem ersten Aufruf definiert, so
nimmt der Compiler an, da&szlig; ihr R&uuml;ckgabewert vom Typ <TT>int</TT>
ist. Ist in der Definition ein anderer Typ angegeben, so l&auml;uft das
Programm sp&auml;testens beim Linker auf einen Fehler (z.B. auf einen
<I>redefinition error</I>). Wie dieses Problem, da&szlig; auch auftritt,
wenn Funktionen sich gegenseitig aufrufen, umgangen werden kann, wird
im folgenden erl&auml;utert.
<P>Um Funktionen nach dem Ort ihres ersten Aufrufes definieren zu
k&ouml;nnen, bietet C die M&ouml;glichkeit der Prototypen. Prototypen stellen
eine Vorgehensweise dar, wie dem Compiler zu Beginn des Quelltextes
mitgeteilt werden kann, welche Funktionen in einem Programm vorkommen,
welchen Typs ihre R&uuml;ckgabewerte sind, welche Parameter sie erwarten
und welchen Namen diese Funktionen haben. Dies erm&ouml;glicht dem
Compiler, die korrekte Verwendung der Funktionen in einem Programm
zu &uuml;berpr&uuml;fen. Die Prototypen sollten direkt nach den
Preprocessoranweisungen folgen.
<P>Folgendes Beispiel demonstriert den Einsatz von Prototypen:
<P>
<PRE>
/*****************************************************************
 *  proto.c                                                      *
 *  demonstriert den einsatz von prototypen                      *
 *****************************************************************/
 
#include &lt;stdio.h&gt;
 
double berechnung(double, double);              /*   Prototyp    */
 
void main(void)
{
     double a1=0.0, a2=0.0;
 
     a1=3.14;
     a2=218;
 
     printf("\nErgebnis = %lf", berechnung(a1,a2));
}
 
double berechnung(double a1, double a2)
{
   return(a1 * a2);
}
</PRE>
<P>In dem obigen Beispiel wird ein Prototyp f&uuml;r die Funktion
<TT>berechnung</TT> eingef&uuml;hrt. Der Prototyp enth&auml;lt folgende
Elemente:
<OL TYPE=1>
<P><LI>den Typ des R&uuml;ckgabewertes,
<P><LI>den Namen der Funktion,
<P><LI>die Typen der Parameter, die die Funktion erwartet, in Klammern und
<P><LI>ein abschlie&szlig;endes Semikolon.
</OL>
<P>Die generelle Verwendung von Prototypen f&uuml;r s&auml;mtliche Funktionen
in jedem Programm empfiehlt sich aus mehreren Gr&uuml;nden:
<UL>
<P><LI>Die Prototypen nehmen wenig Platz ein. In Verbindung mit einem
Kommentar erm&ouml;glicht eine Reihe von Prototypen eine n&uuml;tzliche
&Uuml;bersicht &uuml;ber die einzelnen Funktionen, ihren Sinn, den Typ ihres
R&uuml;ckgabewertes und ihre Parameter in einem Programm. Der Reihe der
kommentierten Prototypen kann die Funktion <TT>main()</TT> folgen,
was das Programm sehr &uuml;bersichtlich und leicht lesbar macht. Die
eigentliche Funktionsdefinition kann im Anschlu&szlig; erfolgen.
<P><LI>Funktionen k&ouml;nnen nach ihrem ersten Aufruf definiert werden und
sind dabei nicht auf den Typ <TT>int</TT> f&uuml;r den R&uuml;ckgabewert
beschr&auml;nkt.
<P><LI>Funktionen k&ouml;nnen sich gegenseitig aufrufen.
</UL>
<P>Die oben genannten Vorteile stellen die wichtigsten Gr&uuml;nde f&uuml;r
die Verwendung von Prototypen dar. Die Verwendung ist jedoch nicht
zwingend, s&auml;mtliche Funktionen k&ouml;nnen ohne Prototypen definiert
werden.
<HR><H2><A NAME="Header_86" HREF="#ToC_86">5.4 Variable Anzahl an Parametern beim Funktionsaufruf</A></H2>
<A NAME="IDX210"></A>
<P>Die bisher vorgestellten M&ouml;glichkeiten sind auf Funktionen mit
einer fest definierten Anzahl an Parametern begrenzt. Funktionen
wie <TT>printf</TT> bieten jedoch die M&ouml;glichkeit, sie mit einer
variablen Anzahl an Parametern aufzurufen:
<PRE>
printf("\nAufruf mit einem Parameter.\n");
printf("\nAufruf mit %d Parametern.\n",2);
printf("\n%d. Aufruf mit %s Parametern.\n",anzahl,typ);
</PRE>
<P>Das folgende Beispiel demonstriert die grunds&auml;tzliche
Vorgehensweise anhand der Funktion <TT>name</TT>, die
als Parameter einen Integerwert und eine unbestimmte Anzahl
an Zeichenketten entgegennimmt.
<PRE>
/*
   Bearbeitung einer unbestimmten Anzahl Parameter, die bei
   einem Funktionsaufruf angegeben werden.
*/
 
#include &lt;stdarg.h&gt;
 
int name(int i, ...)
{
<A NAME="IDX211"></A>
  va_list arg_ptr;
  char *zeichenkette;
 
  /* arg_ptr f&uuml;r Zugriffe durch va_arg und va_end initialisieren */
  /* i ist der letzte benannte Parameter vor ... und in diesem   */
  /* Fall der einzige Parameter, der angegeben werden mu&szlig;.       */
<A NAME="IDX212"></A>
  va_start(arg_ptr, i);
 
  /* solange einen Parameter holen und in Zeichenkette ablegen, */
  /* bis keine Parameter mehr vorhanden sind                    */
<A NAME="IDX213"></A>
  while((zeichenkette=va_arg(arg_ptr, char*))!='\0')
  {
       printf("%s",zeichenkette);
       i++;
  }
 
  fflush(stdout);
 
  /* parameter scanning beenden */
<A NAME="IDX214"></A>
  va_end(arg_ptr);
 
  return i;
}
 
void main(void)
{
  int i=0;
 
  i=name(200,"Hallo",", dies"," ist ein ","Test.");
}
</PRE>
<HR><H1><A NAME="HDRREPEAT" HREF="#ToC_87">6.0 Wiederholungen - Schleifen</A></H1>
<A NAME="IDX215"></A>
<P>Um bestimmte Programmteile wiederholen zu k&ouml;nnen, werden die
Wiederholungsanweisungen verwendet. Sie gliedern sich auf in:
<OL TYPE=1>
<P><LI>while-statement,
<P><LI>do-while-statement und
<P><LI>for-statement.
</OL>
<P>Allen Schleifen ist gemein, da&szlig; sie sich in einen Schleifenkopf
(der bei der <TT>do while</TT>-Schleife aus zwei Teilen besteht)
und einen Schleifenrumpf aufgliedern. Befindet sich mehr als eine
Anweisung im Schleifenrumpf, m&uuml;ssen diese Anweisungen, die bei jedem
Schleifendurchlauf ausgef&uuml;hrt werden, in geschweifte Klammern ({})
eingefa&szlig;t sein.
<P>
<HR><H2><A NAME="Header_88" HREF="#ToC_88">6.1 while</A></H2>
<A NAME="IDX216"></A>
<A NAME="IDX218"></A>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">while - statement</TH><TR><TD>
<PRE>
                                          
>>--while--(--expression--)--statement--><
</PRE>
</TD></TR></TABLE>
<P>Die <TT>while</TT>-Schleife besteht aus einem Schleifenkopf und
einem Schleifenrumpf. Im Schleifenkopf befindet sich die Bedingung zur
Ausf&uuml;hrung eines Schleifendurchlaufs. Im Schleifenrumpf befinden sich
die Anweisungen, die bei jedem Schleifendurchlauf abgearbeitet werden
sollen.
<P>Die while-Schleife ist eine kopfgesteuerte Schleife. Das hei&szlig;t,
da&szlig; die Bedingung vor dem Schleifendurchlauf auf Wahrheit &uuml;berpr&uuml;ft
wird. Der Schleifenrumpf wird solange ausgef&uuml;hrt, wie der Ausdruck
in der Klammer wahr ist.
<P>Codiert wird die <TT>while</TT>-Schleife folgenderma&szlig;en:
<PRE>
   expr1;
 
   while (expr2)
   {
      statement;
      expr3;
   }
</PRE>
<P>Durch <TT>expr1</TT> wird die Kontrollvariable, der Z&auml;hler,
initialisiert. <TT>expr2</TT> ist die Ausf&uuml;hrungsbedingung und
<TT>expr3</TT> legt die Ver&auml;nderung der Kontrollvariablen pro
Schleifendurchlauf fest.
<P>
Beispiel:
<PRE>
   n = 18;                                 /* Initialisierung der    */
   i = 1;                                  /* Schleifenvariablen     */
 
   while (i++ &lt;= n)                        /* Start der Schleife     */
   {
      printf("Ergebnis: %d\n", i*i);       /* Anweisungen im Rumpf   */
   }                                       /* Ende der Schleife      */
</PRE>
<P>Diese Schleife gibt solange das Ergebnis von <TT>i * i</TT> aus,
bis <TT>i</TT> den Wert von <TT>n</TT> (18) erreicht hat. Wenn
<TT>i</TT> den Wert von <TT>n</TT> erreicht hat, wird der letzte
Schleifendurchlauf gestartet. <TT>i</TT> wird
bei jedem Schleifendurchlauf um eins erh&ouml;ht.
<P>
<HR><H2><A NAME="Header_89" HREF="#ToC_89">6.2 do while</A></H2>
<A NAME="IDX219"></A>
<A NAME="IDX221"></A>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">do while - statement</TH><TR><TD>
<PRE>
                                                 
>>--do--statement--while--(--expression--)--&#59;--><
</PRE>
</TD></TR></TABLE>
<P>Die <TT>do while</TT>-Schleife wird ebenfalls solange ausgef&uuml;hrt,
wie der
Ausdruck in der Klammer wahr ist. Allerdings wird erst nach dem
Schleifendurchlauf gepr&uuml;ft, ob die Bedingung wahr ist.
Es handelt sich somit um eine fu&szlig;gesteuerte Schleife.
<P>Beispiel:
<P>
<PRE>
   n = 18;
   i = 1;
 
   do
   {
     printf("Ergebnis: %d\n", i*i);
   } while (i++ &lt;= n);
</PRE>
<P>Diese Schleife wird einmal mehr durchlaufen, als die oben
aufgef&uuml;hrte <TT>while</TT>-Schleife.
<P>
<HR><H2><A NAME="Header_90" HREF="#ToC_90">6.3 for</A></H2>
<A NAME="IDX222"></A>
<A NAME="IDX224"></A>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">for - statement</TH><TR><TD>
<PRE>
                                                                               
>>--for--(--+---------------+--&#59;--+---------------+--&#59;--+---------------+--)-->
            |               |     |               |     |               |      
            +--expression1--+     +--expression2--+     +--expression3--+      
</PRE>
<PRE>
                
>--statement--><
</PRE>
</TD></TR></TABLE>
<P>Die <TT>for</TT>-Schleife wird h&auml;ufig dann eingesetzt, wenn zu
Beginn der Schleife bekannt ist, wie oft sie durchlaufen werden soll.
<UL>
<P><LI><TT>expression1</TT> stellt die Initialisierung der Z&auml;hlvariable
dar.
<P><LI><TT>expression2</TT> stellt die Abbruchbedingung dar.
<P><LI><TT>expression3</TT> stellt die Ver&auml;nderung der Z&auml;hlvariablen dar.
</UL>
Beispiele:
<PRE>
<B>aufw&auml;rts z&auml;hlend&#58;</B>
 
                for (i = 1; i &lt;= n; i++)
                {
                   ...anweisungen...
                }
 
 
<B>abw&auml;rts z&auml;hlend:</B>
 
                for (i = n; i &gt; n; i--)
                {
                   ...anweisungen...
                }
</PRE>
<P>Besonders h&auml;ufig wird die <TT>for</TT>-Schleife zur Verarbeitung
von Feldern (Arrays) verwendet. Das Beispiel zeigt die
Initialisierung eines Feldes mit 50 Komponenten:
<PRE>
                int zahlenfeld[50];
                int index = 0, n = 50;
 
                for (index = 0; index &lt; n; index++)
                {
                   zahlenfeld[index] = index;
                }
</PRE>
<P><I>Anmerkung: Im Vergleich zu anderen Programmiersprachen sind
drei Charakteristika bemerkenswert: Zum ersten die Codierweise der
Addition und zum zweiten die Semikola innerhalb der Klammern!
Des weiteren ist darauf hinzuweisen, da&szlig; nach der Klammer kein
Semikolon, sondern nur ein Blockzeichen codiert wird, wenn
der Schleifenrumpf nicht in den Schleifenkopf integriert
wird.</I>
<P>Die Angabe s&auml;mtlicher Ausdr&uuml;cke
in den Klammern des Schleifenkopfes ist nicht zwingend. Des weiteren
k&ouml;nnen Anweisungen aus dem Schleifenrumpf h&auml;ufig in den Schleifenkopf
mit eingebunden werden.
Die beiden folgenden Codesegmente sind funktionell identisch:
<P>
<PRE>
   int zahlenfeld[50];
   int index = 0, n = 50;
 
   for (index = 0; index &lt; n; index++)
   {
     zahlenfeld[index] = index;
     printf("\n%d", zahlenfeld[index]);
   }
</PRE>
<P>entspricht
<PRE>
   for (index = 0, n = 50; index &lt; n; printf("\n%d", zahlenfeld[index++] = index));
</PRE>
<P>Bei derartigen Vereinfachungen sollte man jedoch aufpassen,
da&szlig; es nicht zu Wechselwirkungen, insbesondere durch das
Inkrementieren der Z&auml;hlvariable, zwischen den einzelnen
Operationen kommt.
<HR><H2><A NAME="HDRBRE" HREF="#ToC_91">6.4 Die Anweisungen break und continue</A></H2>
<A NAME="IDX225"></A>
<A NAME="IDX226"></A>
<P>Die <TT>continue</TT>- und die <TT>break</TT>-Anweisung
werden ausschlie&szlig;lich bei <TT>switch</TT> (siehe hdref
refid=case.) und bei
Schleifen und dort nur im Schleifenrumpf, dem Anweisungsteil,
genutzt. <TT>break</TT> bewirkt einen sofortigen Abbruch der
gesamten Schleife.
Die Durchf&uuml;hrung wird mit dem Befehl nach der abschlie&szlig;enden
geschweiften Klammer des Schleifenblocks fortgesetzt.
<P>Bei der <TT>continue</TT>-Anweisung wird nur der aktuelle
Schleifendurchlauf abgebrochen, d.h. es wird nicht die gesamte
Schleifenverarbeitung beendet, sondern ausschlie&szlig;lich mit dem
n&auml;chsten Schleifendurchlauf begonnen.
<P>Beispiel f&uuml;r <TT>break</TT>:
<PRE>
   for (i = 0; i &lt; 21; i++)
   {
      if (zeichenkette [i] == '#')
         break;
      position++;
   }
</PRE>
<P>Die L&auml;nge der Zeichenkette wird solange hochgez&auml;hlt, bis das Zeichen
<TT>#</TT> auftaucht.
<P>Beispiel f&uuml;r <TT>continue</TT>:
<PRE>
   for (i = 1; i &lt;= 100; i++)
   {
      if (i % 5 == 0) continue;
      printf("\n%d", i);
   }
</PRE>
<P>Es werden s&auml;mtliche Zahlen von 1 bis inklusive 100 ausgegeben, die
nicht durch 5 teilbar sind.
<HR><H1><A NAME="HDRCHOICE" HREF="#ToC_92">7.0 Auswahl</A></H1>
<P>Bei der Auswahl sind zwei m&ouml;gliche Varianten zu betrachten&#58;
<BR>
<TABLE >
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%">1.
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">if/else
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="63%">einfache Auswahl oder Alternativauswahl
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%">2.
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">switch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="63%">mehrfache Auswahl (Liste)
</TD></TR></TABLE>
<P>
<HR><H2><A NAME="Header_93" HREF="#ToC_93">7.1 if/else</A></H2>
<A NAME="IDX227"></A>
<A NAME="IDX228"></A>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">if - statement</TH><TR><TD>
<PRE>
                                                              
>>--if--(--expression--)--statement--+-------------------+--><
                                     |                   |    
                                     +--else--statement--+    
</PRE>
</TD></TR></TABLE>
<P>Die nach <TT>if</TT> in Klammern stehende Bedingung mu&szlig; wahr sein,
damit die darauffolgende Anweisung ausgef&uuml;hrt wird. Sollen mehrere
Anweisungen ausgef&uuml;hrt werden, m&uuml;ssen diese in geschweifte Klammern
({}) eingefa&szlig;t werden.
Beim if-statement unterscheidet man zwei M&ouml;glichkeiten:
<OL TYPE=1>
<P><LI>bedingte Anweisung
<P>Eine Anweisung oder eine Gruppe von Anweisungen wird nur in dem
Fall ausgef&uuml;hrt, wenn die Bedingung wahr (ungleich 0) ist.
<P>1. Beispiel:
<PRE>
        if( kontostand &lt;= 0 )
        {
          zugriff = 0;
          printf("Kein Geld auf dem Konto!");
        }
</PRE>
<P>Wenn der Kontostand kleiner oder gleich Null ist, wird der Zugriff
auf das Konto gesperrt und ein Hinweis ausgegeben.
<P>2. Beispiel:
<PRE>
        if( !kontostand )
        {
          zugriff = 0;
          printf("Exakt 0 DM auf dem Konto!");
        }
</PRE>
<P><LI>Alternativ- oder Zweifachauswahl
<P>Wenn die Bedingung nicht zutrifft, wird der Anweisungsblock nach
<TT>else</TT> ausgef&uuml;hrt.
<P>Beispiel f&uuml;r Alternativ- oder Zweifachauswahl:
<PRE>
   if ( alter &gt; 50 )
   {
      printf("Bald gibt's Rente!");
   }
   else
   {
      printf("Nen bischen dauert's noch.");
   }
</PRE>
</OL>
<P><I>Anmerkung&#58; Wie bei der for-Schleife wird auch hier nach der
Bedingung kein Semikolon, sondern nur eine geschweifte Klammer
(Block-Zeichen) gesetzt.</I>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">Achtung</TH><TR><TD>
Bei Test auf Gleichheit <TT>==</TT> anstatt <TT>=</TT> benutzen!
</TD></TR></TABLE>
<P>
<HR><H2><A NAME="HDRCASE" HREF="#ToC_94">7.2 switch</A></H2>
<A NAME="IDX229"></A>
<P>Mit Hilfe der <TT>switch</TT>-Anweisung kann eine Alternative
unter einer
Liste von verschiedenen M&ouml;glichkeiten gew&auml;hlt werden. Diese Art
der bedingten Auswahl w&auml;re auch mit einer <TT>if/else</TT>-Kombination
erreichbar, allerdings k&auml;me es zu einer Verschachtelung, die auch
mit guten Kommentaren und guter Strukturierung nicht mehr lesbar
w&auml;re.
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">switch</TH><TR><TD>
<PRE>
                                             
>>--switch--(--expression--)--switch body--><
</PRE>
</TD></TR></TABLE>
<P>Dem Schl&uuml;sselwort <TT>switch</TT> folgt ein geklammerter Ausdruck,
dessen Wert f&uuml;r die Auswahl zur Verf&uuml;gung steht. Dem Ausdruck folgt der
<TT>switch body</TT>, der in einfacher und in komplexer Form
existiert:
<P>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">switch body - einfache Form</TH><TR><TD>
<PRE>
                                                                    
>>--+-case label - statement-----------------------------------+--><
    |                                                          |    
    +-+------------+--default label--+------------+--statement-+    
      +-case label-+                 +-case label-+                 
</PRE>
</TD></TR></TABLE>
<P>Die einfache Form enth&auml;lt einen oder mehrere <TT>case</TT>-Zweige
und einen <TT>default</TT>-Zweig (optional) mit einzelnen
Anweisungen.
<P>H&auml;ufig benutzt wird die komplexe Form:
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">switch body - komplexe Form</TH><TR><TD>
<PRE>
                                                             
       <-----------------------------<  <----------------<   
                                                             
>>--{--V+--------------------------+-+--V+-------------+-+-->
        |-type definition----------|     +-case clause-+     
        |                          |                         
        |-extern declaration-------|                         
        |                          |                         
        +-internal data definition-+                         
</PRE>
<PRE>
                                                
                       <----------------<       
                                                
>--+----------------+--V+-------------+-+--}--><
   +-default clause-+   +-case clause-+         
</PRE>
</TD></TR></TABLE>
<P>Die komplexe Form besteht ebenfalls aus einem oder mehreren
<TT>case</TT>-Zweigen und einem (optionalen)
<TT>default</TT>-Zweig.
Der Unterschied zur einfachen Form besteht darin, da&szlig; in der komplexen
Form jeder Zweig Variablendeklarationen enthalten kann.
<P>Syntax der einfachen Form:
<A NAME="IDX230"></A>
<A NAME="IDX231"></A>
<A NAME="IDX232"></A>
<PRE>
   switch ( Ausdruck )
   {
 
      case konstanter Ausdruck : Anweisung;
                                 [break;]
      case konstanter Ausdruck :
              Anweisung 1;
              Anweisung 2;
              ...
              Anweisung n;
              [break;]
      default : Anweisung;
                [break;]
   }
</PRE>
<P>Syntax der komplexen Form:
<A NAME="IDX233"></A>
<A NAME="IDX234"></A>
<A NAME="IDX235"></A>
<PRE>
   switch ( Ausdruck )
   {
 
      case konstanter Ausdruck : { Anweisung;
                                   [break;] }
      case konstanter Ausdruck :
           {
              Variablendeklarationen;
 
              Anweisung 1;
              Anweisung 2;
              ...
              Anweisung n;
              [break;]
           }
      default : Anweisung;
                [break;]
   }
</PRE>
<P>Beispiel:
<PRE>
   switch(zeichen)
   {
     case 'a': printf("Kleinbuchstabe\n"); break;
     case 'b': printf("Kleinbuchstabe\n"); break;
     ...
     case 'z': printf("Kleinbuchstabe\n"); break;
     case 'A': printf("Grossbuchstabe\n"); break;
     case 'B': printf("Grossbuchstabe\n"); break;
     ...
     case 'Z': printf("Grossbuchstabe\n"); break;
     case '0': printf("Ziffer\n"); break;
     case '1': printf("Ziffer\n"); break;
     ...
     case '9': printf("Ziffer\n"); break;
     default : printf("Anderes Zeichen\n"); break;
   }
</PRE>
<P>In diesem Beispiel wird eine Variable <TT>zeichen</TT>
(definiert als <TT>char zeichen;</TT>) daraufhin &uuml;berpr&uuml;ft,
ob es sich um einen Gro&szlig;buchsteben, Kleinbuchstaben oder eine
Ziffer handelt. Die Zeilen mit ... kennzeichnen lediglich,
da&szlig; im Beispiel einige Zeilen ausgelassen wurden. Es besteht keine
M&ouml;glichkeit, Bereiche in der <TT>case</TT>-Bedingung anzugeben.
<P><TT>break</TT> wurde bereits in Abschnitt <A HREF="#HDRBRE">6.4, "Die Anweisungen break und continue"</A>
beschrieben. Bei <TT>switch</TT> sorgt dieses Schl&uuml;sselwort daf&uuml;r,
da&szlig; der <TT>switch</TT>-Durchlauf abgebrochen wird. Wird dieses
Schl&uuml;sselwort nicht verwendet und der Ausdruck einer der
<TT>case</TT>-Zweige trifft zu, so durchl&auml;uft das Programm nicht nur
diesen Zweig, sondern auch s&auml;mtliche nachfolgende, bis es auf ein
<TT>break</TT> trifft. Dadurch k&ouml;nnen wir uns einigen Aufwand im
obigen Beispiel sparen:
<PRE>
   switch(zeichen)
   {
     case 'a':
     case 'b':
     ...
     case 'z': printf("Kleinbuchstabe\n"); break;
     case 'A':
     case 'B':
     ...
     case 'Z': printf("Grossbuchstabe\n"); break;
     case '0':
     case '1':
     ...
     case '9': printf("Ziffer\n"); break;
     default : printf("Anderes Zeichen\n"); break;
   }
</PRE>
<P>Dieses Verhalten von <TT>break</TT> wird auch im n&auml;chsten Beispiel
zur Ausgabe der Anzahl der Tage eines Monats benutzt.
Nach Eingabe des Monats soll ausgegeben werden, ob der Monat
30, 31 oder 28 Tage hat.
<PRE>
#include &lt;stdio.h&gt;
 
enum monate { Januar=1, Februar, Maerz, April, Mai, Juni, Juli,
              August, September, Oktober, November, Dezember } monat;
 
void main(void)
{
   int num;
 
   printf("Bitte den gew&uuml;nschten Monat (1-12) eingeben: ");
   fflush(stdout);
   scanf("%d", &num);
   monat=num;
   switch (monat)
   {
     case Januar   :
     case Maerz    :
     case Mai      :
     case Juli     :
     case August   :
     case Oktober  :
     case Dezember : printf("Der Monat hat 31 Tage.\n");    break;
     case Februar  : printf("Der Monat hat 28/29 Tage.\n"); break;
     default       : printf("Der Monat hat 30 Tage.\n");    break;
   } /* Ende switch */
}  /* Ende main */
</PRE>
<P>Wird <TT>Januar, Maerz, Mai, Juli, August</TT> oder
<TT>Oktober</TT> durch Eingabe der entsprechenden Zahl
ausgew&auml;hlt, so wird ebenfalls in den Zweig
<TT>Dezember</TT> verzweigt. Dadurch wird f&uuml;r alle Monate, die 31
Tage haben, die korrekte Anzahl der Tage mit nur einer Anweisung
ausgegeben. Die Anweisung <TT>break</TT> beendet den Durchlauf.
<P>Handelt es sich bei der Eingabe um <TT>Februar</TT>, so verzweigt
das Programm nicht in die ersten sechs Zweige, sondern erst in den
Zweig <TT>Februar</TT> und gibt 28 als Anzahl der Tage aus. Die
Anweisung <TT>break</TT> beendet auch hier den Durchlauf.
<P>F&uuml;r alle &uuml;brigen Eingaben wird 30 als Anzahl der Tage ausgegeben,
auch wenn z.B. <TT>Pizza Bringdienst</TT> eingegeben wurde,
<P>Wird <TT>default</TT> ohne eine folgende Anweisung verwendet,
so mu&szlig; ein Semikolon folgen:
<P>
<PRE>
default:;
</PRE>
<P>
<HR><H1><A NAME="HDRFILE" HREF="#ToC_95">8.0 Dateibehandlung</A></H1>
<A NAME="IDX236"></A>
<P>In diesem Kapitel wird  die Arbeit mit Dateien unter C vorgestellt.
Es wird auf die grundlegenden Funktionen, wie z.B.
Dateien &ouml;ffnen/schlie&szlig;en, Daten aus Dateien lesen, Daten in
Dateien schreiben und
Daten an bestehende Dateien anh&auml;ngen, eingegangen.
Des weiteren wird auf die Unterschiede in der Benutzung von Text- und
Bin&auml;rdateien hingewiesen.
<P>
<HR><H2><A NAME="Header_96" HREF="#ToC_96">8.1 Datei &ouml;ffnen/schlie&szlig;en</A></H2>
<A NAME="IDX238"></A>
<P>
Bevor Dateien verarbeitet werden k&ouml;nnen, m&uuml;ssen sie von dem Programm
f&uuml;r die Bearbeitung vorbereitet werden. Diese Vorbereitung nennt man
Datei &ouml;ffnen. Das Betriebssystem wird veranla&szlig;t, Speicher
bereitzustellen, in dem Informationen bez&uuml;glich der ge&ouml;ffneten Datei
abgelegt werden. Nach der Nutzung der Datei mu&szlig; sie wieder
geschlossen werden, damit die neuen Informationen dauerhaft auf dem
Datentr&auml;ger gespeichert werden. Anhand eines Beispiels wird die
Vorgehensweise erl&auml;utert.
<P>Dieses Beispiel &ouml;ffnet eine Datei und schlie&szlig;t sie wieder,
wenn der Versuch, sie zu &ouml;ffnen, erfolgreich verlaufen ist:
<P>
<PRE>
   /*  Datei_io.c                             */
   /*  demonstriert die funktionen zum &ouml;ffnen */
   /*  und schlie&szlig;en von dateien in c         */
 
   #include &lt;stdio.h&gt;
 
   void main(void)
   {
      /* Zeiger f&uuml;r die Datei deklarieren      */
<A NAME="IDX239"></A>
      FILE *datei_ptr=NULL;                                (1)
 
      /* Datei &ouml;ffnen und Return-Code annehmen */
<A NAME="IDX240"></A>
      datei_ptr = fopen("TEST.TXT","w");                   (2)
 
      /* Return-Code auswerten                 */
      if (datei_ptr != NULL)
      {
         /* wenn kein fehler, datei schlie&szlig;en  */
<A NAME="IDX241"></A>
         fclose(datei_ptr);                                (3)
      }
   }
</PRE>
<P>zu (1): Mit <TT>FILE *datei_ptr;</TT>
wird ein Zeiger mit dem Namen
<I>datei_ptr</I> definiert. F&uuml;r jede gleichzeitig ge&ouml;ffnete Datei
mu&szlig; ein Zeiger mit einem eigenen Namen deklariert werden, dessen Name
in allen folgenden Operationen (Beispiele hier: (2),(3))
eingesetzt wird, die sich auf die
zugeh&ouml;rige Datei beziehen. Die Anweisung kann gelesen werden als:
<TT>datei_ptr</TT> ist ein Zeiger auf ein Objekt des Typs
<TT>FILE</TT>, hinter dem sich eine Struktur verbirgt.
<TT>FILE</TT>
ist ein vordefinierter Typ aus der Definitionsdatei <TT>stdio.h</TT>,
der immer gro&szlig; geschrieben wird und Dateizugriffe erm&ouml;glicht.
<P>zu (2): Die Funktion <TT>fopen()</TT> &ouml;ffnet die Datei
<TT>TEST.TXT</TT>. Die Syntax der Funktion lautet:
<BR>
<TT>zeiger = fopen(dateiname, zugriffsmodus)&#59;</TT>
<BR>
<TT>datei_ptr</TT> nimmt den R&uuml;ckgabewert der Funktion
<TT>fopen()</TT> auf. Dieser ist entweder ein Zeiger auf die
Dateistruktur der ge&ouml;ffneten Datei oder <TT>NULL</TT>, wenn beim
&Ouml;ffnen der Datei ein Fehler aufgetreten ist.
<TT>TEST.TXT</TT> ist der Dateiname der Datei, die ge&ouml;ffnet wird und
<TT>w</TT> der Zugriffsmodus. 
<A NAME="IDX242"></A>
Der Zugriffsmodus
bestimmt die Art und Weise, in der auf die Datei zugegriffen werden kann.
Die folgende Liste enth&auml;lt die zul&auml;ssigen Dateizugriffsmodi:
<BR>
<DL>
<P><DT><B>Modus</B>
<DD><B>Beschreibung</B>
<P><DT>r
<DD>Die Datei wird nur zum Lesen ge&ouml;ffnet. Voraussetzung ist, da&szlig; die
Datei bereits existiert. Ansonsten bekommt der Zeiger
<TT>NULL</TT> zugewiesen.
<P><DT>w
<DD>Eine leere Datei wird zum Schreiben ge&ouml;ffnet. Falls die Datei bereits
besteht, wird die Dateil&auml;nge auf Null gesetzt. Dies entspricht dem
L&ouml;schen des Inhaltes der Datei.
<P><DT>a
<DD>Die Datei wird nur zum Schreiben ge&ouml;ffnet. Die neuen Daten werden am
Ende angeh&auml;ngt, wenn die Datei existiert, anderenfalls wird sie erstellt.
<P><DT>r+
<DD>Eine existierende Datei wird zum Lesen und Schreiben ge&ouml;ffnet.
<P><DT>w+
<DD>Eine Datei wird zum Lesen und zum Schreiben ge&ouml;ffnet und erstellt,
falls sie noch nicht existiert. Anderenfalls wird der Inhalt gel&ouml;scht.
<P><DT>a+
<DD>Eine Datei wird sowohl zum Lesen als auch zum Anh&auml;ngen an das
Dateiende ge&ouml;ffnet. Existiert sie noch nicht, so wird sie erstellt.
</DL>
<P>Au&szlig;er diesen Zugriffsmodi mu&szlig; dem Compiler mitgeteilt werden, ob
die Datei im bin&auml;ren oder im Text-Modus ge&ouml;ffnet werden soll. Dies
geschieht durch das Anh&auml;ngen eines <TT>b</TT> f&uuml;r bin&auml;r
an das K&uuml;rzel f&uuml;r den Zugriffsmodus. F&uuml;r den Zugriff im Text-Modus
ist kein K&uuml;rzel erforderlich. Dennoch ist es bei einigen Compilern
m&ouml;glich, ein <TT>t</TT> f&uuml;r den Text-Modus anzuh&auml;ngen. Auf dieses
K&uuml;rzel sollte jedoch verzichtet werden, um die Portabilit&auml;t des Codes
zu gew&auml;hrleisten, da einige Compiler dieses K&uuml;rzel nicht unterst&uuml;tzen.
So compiliert Visual Age C<TT>++</TT>
f&uuml;r OS/2 ein Programm, das dieses K&uuml;rzel
enth&auml;lt, zwar anstandslos und ohne Fehlermeldung oder Warnung, beim
Betrieb des Programms ist dieses dann jedoch nicht in der Lage, Dateien
zu &ouml;ffnen.
<P>zu (3): Mit <TT>fclose(datei_ptr);</TT> wird
die Datei geschlossen.
Dabei f&uuml;hrt das Betriebssystem eine Reihe von Schritten aus:
<OL TYPE=1>
<P><LI>Die zur Zwischenpufferung genutzten Speicher werden geleert und die
noch nicht gespeicherten Daten auf den Datentr&auml;ger geschrieben.
<P><LI>Die Verbindung zwischen Datei und Dateizeiger wird unterbrochen,
so da&szlig; der Zeiger f&uuml;r eine andere Datei verwendet werden kann.
<P><LI>Der Systembereich der Festplatte (oder eines anderen
Massenspeichers) wird aktualisiert (Gr&ouml;&szlig;e,
Position, Datum/Zeitpunkt der letzten Modifikation, etc.).
</OL>
<P>
<HR><H2><A NAME="Header_97" HREF="#ToC_97">8.2 Zeichen und Zeichenketten aus Dateien lesen</A></H2>
<A NAME="IDX244"></A>
<P>Um den Inhalt einer
Datei lesen zu k&ouml;nnen, mu&szlig; sie im Lesezugriff ge&ouml;ffnet
und eine Variable deklariert werden, die die gelesenen Daten aufnimmt.
Im folgenden Beispiel wird die Datei <TT>TEST.TXT</TT> ge&ouml;ffnet und die
Variable <TT>zeichen</TT> zur Aufnahme der Daten deklariert:
<P>
<PRE>
   /*   datei_2.c                                              */
   /*   demonstriert das lesen von textdaten aus einer datei   */
   /*                                                          */
 
   #include &lt;stdio.h&gt;
 
 
   void main(void)
   {
      /* deklaration lokaler variablen */
      FILE *datei_ptr=NULL;                  /* Dateizeiger   */
      char datei[12]="TEST.TXT";             /* Dateiname     */
      char zugriff[3]="r";                   /* Zugriffsmodus */
      char zeichen;
 
      /* datei oeffnen und return-code auswerten */
      datei_ptr = fopen(datei , zugriff);
 
      if (datei_ptr == NULL)       /* &ouml;ffnen fehlgeschlagen */
      {
        printf("Die Datei %s konnte nicht ge&ouml;ffnet werden!", datei);
        exit(1);
      }
      else                         /* &ouml;ffnen gegl&uuml;ckt */
      {
        /* zeichen aus der datei lesen */
<A NAME="IDX245"></A>
        zeichen=fgetc(datei_ptr);
        while (!feof(datei_ptr))
        {
<A NAME="IDX246"></A>
              putchar(zeichen);    /*  zeichen auf der standardausgabe
                                       ausgeben */
              zeichen=fgetc(datei_ptr);
<A NAME="IDX247"></A>
        }
 
        /* datei schliessen */
        fclose(datei_ptr);
        printf("Die Datei %s wurde geschlossen!", datei);
 
      } /* ende &ouml;ffnen gegl&uuml;ckt */
 
   } /* ende main */
</PRE>
<P>In diesem Beispiel wird die Dateiverarbeitung vollst&auml;ndig in
Funktionen ausgelagert. Das Hauptprogramm hat nur noch
aufrufende und auf Fehler testende Funktion. Die Dateifunktionen
zum &Ouml;ffnen, Lesen und Schlie&szlig;en wurden bereits erl&auml;utert.
<P>In der Funktion <TT>datei_lesen()</TT> werden in der
<TT>while</TT>-Schleife mit <TT>fgetc()</TT> solange einzelne
Zeichen aus der, mit <TT>datei_ptr</TT> referenzierten, Datei gelesen
und der Variablen <TT>zeichen</TT> zugewiesen, bis sie den Wert
<TT>EOF</TT> erreicht hat. Ist das Ende der Datei noch nicht
erreicht, wird jedes einzelne Zeichen ausgegeben.
<P><I>Anmerkung&#58; 'Zeichen' wird in der Funktion 'datei_lesen'
als Integer-Wert deklariert, da es jedes beliebige ASCII-Zeichen
inklusive dem EOF-Zeichen annehmen k&ouml;nnen mu&szlig;. In einigen C
Implementierungen liegt der Wert von EOF au&szlig;erhalb des Wertebereichs
des Typs char, da diese standardm&auml;&szlig;ig unsigned char verwenden.</I>
<P>Die Funktion <TT>exit(R&uuml;ckgabewert)</TT> beendet das C-Programm mit
sofortiger Wirkung. Es werden alle Puffer geleert und alle ge&ouml;ffneten
Dateien automatisch geschlossen. Der R&uuml;ckgabewert <TT>1</TT> gibt dem
Benutzer bekannt, da&szlig; bei der Ausf&uuml;hrung des Programms ein Fehler
aufgetreten ist, wobei der R&uuml;ckgabewert nicht ausgegeben, sondern in
einer sogenannten <I>Umgebungsvariable</I> des Betriebssystems
(unter DOS z.B. <TT>Errorlevel</TT>) abgelegt wird. Diese
Umgebungsvariable kann von einem aufrufenden Programm ausgewertet werden.
<P>
<P>Beim Lesen von Zeichenketten
aus einer Datei ergeben sich nur geringf&uuml;gige
&Auml;nderungen gegen&uuml;ber dem Lesen von einzelnen Zeichen. Zur
Veranschaulichung soll dennoch das obige Beispiel, mit den notwendigen
Modifikationen, verwendet werden:
<P>
<PRE>
   /*   zeichenk_lesen.c                                           */
   /*   demonstriert das lesen von zeichenketten aus einer datei   */
   /*                                                              */
 
   #include &lt;stdio.h&gt;
 
   FILE *datei_ptr=NULL;
 
   void datei_oeffnen (char datei[], char zugriff[])
   {
     datei_ptr = fopen(datei , zugriff);
     return;
   }
 
   /* die einzigen unterschiede zwischen dem lesen einzelner zeichen  */
   /* und dem lesen von strings aus einer datei sind in der funktion  */
   /* datei_lesen zu finden. es werden andere variablendeklarationen  */
   /* und die funktion fgets benutzt.                                 */
   void datei_lesen (void)
   {
      char satz[256];
      do
      {
<A NAME="IDX248"></A>
         satz = fgets(satz, 256, datei_ptr);
<A NAME="IDX249"></A>
         fputs(satz, stdout);
      } while (!feof(datei_ptr));
     return;
   }
 
   void datei_schliessen (void)
   {
     fclose(datei_ptr);
     return;
   }
 
   void main(void)
   {
 
      char datei[12]="TEST.TXT";
      char zugriff[3]="r";
 
      datei_oeffnen(datei, zugriff);
      if (datei_ptr == NULL)
      {
        printf("Die Datei %s konnte nicht ge&ouml;ffnet werden!", datei);
        exit(1);
      }
      else
      {
        datei_lesen();
        datei_schliessen();
        printf("Die Datei %s wurde geschlossen!", datei);
      }
   }
</PRE>
<P>Die &Auml;nderungen wirken sich nur in der Funktion
<TT>datei_lesen</TT> aus.
Statt <TT>fgetc()</TT> wird <TT>fgets()</TT>
und statt <TT>putchar()</TT> wird <TT>fputs()</TT>
verwendet. Dabei ist zu bemerken, da&szlig;
<TT>fgets()</TT> und <TT>fputs()</TT> mehr
Parameter ben&ouml;tigen, als die Funktionen zur zeichenweisen Behandlung.
Die Funktion <TT>fgets()</TT> erwartet drei Parameter. Der erste
Paramater stellt die Adresse des Daten aufnehmenden Feldes dar, der
zweite Parameter die Gr&ouml;&szlig;e dieses Feldes und der dritte Parameter
kennzeichnet als Zeiger die Quelle der zu lesenden Zeichenkette.
<P>Die Angabe des Gr&ouml;&szlig;enparameters ist notwendig, da nicht mehr Zeichen
eingelesen werden d&uuml;rfen, als <TT>satz</TT> aufnehmen kann. Die Datei
wird immer bis zum Ende (EOF, End Of File) gelesen und mit Hilfe von
<TT>fputs()</TT> ausgegeben. Diese Funktion &uuml;bernimmt zwei Parameter.
Der erste Parameter ist die auszugebende Zeichenkette
und der zweite Parameter
bezeichnet die Ausgabe (hier: Standard Output/ i.d.R. der Bildschirm).
<P>
<HR><H2><A NAME="Header_98" HREF="#ToC_98">8.3 Zeichen in Dateien schreiben</A></H2>
<P>Im folgenden werden die Funktionen zum Schreiben von
einzelnen Zeichen und Zeichenketten vorgestellt. Sie sind
ohne Probleme in die oben genannten Programme einbindbar.
<P>Streng genommen ist das Schreiben von Daten
bereits behandelt worden, nur nicht
in eine Datei, sondern auf den Bildschirm.
Der <TT>putc()</TT> Funktion mu&szlig; lediglich
die Adresse der Datei mit Hilfe des Zeigers
(<TT>datei_ptr</TT>) gegeben werden.
<P>In dem folgenden Beispiel wird zum Lesen der Zeichen von der
Tastatur die Funktion <TT>getchar()</TT> verwendet.
<P>
<PRE>
   void datei_schreiben(void)
   {
      char zeichen;
 
      /* solange zeichen einlesen, bis enter gedr&uuml;ckt wird */
<A NAME="IDX250"></A>
      while ((zeichen = getchar()) != '\n')
            /* zeichen in die datei schreiben */
            putc(zeichen, datei_ptr);
     return;
   }
</PRE>
<P>
<P><H3><A NAME="Header_99" HREF="#ToC_99">8.3.1 Zeichenketten in eine Datei schreiben</A></H3>
<P>Wie beim Lesen von Zeichenketten
aus einer Datei, sind auch beim Schreiben von Zeichenketten
in eine Datei einige zus&auml;tzliche Angaben notwendig.
<P>
<PRE>
   void datei_schreiben(void)
   {
      char satz[256]
 
      /* satz mit einer maximalen l&auml;nge von 256 zeichen einlesen */
      fgets(satz, 256, stdin);
 
      /* solange wiederholen, bis in einer leeren zeile enter    */
      /* gedr&uuml;ckt wird                                           */
      while(satz[0] == '\n')
      {
         /* satz in datei schreiben */
         fputs(satz, datei_ptr2);
 
         /* neuen satz lesen */
         fgets(satz, 256, stdin);
      }
     return;
   }
</PRE>
<P>Es werden solange S&auml;tze mit einer maximalen Anzahl von 256 Zeichen von
der Tastatur eingelesen und in die Datei geschrieben, bis in einer leeren
Zeile die Taste <B>ENTER</B> gedr&uuml;ckt wird.
<P>Die Funktion <TT>fputs()</TT> schreibt Zeichenketten in die mit
<TT>datei_ptr2</TT> bezeichnete Datei.
<P>
<P><H3><A NAME="Header_100" HREF="#ToC_100">8.3.2 Anh&auml;ngen von Daten an eine bereits vorhandene Datei</A></H3>
<P>Das Anh&auml;ngen von Daten erfolgt nicht &uuml;ber eine spezielle Funktion,
sondern &uuml;ber den Zugriffsmodus. Je nachdem, ob die Datei nur zum Anh&auml;ngen
oder auch zum Lesen ge&ouml;ffnet werden soll, verwendet man
<TT>a</TT> oder <TT>a+</TT>. Zum Schreiben der Daten werden die
bereits erw&auml;hnten Funktionen <TT>fputs()</TT> und <TT>putc()</TT>
verwendet.
<P>
<HR><H2><A NAME="Header_101" HREF="#ToC_101">8.4 Das Arbeiten mit bin&auml;ren Dateien</A></H2>
<A NAME="IDX252"></A>
<P>Der Unterschied zwischen Text- und Bin&auml;rdateien besteht in den
unterschiedlichen Informationen, die in ihnen enthalten sind. Textdateien
enthalten Zeichenfolgen, die f&uuml;r den Menschen verst&auml;ndlich sind. Sie
bestehen aus alphanumerischen Zeichen, Satzzeichen und einigen
Steuerzeichen. Diese Art von Dateien kann zeilenorientiert aufgebaut
sein.
<P>Bin&auml;rdateien besitzen keine Zeilenstruktur und sind f&uuml;r den
Menschen in der Regel unverst&auml;ndlich.
Ein weiterer Unterschied besteht in der Codierung von Zahlen. In
der bin&auml;ren Datei werden Zahlen abgelegt, wie sie im Hauptspeicher
vorliegen (z.B. <TT>int</TT> mit 4 Byte in einer bestimmten Reihenfolge)
und nicht - wie in Textdateien - als eine Folge von Ziffern.
<P>Bei einer Bin&auml;rdatei sieht der Modus zum &Ouml;ffnen einer Datei
wie folgt aus:
<PRE>
   rb
   wb
   ab
   rb+
   wb+
   ab+
</PRE>
<P>
<P><H3><A NAME="Header_102" HREF="#ToC_102">8.4.1 Bin&auml;res Lesen von Integer Daten</A></H3>
<P>Prinzipiell werden alle Datentypen in Bl&ouml;cken &agrave; 1 Byte gespeichert,
wobei die Reihenfolge der Bytes im Speicher je nach Betriebssystem
und Prozessor unterschiedlich sein kann.
Ein 4 Byte langer Integer mit dem Wert x wird bin&auml;r wie folgt
dargestellt (Big Endian):
<PRE>
11110000 00001111 11111111 00000000
</PRE>
<P>Auf bestimmten Systemen werden diese vier Bytes jedoch in umgekehrter
Reihenfolge abgelegt:
<PRE>
00000000 11111111 00001111 11110000
</PRE>
<P>Oder auch folgenderma&szlig;en (Little Endian):
<PRE>
11111111 00000000 11110000 00001111
</PRE>
<A NAME="IDX253"></A>
<P>Allgemein unterscheidet man die Varianten <I>Little Endian</I>
(z.B. Intel x86, low Bytes, high Bytes)
<A NAME="IDX254"></A>
und <I>Big Endian</I> (z.B. RS/6000, high Bytes, low Bytes).
<P>Der folgende Beispielcode liest vier Byte aus einer Datei und speichert
diese als (long) Integer in Abh&auml;ngigkeit einer symbolischen Konstante, die
die Zielhardware spezifiziert.
<PRE>
void readINT32(FILE *file_in, UINT32 *integer)
{
  unsigned char p[4];
 
  p[0]=fgetc(file_in); p[1]=fgetc(file_in);
  p[2]=fgetc(file_in); p[3]=fgetc(file_in);
 
# ifdef RS6000
  // Big Endian - RS6000
  *integer=(((((p[0] &lt;&lt; 8) | p[1]) &lt;&lt; 8) | p[2]) &lt;&lt; 8) | p[3];
# else
  // Little Endian - DOS, OS/2 on Intel x86
  *integer=(((((p[3] &lt;&lt; 8) | p[2]) &lt;&lt; 8) | p[1]) &lt;&lt; 8) | p[0];
# endif
 
  return;
} //--- end - readINT32()
</PRE>
<P>Das folgende Beispiel liest zwei Byte aus einer bin&auml;ren
Datei und interpretiert sie als short int.
<PRE>
void readINT16(FILE *bmp_in, UINT16 *integer)
{
  unsigned char p[2];
 
  p[0]=fgetc(bmp_in); p[1]=fgetc(bmp_in);
 
# ifdef RS6000
  // Big Endian - RS6000
  *integer=(p[0] &lt;&lt; 8) | p[1]; // Big Endian - AIX
# else
  // Little Endian - DOS, OS/2 on Intel x86
  *integer=(p[1] &lt;&lt; 8) | p[0]; // Little Endian - DOS, OS/2
#endif
 
  return;
} //--- end - readINT16()
</PRE>
<P>Mit dieser Funktion kann z.B. die H&ouml;he und Breite einer
Bitmap ausgelesen werden, deren Werte als 19-22. Bytes einer
Bitmap gespeichert werden. Z.B. ergibt sich aus
<TT>FD 02 87 01</TT> 765x391 Pixel
(<TT>02 FD</TT>x<TT>01 87</TT>).
<P><H3><A NAME="Header_103" HREF="#ToC_103">8.4.2 Bin&auml;res Lesen von Flie&szlig;kommadaten</A></H3>
<P>F&uuml;r die Darstellung von Flie&szlig;kommazahlen im Speicher existieren
f&uuml;r fast alle Prozessorsysteme unterschiedliche Varianten, was den
Datenaustausch erschwert.
<HR><H2><A NAME="Header_104" HREF="#ToC_104">8.5 Zusammenfassung Lesen/Ausgeben von Daten</A></H2>
<P>Die folgende Tabelle zeigt die zum Lesen und Augeben
m&ouml;glichen Funktionen. Auf Funktionen, die noch nicht in den Beispielen
vorgekommenen sind, wird im Anschlu&szlig; kurz eingegangen.
<BR>
<P><B><A NAME="Table_9" HREF="#FT_Table_9">Tabelle 9. Funktionen zum Lesen/Ausgeben</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Schreiben
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Lesen
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Daten
</TH></TR><TR>
<A NAME="IDX255"></A>
<A NAME="IDX256"></A>
<A NAME="IDX257"></A>
<A NAME="IDX258"></A>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">putc(), fputc()
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">getc(), fgetc()
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Zeichen
</TD></TR><TR>
<A NAME="IDX259"></A>
<A NAME="IDX260"></A>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">fputs()
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">fgets()
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Zeichenkette
</TD></TR><TR>
<A NAME="IDX261"></A>
<A NAME="IDX262"></A>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">fprintf()
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">fscanf()
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">formatierte Daten
</TD></TR><TR>
<A NAME="IDX263"></A>
<A NAME="IDX264"></A>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">fwrite()
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">fread()
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Block
</TD></TR></TABLE>
<P>Die Funktionen <TT>fprintf()</TT> und <TT>fscanf()</TT> werden
f&uuml;r das &Uuml;bertragen von Feldern mit einer festen L&auml;nge verwendet. Der
Gebrauch unterscheidet sich nur in der Angabe der Datei von den
Funktionen <TT>printf()</TT> und <TT>scanf()</TT>.
<P>
Beispiel:
<P>
<PRE>
    fprintf(datei_ptr, "Horst ist %d Jahre alt!\n", jahre);
</PRE>
<P>Mit dieser Anweisung wird in der angegebenen Datei ein Satz mit
einer variablen Angabe des Alters abgespeichert und das
Zeilenendezeichen angef&uuml;gt.
<P>Die Funktionen <TT>fwrite()</TT> und <TT>fread()</TT> schreiben
beziehungsweise lesen <TT>n</TT> Datenobjekte der Gr&ouml;&szlig;e
<TT>size</TT> aus/in einem/n Puffer aus/in die mit <TT>datei_ptr</TT>
angegebene Datei.
<P>Beispiel:
<P>(1) Syntax:
<P>
<PRE>
   fwrite(buffer, size, n, *fp);
</PRE>
<P>Diese Anweisung speichert n Objekte der Gr&ouml;&szlig;e <TT>size</TT> aus
dem Speicherbereich ab der Adresse von <TT>buffer</TT> in die Datei,
auf die der Dateizeiger <TT>*fp</TT> verweist.
<P>Anwendung:
<P>
<PRE>
   fwrite(katalog, sizeof(BUCH), 200, datei_ptr);
</PRE>
<P>Diese Anweisung speichert 200 Objekte der Gr&ouml;&szlig;e der Struktur
<TT>BUCH</TT>
aus dem Speicherbereich ab der Adresse von <TT>katalog</TT> in die
Datei, auf die der Dateizeiger <TT>datei_ptr</TT> verweist.
<P>(2) Syntax:
<P>
<PRE>
   fread(buffer, size, n, *fp);
</PRE>
<P>Mit dieser Anweisung werden die Daten aus einer Datei in den
Speicherbereich ab der Adresse von <TT>buffer</TT> geschrieben.
<TT>size</TT> beschreibt die Gr&ouml;&szlig;e und n die Anzahl der Objekte.
<P>Anwendung:
<P>
<PRE>
   fread(katalog, sizeof(BUCH), 200, datei_ptr);
</PRE>
<P>Mit dieser Anweisung werden die Daten aus einer Datei, auf die der
Dateizeiger <TT>datei_ptr</TT> verweist, in den
Speicherbereich ab der Adresse von <TT>katalog</TT> geschrieben.
Die Gr&ouml;&szlig;e der Objekte soll der Gr&ouml;&szlig;e der Struktur <TT>BUCH</TT>
entsprechen. Es sollen 200 dieser Objekte gelesen werden.
<P>
<HR><H1><A NAME="HDRMEMORY" HREF="#ToC_105">9.0 Speicherverwaltung</A></H1>
<A NAME="IDX265"></A>
<P>Die Speicherverwaltungsfunktionen kommen z.B. zum Einsatz, wenn
die Gr&ouml;&szlig;e des ben&ouml;tigten Speichers unbekannt ist.
Speicher f&uuml;r Variablen und Konstanten wird bereits vom
Compiler reserviert und ist dadurch statisch und in seiner Gr&ouml;&szlig;e
vorgegeben. Im folgenden wird eine Auswahl der zur Verf&uuml;gung
stehenden Funktionen vorgestellt.
<HR><H2><A NAME="Header_106" HREF="#ToC_106">9.1 Speicherplatz reservieren</A></H2>
<A NAME="IDX267"></A>
<A NAME="IDX268"></A>
<P>Syntax:
<PRE>
void *malloc(size_t size);
</PRE>
<P>Die Funktion <TT>malloc</TT> reserviert einen Block
angegebener Gr&ouml;&szlig;e im Speicher.
Konnte Speicher reserviert werden, liefert
<TT>malloc</TT> einen Zeiger auf den
angelegten Speicherbereich zur&uuml;ck. Konnte kein Speicher
reserviert werden oder wurde als Gr&ouml;&szlig;e 0 Bytes angegeben,
wird NULL zur&uuml;ckgegeben.
<P>Beispiel 1:
<PRE>
/* Speicherplatz mit malloc reservieren */
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
 
void main(void)
{
  char *block=NULL; /* Zeiger auf Zeichen deklarieren */
  int i;
 
  /* Speicherbereich mit 4000 Bytes reservieren und */
  /* zur&uuml;ckgegebenen Zeiger in Zeiger auf Zeichen   */
  /* umwandeln                                      */
  block=(char *)malloc(4000);
  if(block!=NULL)
  {
    for(i=0;i&lt;4000;block[i++]=' ');
    printf("Speicherblock angelegt und initialisiert.");
  }
  else
    printf("Speicherblock konnte nicht angelegt werden.");
}
</PRE>
<P>Beispiel 2:
<PRE>
/* Speicherplatz mit malloc reservieren */
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
 
void main(void)
{
  int *block=NULL; /* Zeiger auf Integer deklarieren */
  int i;
 
  /* Speicherbereich mit 20*32 Bits reservieren und */
  /* zur&uuml;ckgegebenen Zeiger in Zeiger auf Integer   */
  /* umwandeln                                      */
  block=(int *)malloc(20*sizeof(int));
  if(block!=NULL)
  {
    for(i=0;i&lt;20;printf("%d\n",(block[i++]=i)));
    printf("Speicherblock angelegt und initialisiert.");
  }
  else
    printf("Speicherblock konnte nicht angelegt werden.");
}
</PRE>
<HR><H2><A NAME="Header_107" HREF="#ToC_107">9.2 Speicherplatz reservieren und initialisieren</A></H2>
<A NAME="IDX270"></A>
<A NAME="IDX271"></A>
<P>Syntax:
<PRE>
void *calloc(size_t num, size_t size);
</PRE>
<P>Die Funktion <TT>calloc</TT> legt
einen Speicherbereich an und initialisiert diesen mit 0.
Ansonsten verh&auml;lt sich <TT>calloc</TT> wie
<TT>malloc</TT>.
<P>Beispiel:
<PRE>
/* Speicherplatz mit calloc reservieren */
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
 
void main(void)
{
  int *block=NULL; /* Zeiger auf Integer deklarieren */
  int i;
 
  /* Speicherbereich mit 20*32 Bits reservieren und */
  /* zur&uuml;ckgegebenen Zeiger in Zeiger auf Integer   */
  /* umwandeln                                      */
  block=(int *)calloc(20,sizeof(int));
  if(block!=NULL)
  {
    for(i=0;i&lt;20;printf("Inhalt von %d : %d\n",i,block[i++]));
    printf("Speicherblock angelegt und initialisiert.");
  }
  else
    printf("Speicherblock konnte nicht angelegt werden.");
}
</PRE>
<HR><H2><A NAME="Header_108" HREF="#ToC_108">9.3 Speicherplatzgr&ouml;&szlig;e ver&auml;ndern</A></H2>
<A NAME="IDX273"></A>
<A NAME="IDX274"></A>
<P>Syntax:
<PRE>
void *realloc(void *ptr, size_t size);
</PRE>
<P>Die Funktion <TT>realloc</TT> &auml;ndert die Gr&ouml;&szlig;e eines
bereits angelegten Speicherbereichs. Der Inhalt des
alten (bei Vergr&ouml;&szlig;erung) bzw. &uuml;brigbleibenden (bei Verkleinerung)
Speicherbereichs bleibt erhalten.
Die Funktion <TT>realloc</TT> liefert wie <TT>malloc</TT>
einen Zeiger auf den Speicherbereich zur&uuml;ck.
<P>Beispiel:
<PRE>
/* Speicherplatz mit calloc reservieren und mit realloc ver&auml;ndern */
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
 
void main(void)
{
  int *block=NULL; /* Zeiger auf Integer deklarieren */
  int i;
 
  /* Speicherbereich mit 20*32 Bits reservieren und */
  /* zur&uuml;ckgegebenen Zeiger in Zeiger auf Integer   */
  /* umwandeln                                      */
  block=(int *)calloc(20,sizeof(int));
  if(block!=NULL)
  {
    for(i=0;i&lt;20;printf("Inhalt von %d : %d\n",i,block[i++]));
    printf("Speicherblock angelegt und initialisiert.\n");
  }
  else
    printf("Speicherblock konnte nicht angelegt werden.");
 
  for(i=0;i&lt;20;block[i++]=i);
 
  /* Speicherblock vergr&ouml;&szlig;ern */
  block=realloc(block,40*sizeof(int));
  if(block!=NULL)
  {
    for(i=0;i&lt;40;printf("Inhalt von %d : %d\n",i,block[i++]));
    printf("Speicherblock ge&auml;ndert.\n");
  }
 
  /* Speicherblock verkleinern */
  block=realloc(block,10*sizeof(int));
  if(block!=NULL)
  {
    for(i=0;i&lt;10;printf("Inhalt von %d : %d\n",i,block[i++]));
    printf("Speicherblock ge&auml;ndert.");
  }
}
</PRE>
<HR><H2><A NAME="Header_109" HREF="#ToC_109">9.4 Speicherblock freigeben</A></H2>
<A NAME="IDX276"></A>
<A NAME="IDX277"></A>
<P>Wird ein reservierter Speicherblock nicht mehr ben&ouml;tigt,
sollte dieser mit der Funktion <TT>free</TT>
freigegeben werden, um nicht unn&ouml;tig Speicherplatz
zu blockieren.
<P>Syntax:
<PRE>
void free(void *ptr);
</PRE>
<P>Beispiel:
<PRE>
/* Speicherplatz mit malloc reservieren und mit free freigeben */
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
 
void main(void)
{
  char *block=NULL; /* Zeiger auf Zeichen deklarieren */
  int i;
 
  /* Speicherbereich mit 4000 Bytes reservieren und */
  /* zur&uuml;ckgegebenen Zeiger in Zeiger auf Zeichen   */
  /* umwandeln                                      */
  block=(char *)malloc(4000);
  if(block!=NULL)
  {
    for(i=0;i&lt;4000;block[i++]=' ');
    printf("Speicherblock angelegt und initialisiert.");
  }
  else
    printf("Speicherblock konnte nicht angelegt werden.");
 
  /* speicherplatz freigeben */  free(block);
}
</PRE>
<HR><H2><A NAME="Header_110" HREF="#ToC_110">9.5 Verkettete Listen</A></H2>
<A NAME="IDX278"></A>
<P>Mittels Zeiger und Speicherverwaltungsfunktionen
lassen sich effektiv Listen aufbauen, ohne
vorher zu wissen, wieviel Listenelemente ben&ouml;tigt werden.
Des weiteren lassen sich flexibel Listenelemente einf&uuml;gen und
l&ouml;schen.
<P>Eine Liste besteht aus einer beliebigen Anzahl
fest definierter Elemente. Diese Elemente sind
Speicherbereiche, die i.d.R. als Strukturen mit einer
festen Anzahl an Strukturelementen betrachtet werden.
Eine derartige Liste kann z.B. zur Verwaltung von Studenten
benutzt werden. Um eine Verbindung der einzelnen Listenelemente
untereinander gew&auml;hrleisten zu k&ouml;nnen, werden diese
&uuml;ber Zeiger miteinander verbunden. Hierbei unterscheidet man
einfach und doppelt verkettete Listen. Einfach verkettete
Listen enthalten in der Struktur nur einen Zeiger, der auf
das nachfolgende Listenelement zeigt (also ein Zeiger auf eine
Struktur). Eine doppelt verkettete Liste enth&auml;lt in der
Struktur zus&auml;tzlich einen Zeiger, der auf das vorherige
Listenelement zeigt.
<P><B><A NAME="FIGDLISTE" HREF="#FT_FIGDLISTE">Abbildung 11. Doppelt verkettete Liste</A></B><BR>
<B><BR><CENTER><IMG SRC="liste.gif" ALT="Figure liste not displayed."></CENTER><BR></B><BR>
<P>Da die doppelt verkettete Liste wesentlich flexibler
ist als die einfach verkettete Liste, wird auf die
doppelt verkettete Liste ausf&uuml;hrlich eingegangen und die
einfach verkettete Liste lediglich der Vollst&auml;ndigkeit
halber vorgestellt.
<P><H3><A NAME="Header_111" HREF="#ToC_111">9.5.1 Doppelt verkettete Liste</A></H3>
<A NAME="IDX280"></A>
<P>In diesem Abschnitt wird vorgestellt, wie eine
doppelt verkettete Liste erzeugt, Listenelemente
hinzugef&uuml;gt und gel&ouml;scht werden.
<P><H4><A NAME="Header_112">9.5.1.1 Doppelt verkettete Liste erzeugen</A></H4>
<P>Der Vorgang zur Erzeugung einer doppelt verketteten
Liste gliedert sich wie folgt:
<OL TYPE=1>
<P><LI>Vorbereitungen
<OL TYPE=a>
<P><LI>Mittels <TT>typedef</TT> einen Strukturtyp
definieren, der die Daten eines Listenelements
aufnimmt.
<P><LI>Eine Variable dieses Strukturtyps deklarieren.
<P><LI>Mehrere Pointer dieses Strukturtyps deklarieren:
<UL>
<P><LI>Der Pointer <TT>start</TT> dient dazu,
die Adresse des ersten Listenelements aufzunehmen.
<P><LI>Der Pointer <TT>ende</TT> dient dazu,
die Adresse des letzten Listenelements aufzunehmen.
<P><LI>Der Pointer <TT>momentan</TT> dient dazu,
die Adresse des aktuellen Listenelements aufzunehmen.
<P><LI>Der Pointer <TT>zwischen</TT> dient dazu,
die Adresse des vorherigen Listenelements aufzunehmen.
</UL>
<P><LI>Deklarierte Pointer mit NULL initialisieren.
</OL>
<P><LI>Erstes Listenelement erzeugen
<OL TYPE=a>
<P><LI>Speicher mittels <TT>malloc</TT> reservieren
(momentan=...)
<P><LI>Strukturelemente mit Nutzdaten f&uuml;llen.
<P><LI>Zeiger auf vorheriges Listenelement in der Struktur
auf NULL setzen.
<P><LI>Zeiger <TT>start</TT> mit der Adresse des momentanen
Speicherblocks f&uuml;llen.
<P><LI>Zeiger <TT>zwischen</TT> mit der Adresse des momentanen
Speicherblocks f&uuml;llen.
</OL>
<P><LI>Weitere Listenelemente erzeugen
<OL TYPE=a>
<P><LI>Speicher mittels <TT>malloc</TT> reservieren
<P><LI>Strukturelemente mit Nutzdaten f&uuml;llen.
<P><LI>Zeiger auf vorheriges Listenelement in der Struktur
mit dem Wert des Zeigers <TT>zwischen</TT> f&uuml;llen.
<P><LI>Zeiger auf vorheriges Listenelement in der Struktur,
auf die der Zeiger <TT>zwischen</TT> zeigt, mit der
Adresse des momentanen Speicherblocks f&uuml;llen.
<P><LI>Zeiger <TT>zwischen</TT> mit der Adresse des momentanen
Speicherblocks f&uuml;llen.
</OL>
<P><LI>Letztes Listenelement erzeugen
<OL TYPE=a>
<P><LI>Vorgang wie oben, aber momentan-&gt;danach=NULL
</OL>
</OL>
<PRE>
/* Doppelt verkettete Liste anlegen und benutzen */
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
 
/* Strukturtyp f&uuml;r Listenelement definieren und */
/* Variable DATEI deklarieren                   */
typedef struct datei
{
  int satznummer;
  char nachname[20+1];
  char vorname[20+1];
  struct datei *davor;
  struct datei *danach;
} DATEI;
 
DATEI *momentan, *zwischen, *start, *ende;
 
void speicher_anfordern(void);
void liste_fuellen(int);
void liste_ausgeben(void);
 
void main(void)
{
  int i;
 
  zwischen=NULL;                             /* Zeiger auf vorheriges Element */
  for(i=1;i&lt;=3;i++)
  {
     speicher_anfordern();
     liste_fuellen(i);
     momentan-&gt;davor=zwischen;               /* Zeiger auf vorheriges Element */
     if(zwischen) zwischen-&gt;danach=momentan; /* zwischen&lt;&gt;NULL, ab 2.Element  */
     else start=momentan;                    /* zwischen==NULL, nur 1.Element */
     zwischen=momentan;                      /* momentane Adresse f&uuml;r Zeiger  */
                                             /* auf vorheriges Element retten */
  }
  momentan-&gt;danach=NULL;                     /* Zeiger auf nachfolgendes      */
                                             /* Element bei letztem Element   */
  ende=momentan;                             /* Zeiger auf letztes Element    */
  liste_ausgeben();
}
 
void speicher_anfordern(void)
{
   /* Speicher anfordern und Zeiger per Typecast &auml;ndern */
   if((momentan=(DATEI *)malloc(sizeof(DATEI))) == NULL)
   {
      printf("\nKein Speicherplatz zur Verf&uuml;gung!\n");
      exit(8);
   }
   return;
}
 
void liste_fuellen(i)
{
   int t;
   /* Strukturelemente mit Nutzdaten f&uuml;llen */
   momentan-&gt;satznummer=i;
   strcpy(momentan-&gt;nachname,"Nachname ");
   for(t=1;t&lt;=i;t++)
      strcat(momentan-&gt;nachname,"x");
   strcpy(momentan-&gt;vorname,"Vorname");
   return;
}
 
void liste_ausgeben(void)
{
   printf("\nListe vorw&auml;rts ausgeben\n");
   /* Zeiger auf erstem Element positionieren */
   momentan=start;
   /* Solange es Elemente gibt, also bis momentan==NULL */
   while(momentan)
   {
      printf("\nSatz %d\nNachname %s\nVorname %s\n",
             momentan-&gt;satznummer,momentan-&gt;nachname,
             momentan-&gt;vorname);
      /* Zeiger auf n&auml;chstem Element positionieren */
      momentan=momentan-&gt;danach;
   }
   printf("\nListe r&uuml;ckw&auml;rts ausgeben\n");
   /* Zeiger auf letztem Element positionieren */
   momentan=ende;
   while(momentan)
   {
      printf("\nSatz %d\nNachname %s\nVorname %s\n",
             momentan-&gt;satznummer,momentan-&gt;nachname,
             momentan-&gt;vorname);
      /* Zeiger auf vorherigem Element positionieren */
      momentan=momentan-&gt;davor;
   }
   return;
}
</PRE>
<P><H4><A NAME="Header_113">9.5.1.2 Listenelement einf&uuml;gen</A></H4>
<P>Das Einf&uuml;gen eines Listenelementes wird durch &Auml;nderung
der Zeiger des vorhergehenden und des nachfolgenden
Listenelementes erreicht.
Die Zeiger <TT>danach</TT> des vorhergehenden
Listenelementes und <TT>davor</TT> des nachfolgenden
Listenelementes m&uuml;ssen
auf das einzuf&uuml;gende Element zeigen.
Der Zeiger <TT>davor</TT> des einzuf&uuml;genden Elementes
mu&szlig; auf das vorhergehende Listenelement zeigen und
der Zeiger <TT>danach</TT> auf das nachfolgende
Listenelement.
<P>Der folgende Beispielcode enth&auml;lt nur die neue Funktion
<TT>liste_einfuegen(void)</TT> und einen Beispielaufruf.
S&auml;mtliche mit ... angegeben Stellen sind mit dem vorhergehenden
Quelltext identisch.
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">Hinweis</TH><TR><TD>
<P>Dieser Beispielcode ist nicht auf alle m&ouml;glichen
Konstellationen ausgelegt!
</TD></TR></TABLE>
<PRE>
 
 . . .
void liste_einfuegen(void);
 . . .
void main(void)
{
   . . .
   ende=momentan;
   liste_ausgeben();
 
   /* Neues Listenelement einf&uuml;gen */
   zwischen=start-&gt;danach; /* zeiger vorbereiten, um element zwischen erstem
                              und zweitem element einzuf&uuml;gen */
   liste_einfuegen();
   printf("\n\nListe nach dem Einf&uuml;gen eines Elements an zweiter Position:\n");
   liste_ausgeben();
}
 . . .
void liste_einfuegen(void)
{
   DATEI *hilfszeiger;
 
   /* 1.) Speicher f&uuml;r das neue Listenelement anfordern */
   speicher_anfordern();         /* momentan erhaelt adresse des neuen elements */
 
   /* 2.) Struktur mit Nutzdaten f&uuml;llen */
   liste_fuellen(10);
 
   /* 3.) Zeiger aller drei Element 'korrigieren' */
   hilfszeiger=zwischen-&gt;davor;  /* zeiger auf vorheriges element */
   momentan-&gt;davor=hilfszeiger;  /* neues element auf vorheriges verweisen lassen */
   hilfszeiger-&gt;danach=momentan; /* vorheriges element auf neues verweisen lassen */
   momentan-&gt;danach=zwischen;    /* neues element auf nachfolgendes verweisen lassen */
   zwischen-&gt;davor=momentan;     /* nachfolgendes auf neues verweisen lassen */
 
   return;
}
 . . .
 
</PRE>
<P><H4><A NAME="Header_114">9.5.1.3 Listenelement l&ouml;schen</A></H4>
<P>
<P>Der folgende Beispielcode enth&auml;lt nur die neue Funktion
<TT>liste_einfuegen(void)</TT> und einen Beispielaufruf.
S&auml;mtliche mit ... angegeben Stellen sind mit dem vorhergehenden
Quelltext identisch.
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">Hinweis</TH><TR><TD>
<P>Dieser Beispielcode ist nicht auf alle m&ouml;glichen
Konstellationen ausgelegt!
</TD></TR></TABLE>
<PRE>
 
 . . .
void liste_loeschen(void);
 . . .
void main(void)
{
   . . .
   ende=momentan;
   liste_ausgeben();
 
   /* Neues Listenelement einf&uuml;gen */
   zwischen=start-&gt;danach; /* zeiger vorbereiten, um element zwischen erstem
                              und zweitem element einzuf&uuml;gen */
   liste_einfuegen();
   printf("\n\nListe nach dem Einf&uuml;gen eines Elements an zweiter Position:\n");
   liste_ausgeben();
 
 
   zwischen=start-&gt;danach; /* zeiger vorbereiten, um element zwischen erstem
                              und zweitem element einzuf&uuml;gen */
   liste_loeschen();
   printf("\n\nListe nach dem L&ouml;schen eines Elements an zweiter Position:\n");
   liste_ausgeben();
}
 . . .
void liste_loeschen(void)
{
   DATEI *hilfszeiger;
 
   hilfszeiger=zwischen-&gt;davor; /* zeiger auf element vor dem zu l&ouml;schenden
                                   element */
   hilfszeiger-&gt;danach=zwischen-&gt;danach;
 
   hilfszeiger=zwischen-&gt;danach;
   hilfszeiger-&gt;davor=zwischen-&gt;davor;
   return;
}
 
</PRE>
<P><H3><A NAME="Header_115" HREF="#ToC_115">9.5.2 Einfach verkettete Liste</A></H3>
<A NAME="IDX282"></A>
<P>Im Gegensatz zur doppelt verketteten Liste wird bei der
einfach verketteten Liste nur die Adresse zum nachfolgenden
Element gesichert.
<PRE>
 
/* Einfach verkettete Liste anlegen und benutzen */
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
 
typedef struct datei
{
  int satznummer;
  char nachname[20+1];
  char vorname[20+1];
  struct datei *danach;
} DATEI;
 
DATEI *momentan, *zwischen, *start;
 
void speicher_anfordern(void);
void liste_fuellen(int);
void liste_ausgeben(void);
 
void main(void)
{
  int i;
 
  zwischen=NULL;
  for(i=1;i&lt;=3;i++)
  {
     speicher_anfordern();
     liste_fuellen(i);
     if(zwischen) zwischen-&gt;danach=momentan; /* zwischen&lt;&gt;NULL, ab 2.Element  */
     else start=momentan;                    /* zwischen==NULL, nur 1.Element */
     zwischen=momentan;
  }
  momentan-&gt;danach=NULL;
  liste_ausgeben();
}
 
void speicher_anfordern(void)
{
   if((momentan=(DATEI *)malloc(sizeof(DATEI))) == NULL)
   {
      printf("\nKein Speicherplatz zur Verf&uuml;gung!\n");
      exit(8);
   }
   return;
}
 
void liste_fuellen(i)
{
   int t;
   momentan-&gt;satznummer=i;
   strcpy(momentan-&gt;nachname,"Nachname ");
   for(t=1;t&lt;=i;t++)
      strcat(momentan-&gt;nachname,"x");
   strcpy(momentan-&gt;vorname,"Vorname");
   return;
}
 
void liste_ausgeben(void)
{
   momentan=start;
   while(momentan)
   {
      printf("\nSatz %d\nNachname %s\nVorname %s\n",
             momentan-&gt;satznummer,momentan-&gt;nachname,
             momentan-&gt;vorname);
      momentan=momentan-&gt;danach;
   }
   return;
}
 
</PRE>
<HR><H2><A NAME="Header_116" HREF="#ToC_116">9.6 Speicherverwaltungsfunktionen f&uuml;r Debugging</A></H2>
<A NAME="IDX283"></A>
<P>Die folgenden Funktionen stellen einen Ersatz f&uuml;r malloc() und free() dar:
<PRE>
void *Malloc(size_t size);
void Free(char **ptr);
</PRE>
<P>Wie anhand der Funktionsprototypen zu sehen ist, ben&ouml;tigt der Aufruf
von Free() einen anderen Parameter als free().
<PRE>
free(puffer);
</PRE>
mu&szlig; nun folgenderma&szlig;en aussehen:
<PRE>
Free( (char **) &puffer );
</PRE>
<P>Die neuen Funktionen Malloc() und Free() geben folgende Funktionen bei ihrem
Aufruf aus:
<UL>
<P><LI>Die Gr&ouml;&szlig;e des Speicherblocks.
<P><LI>Die Adresse des Speicherblocks.
<P><LI>Den Namen der Source Code Datei, aus der die Funktion aufgerufen wurde.
<P><LI>Die Zeile der Source Code Datei, aus der die Funktion aufgerufen wurde.
</UL>
<P>Die Funktionen werden jedoch nur dann benutzt, wenn das Symbol
DEBUG_MEMORY per #define DEBUG_MEMORY definiert wurde. Anderenfalls werden
alle Aufrufe von Malloc() und Free() durch die Aufrufe
von malloc() und free() ersetzt.
<P>Source Code f&uuml;r Malloc():
<PRE>
/*----------------------------------------------------------------------------*/
/* Malloc()                                                                   */
/*----------------------------------------------------------------------------*/
#if DEBUG_MEMORY
 void *Malloc(size_t size, char *srcFile, int srcLine)
 {
   void *ptr;
 
   ptr=malloc( size );
   printf("Allocating %06d bytes of memory at %d in %s at line %05d\n",
          size, ptr, srcFile, srcLine);
   return ptr;
 }
<A NAME="IDX284"></A>
<A NAME="IDX285"></A>
<A NAME="IDX286"></A>
#define Malloc( val ) Malloc( val, __FILE__, __LINE__)
#else
#   define Malloc(val) malloc(val)
#endif
/*--- End - Debugversion malloc() ---*/
</PRE>
<P>Source Code f&uuml;r Free():
<PRE>
/*----------------------------------------------------------------------------*/
/* Free()                                                                     */
/*----------------------------------------------------------------------------*/
#ifdef DEBUG_MEMORY
 void Free(char **ptr, char *srcFile, int srcLine)
 {
   printf("Releasing  %06d bytes of memory at %d in %s at line %05d ",
           _msize(*ptr), *ptr, srcFile, srcLine);
   if( *ptr != NULL )
   {
      free( *ptr );
      *ptr = NULL;
   }
   printf("-&gt; %d\n",*ptr);
 }
#define Free( val ) Free( val, __FILE__, __LINE__);
#else
#   define Free(val) free(* val);
#endif
/*--- End Debugversion free() ---*/
</PRE>
<HR><H1><A NAME="HDRBS" HREF="#ToC_117">10.0 Verbindungen zum Betriebssystem</A></H1>
<P>Von Zeit zu Zeit ist es notwendig, von einem Programm aus ein anderes
Programm zu starten, Betriebssystembefehle auszuf&uuml;hren oder dem
Programm beim Aufruf von der Kommandozeile aus Daten
(sog. <I>Kommandozeilenparameter</I>) mitzugeben.
<P>In diesem Kapitel werden die dazu ben&ouml;tigten Funktionen vorgestellt
und anhand von Beispielen verdeutlicht, wie unter C die Verbindung
zum Betriebssystem hergestellt werden kann. Je nach verwendetem
Betriebssystem bzw. verwendeter Entwicklungsumgebung werden weitere
Funktionen zur Verf&uuml;gung gestellt, wie z.B. <TT>DosExecPgm</TT>
unter OS/2.
<P>
<HR><H2><A NAME="Header_118" HREF="#ToC_118">10.1 Kommandozeilenparameter auswerten</A></H2>
<A NAME="IDX287"></A>
<P>Eingangs wurde bereits erw&auml;hnt, da&szlig; die
Funktion <TT>main()</TT> die einzige Funktion ist, die
Kommandozeilenparameter empfangen kann. Kommandozeilenparameter sind
Argumente, die beim Programmstart durch Leerzeichen voneinander
getrennt hinter dem Programmnamen angegeben werden.
<P>Beispiel:
<P>
<PRE>
DISKCOPY A: B:
</PRE>
<P>In diesem Fall wird das Programm <TT>DISKCOPY</TT> aufgerufen,
dem als Kommandozeilenparameter <TT>A&#58;</TT> und
<TT>B&#58;</TT> mitgegeben werden. Solche Parameter werden in C
der Funktion <TT>main()</TT> &uuml;bergeben.
<P>Die Funktionsweise soll anhand eines einfachen Beispiels
erl&auml;utert werden:
<PRE>
/* KOMPARA.C     liest Kommandozeilenparameter ein und gibt */
/*               sie aus                                    */
#include &lt;stdio.h&gt;
 
main(int argc, char *argv[])
{
   int zaehler;
 
   if (argc &lt; 2)                  /* Parameter vorhanden ? */
   {
      printf("Es wurden keine Kommandozeilenparameter angegeben!\n");
      exit(4);
   }
 
   for (zaehler=1; zaehler&lt;argc; zaehler++)
       printf("\nParameter %d = %s", zaehler, argv[zaehler]);
}
</PRE>
<A NAME="IDX288"></A>
<A NAME="IDX289"></A>
<P>Die Funktion <TT>main()</TT> erh&auml;lt vom Betriebssystem zwei
Parameter: <TT>argc</TT> und <TT>argv[]</TT>.
<TT>argc</TT> enth&auml;lt die Anzahl der an das Programm
&uuml;bergebenen Parameter. <TT>argv[]</TT> enth&auml;lt die
eigentlichen Parameter. Enth&auml;lt <TT>argc</TT> den Wert 1, so
bedeutet dies, da&szlig; kein Parameter &uuml;bergeben wurde, da
grunds&auml;tzlich der Programmname als erster Parameter an das Programm
&uuml;bergeben wird. <TT>argv[0]</TT> enth&auml;lt somit den
Namen des Programms. Zus&auml;tzlich wird noch der Parameter
<TT>envp</TT> &uuml;bergeben, der Daten des sog. Environments
beinhalten kann.
<P>Die Namen der Variablen sind frei w&auml;hlbar, allerdings stellen
die oben angegeben Bezeichner einen Quasi-Standard dar.
<P>Die Deklaration <TT>char *argv[]</TT> bedeutet: Zeiger
auf Zeiger auf Zeichen. Diese Deklaration ist &auml;quivalent zu
<TT>char **argv</TT>. <TT>argv</TT> ist ein Zeiger, der auf ein
Feld zeigt, welches wiederum Zeiger enth&auml;lt, die ihrerseits auf die
einzelnen Kommandozeilenparameter zeigen. Durch die leeren eckigen
Klammern wird definiert, da&szlig; das Feld eine unbekannte Anzahl an
Elementen hat.
<P>
<HR><H2><A NAME="Header_119" HREF="#ToC_119">10.2 Betriebssystembefehle ausf&uuml;hren</A></H2>
<A NAME="IDX290"></A>
<P>Damit Betriebssystembefehle von einem C-Programm aus aufgerufen
werden k&ouml;nnen,
<A NAME="IDX291"></A>
verwendet C die Funktion <TT>system</TT>. Diese Funktion steht
sowohl unter DOS als auch unter UNIX zur Verf&uuml;gung und leitet
s&auml;mtliche Systembefehle, die in der Kommandozeile des Betriebssystems
eingegeben werden k&ouml;nnen, an das Betriebssystem weiter. Als Argument
wird der Funktion die Kommandozeile in doppelten Hochkommata
(<TT>"</TT>) &uuml;bergeben.
<P>Beispiel:
<P>
<PRE>
    resultat = system("dir c: &gt; dirlist.txt");
</PRE>
<P>Die Funktion &uuml;bergibt den R&uuml;ckgabewert des Systembefehls
(erfolgreich==0, Fehler &lt;&gt;0) an die Variable
<I>resultat</I>, die daraufhin ausgewertet werden kann.
<P>
<HR><H2><A NAME="Header_120" HREF="#ToC_120">10.3 Programme starten</A></H2>
<A NAME="IDX292"></A>
<P>Um andere Programme starten zu k&ouml;nnen, verwendet C in
<A NAME="IDX293"></A>
<A NAME="IDX294"></A>
DOS-Umgebungen die Funktionen <TT>spawn()</TT> und <TT>exec()</TT>.
Die beiden Funktionen unterscheiden sich nur in einem Punkt: bei der
Verwendung von <TT>spawn()</TT> bleibt das aufrufende Programm im
Speicher, w&auml;hrend das aufgerufene (child-Prozess) ausgef&uuml;hrt wird.
Nach Beendigung des aufgerufenen Programms wird die Kontrolle
an das aufrufende Programm zur&uuml;ckgegeben.
Bei <TT>exec()</TT> hingegen wird das
aufrufende Programm im Speicher &uuml;berlagert und nach Beendigung des
Child-Prozesses auf die Betriebssystemebene zur&uuml;ckgekehrt.
Da <TT>spawn()</TT>
mit Hilfe eines Schalters dazu gebracht werden kann, sich wie
<TT>exec()</TT> zu verhalten, wird in diesem Zusammenhang
nur auf <TT>spawn()</TT> eingegangen.
<P>Um eine vorher bekannte Anzahl von Parametern zu &uuml;bergeben,
wird die Funktion <TT>spawnl()</TT> verwendet. Steht die Anzahl der
Parameter nicht fest, so ist die Funktion <TT>spawnv()</TT> zu
benutzen. Im folgenden
werden die einzelnen Varianten mit deren Syntax aufgef&uuml;hrt.
<P>Die Funktion <TT>spawnl()</TT> existiert in den folgenden Varianten:
<PRE>
  int spawnl(int mode, char *path, char *arg(),..., NULL);
  int spawnlp(int mode, char *path, char *arg(),..., NULL);
  int spawnle(int mode, char *path, char *arg(),..., NULL, char *envp[]);
  int spawnlpe(int mode, char *path, char *arg(),..., NULL, char *envp[]);
</PRE>
<P>Auf die Bedeutung der einzelnen Funktionsnamenszus&auml;tze und
Argumente wird weiter unten eingegangen.
<P>Die Funktion <TT>spawnv()</TT> existiert in den folgenden Varianten:
<PRE>
  int spawnv(int mode, char *path, char *argv[]);
  int spawnvp(int mode, char *path, char *argv[]);
  int spawnve(int mode, char *path, char *argv[], char *envp[]);
  int spawnvpe(int mode, char *path, char *argv[], char *envp[]);
</PRE>
<P>Die Zus&auml;tze am Funktionsnamen haben die folgenden Bedeutungen:
<DL>
<P><DT><B> Zeichen</B>
<DD><B> Bedeutung</B>
<P><DT>p
<DD>Die <TT>spawn()</TT>-Funktion sucht nach dem aufzurufenden
Programm nicht nur
im momentanen Verzeichnis, sondern in s&auml;mtlichen,
im Betriebssystem mit <TT>PATH</TT> festgelegten Verzeichnissen.
<P><DT>e
<DD>erm&ouml;glicht die &Uuml;bergabe eines eigenen Environments (eigene
Umgebungsvariablen f&uuml;r das aufzurufende Programm.
</DL>
<P>Die folgende Aufstellung beschreibt die Parameter, die mitgegeben
werden:
<DL>
<P><DT><TT>mode</TT>
<DD>legt fest, wie sich das aufrufende Programm
w&auml;hrend der Ausf&uuml;hrung des aufzurufenden Programmes
verh&auml;lt. Folgende Angaben sind m&ouml;glich:
<OL TYPE=1>
<P><LI><TT>P_WAIT</TT>: das aufrufende Programm bleibt im Speicher, wird
aber w&auml;hrend der Ausf&uuml;hrung des aufzurufenden Programmes stillgelegt.
<P><LI><TT>P_NOWAIT</TT>: das aufrufende Programm und das aufzurufende
Programm werden konkurrierend ausgef&uuml;hrt. Dieser Modus ist nur in
Multitaskingumgebungen verf&uuml;gbar.
<P><LI><TT>P_OVERLAY</TT>: das aufrufende Programm wird vom aufzurufenden
Programm &uuml;berlagert und nach dessen Beendigung nicht weitergef&uuml;hrt.
Entspricht der Funktion <TT>exec()</TT>.
</OL>
<P><DT><TT>path</TT>
<DD>gibt den Namen des aufzurufenden Programmes an.
<P><DT><TT>argv</TT>
<DD>beinhaltet die Argumente, die an das aufzurufende Programm
&uuml;bergeben werden. <TT>argv[0]</TT> sollte den Namen des aufzurufenden
Programmes beinhalten. Die weiteren Argumente sind wahlfrei.
<P><DT><TT>NULL</TT>
<DD>ist obligatorisch und schlie&szlig;t die Argumentenliste ab.
<P><DT><TT>envp</TT>
<DD>ist ein Zeigerfeld, dessen Inhalt &uuml;bergeben wird, um ein Environment
an das aufzurufende Programm &uuml;bergeben zu k&ouml;nnen. Das h&ouml;chste
Element des eigentlichen Umgebungsfeldes mu&szlig; <TT>NULL</TT> enthalten.
</DL>
<P>Beispiele:
<DL>
<P><DT><B> Variante</B>
<DD><B> Bedeutung</B>
<P><DT>spawnl(P_WAIT,"c:\\os2\\e.exe","c:\\os2\\e.exe",
"autoexec.bat",NULL)&#59;
<DD>
<P>Das aufzurufende Programm <TT>e.exe</TT> wird geladen und gestartet.
Durch <TT>P_WAIT</TT> verbleibt das aufrufende Programm im Speicher.
Der Parameter <TT>autoexec.bat</TT> wird an den Editor <TT>e.exe</TT>
&uuml;bergeben. Die Wiederholung der Angabe <TT>e.exe</TT> ist notwendig,
da unter DOS der erste Parameter standardm&auml;&szlig;ig der Programmname des
aufzurufenden Programmes sein sollte. Das Ende der
Parameterliste wird durch <TT>NULL</TT> gekennzeichnet.
<P><DT>spawnlp(P_WAIT,"e.exe","e.exe","autoexec.bat",NULL)&#59;
<DD>
<P>Wie oben, nur da&szlig; im aktuellen Verzeichnis und gem&auml;&szlig; der
<TT>PATH</TT>-Angabe nach dem aufzurufenden Programm
<TT>e.exe</TT> gesucht wird.
<P><DT>spawnlpe(P_OVERLAY,"e.exe","e.exe","autoexec.bat",
NULL, environment)&#59;
<DD>
<P>Wie oben, nur da&szlig; im aktuellen Verzeichnis und gem&auml;&szlig; der
<TT>PATH</TT>-Angabe nach dem aufzurufenden Programm gesucht wird.
Zus&auml;tzlich werden die Angaben des Zeigers <TT>environment</TT>
an das Betriebssystem &uuml;bergeben. <TT>environment</TT> mu&szlig; als
Zeigerfeld vom Typ <TT>char *environment[];</TT> deklariert sein.
Die Angabe <TT>P_OVERLAY</TT> bewirkt, da&szlig;
<TT>spawn()</TT> sich wie <TT>exec()</TT> verh&auml;lt.
</DL>
<P>Aufgrund der Komplexit&auml;t der Erl&auml;uterungen soll noch ein
Programmbeispiel angef&uuml;gt werden:
<P>
<PRE>
 /* SPAWN.C                                                        */
 /* Dieses Programm demonstriert die Verwendungsweise der Funktion */
 /* spawn() anhand der Variante spawnlp().                         */
 
 #include &lt;stdlib.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;process.h&gt;
 
/* Festlegung des Environments f&uuml;r das aufzurufende Programm */
char *environment[]=
 {
    "TEMP=C:\\",
    "PATH=C:\\OS2;C:\\OS2\\APPS",
    NULL
 };
 
 
void main(void)
{
/* Deklaration einer lokalen Return-Code-Variablen */
int res;
 
    /* Aufruf von E.EXE */
    res = spwanlp(P_WAIT,"e.exe","e.exe","autoexec.bat", NULL,
                  environment);
 
    /* Aufruf erfolgreich? */
    if(res)
       printf("Der Proze&szlig; konnte nicht gestartet werden!");
    else
       printf("spwanlp() beendet!");
 }
</PRE>
<P>Das oben abgebildete Beispielprogramm ruft den
Editor <TT>e.exe</TT> auf und gibt ihm ein eigenes
Environment und
Kommandozeilenparameter mit. Nach dem Aufruf wird anhand der Variablen
<TT>res</TT>, die das Resultat des Aufrufes entgegennimmt,
&uuml;berpr&uuml;ft, ob der Aufruf erfolgreich war.
<P>Der folgende Programmcode demonstriert die Verwendung einiger
spawn Funktionen und wurde der CP Reference (Teil der Dokumentation
der IBM C/C<TT>++</TT> FirstStep Tools Version 2.01) entnommen.
<PRE>
 /************************************************************************
 
 This example shows calls to four of the eight _spawn routines.  When
 called without arguments from the command line, the program first
 runs the code for case PARENT.  It spawns a copy of itself, waits for
 its child to run, then spawns a second child.  The instructions for the
 child are blocked to run only if argv[0] and one parameter were
 passed (case CHILD).  In its turn, each child spawns a grandchild as a
 copy of the same program.  The grandchild instructions are blocked by
 the existence of two passed parameters. The grandchild is permitted to
 overlay the child.  Each of the processes prints a message identifying
 itself.
 
 ************************************************************************/
 
#include  &lt;stdio.h&gt;
#include  &lt;process.h&gt;
#define   PARENT        1
#define   CHILD         2
#define   GRANDCHILD    3
 
 int main(int argc, char **argv, char **envp)
 {
    int    result;
    char   *args[4];
 
    switch(argc)
    {
       case PARENT:
       /* no argument was passed:  spawn child and wait */
          result = _spawnle(P_WAIT, argv[0],
                                argv[0], "one", NULL, envp);
          if (result)
              abort();
          args[0] = argv[0];
          args[1] = "two";
          args[2] = NULL;
 
          /* spawn another child, and wait for it */
          result = _spawnve(P_WAIT, argv[0],
                       args, envp);
          if (result)
              abort();
          printf("Parent process ended. %d\n",result);
          _exit(0);
 
       case CHILD:
          /* one argument passed:  allow grandchild to overlay */
          printf("child process %s began\n", argv[1]);
          if (*argv[1] == 'o')            /* child one? */
          {
             _spawnl(P_OVERLAY, argv[0],
                         argv[0], "one", "two", NULL);
             abort();
             /* not executed because child was overlaid */
          }
          if (*argv[1] == 't')            /* child two? */
          {
              args[0] = argv[0];
              args[1] = "two";
              args[2] = "one";
              args[3] = NULL;
              _spawnv(P_OVERLAY, argv[0], args);
              abort();
              /* not executed because child was overlaid */
          }
          abort();       /* argument not valid */
 
      case GRANDCHILD:   /* two arguments passed */
         printf("grandchild %s ran\n", argv[1]);
         _exit(0);
    }
 
 /******  The output should be similar to:  *************
 
     child process one began
     grandchild one ran
     child process two began
     grandchild two ran
     Parent process ended
 */
 }
</PRE>
<HR><H1><A NAME="HDRREGEXP" HREF="#ToC_121">11.0 Regul&auml;re Ausdr&uuml;cke</A></H1>
<A NAME="IDX295"></A>
<A NAME="IDX296"></A>
<P>Regul&auml;re Ausdr&uuml;cke (Regular Expressions) sind Beschreibungen, 
die der Suche von Mustern in Zeichenketten dienen. Viele Programme im 
Unix Umfeld nutzen Regular Expressions, z.B. egrep. Dementsprechend 
bieten die Dokumentation zu diesen Programmen gute Informationen zu
Regular Expressions, Beispiel auch hier egrep. Regular Expressions
geh&ouml;ren nicht zum Sprachumfang von ANSI C und sind somit nicht 
mit jedem Compiler &uuml;bersetzbar. Jeder POSIX oder XPG4 kompatible
Compiler sollte aber &uuml;ber die entsprechenden Funktionen
verf&uuml;gen.
<HR><H2><A NAME="Header_122" HREF="#ToC_122">11.1 Spezielle Zeichen in Regular Expressions</A></H2>
<BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Zeichen
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Bedeutung
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Das n&auml;chste Zeichen seiner Sonderbedeutung berauben und als 
normales Zeichen betrachten.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;w
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Jedes alphanumerische Zeichen inkl. Unterstrich. Entspricht
&#91;A-Za-z0-9&#95;&#93;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;W
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Jedes nicht-alphanumerische Zeichen. 
Entspricht. &#91;&#94;A-Za-z0-9&#95;&#93;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;d
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Jede Zahl. Entspricht &#91;0-9&#93;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;D
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Jedes Zeichen, das keine Zahl ist. Entspricht &#91;&#94;0-9&#93;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#91;xyz&#93;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Jedes angegebene Zeichen. Ein Bereich kann durch Verwendung des
&#45; (z.B. &#91;A-Fa-f0-9&#93;) angegeben werden.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#91;&#94;xyz&#93;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Jedes nicht angegebene Zeichen. Ein Bereich kann durch Verwendung des
&#45; angegeben werden.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#94;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Kennzeichnet den Anfang der Eingabezeile.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#36;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Kennzeichnet das Ende der Eingabezeile.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#42;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">0 oder mehr des vorangegangenen Zeichens.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#43;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">1 oder mehr des vorangegangenen Zeichens. Entspricht &#123;1,&#125;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#63;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">0 oder 1 des vorangegangenen Zeichens.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#46;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Jedes einzelne Zeichen aus newline.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">x&#124;y
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Entweder 'x' oder 'y'.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#123;n&#125;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Exakt n mal das vorangegangene Zeichen.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#123;n,&#125;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Mind. n mal das vorangegangene Zeichen.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#123;n,m&#125;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Mind. n mal, aber maximal m mal das vorangegangene Zeichen.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#91;&#92;b&#93;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Backspace
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;B
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">nicht-Wort Grenze
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;c X
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">'x' ist ein Kontrollzeichen
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;f
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Form feed
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;n
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Line feed
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;r
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">carriage return
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;s
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">einzelnes "white space" Zeichen (Leerzeichen, Tabulator, Form feed,
Line Feed). Entspricht 
&#91;&#92;f&#92;n&#92;r&#92;t&#92;v&#93;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;S
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Einzelnes Zeichen, das kein "white space" Zeichen ist. Entspricht 
&#91;&#94;&#92;f&#92;n&#92;r&#92;t&#92;v&#93;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;t
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Tabulatorzeichen
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;v
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Vertikaler Tabulator
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#92;n
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">R&uuml;ckw&auml;rtsreferenz auf einen Substring.
</TD></TR></TABLE>
<HR><H2><A NAME="Header_123" HREF="#ToC_123">11.2 Beispiele f&uuml;r regul&auml;re Ausdr&uuml;cke</A></H2>
<BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Ausdruck
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Beschreibung
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">&lt;/?[a-zA-Z0-9]{1,9}&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Sucht HTML Befehle mit einer L&auml;nge von bis zu 9 Zeichen
innerhalb der eckigen Klammern (/ nicht eingerechnet).
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">&#92;(&#91;0-9&#93;&#123;3&#125;&#92;) &#92;d&#123;3&#125;&#45;&#92;d&#123;4&#125;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Findet US amerikanische Telefonnummern, z.B. (212)-555-1212
</TD></TR></TABLE>
<P>Mit Vorsicht zu geniessen sind Konstrukte wie <TT>test*</TT>,
bei dem DOS Benutzer davon ausgehen w&uuml;rden, da&szlig; alles, was mit
<TT>test</TT> beginnt, gefunden wird. Um dies zu erreichen mu&szlig;
man allerdings <TT>test.*</TT> benutzen.
<HR><H2><A NAME="Header_124" HREF="#ToC_124">11.3 Quellcodebeispiele f&uuml;r regul&auml;re Ausdr&uuml;cke</A></H2>
<PRE>
#include &lt;regex.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
int main(void)
{
   regex_t    preg;
   char       *string = "&lt;TR&gt;&lt;TD&gt;Gesellschaft:&lt;/TD&gt;&lt;TD&gt;IBM Informationssysteme Deutschland GmbH&lt;/TD&gt;&lt;/TR&gt;";
   char       *pattern = "&lt;/?[a-zA-Z0-9]{1,9}&gt;"; // scan HTML tag up to 9 chars long incl. end tags
 
   int        rc, offset=0;
   size_t     nmatch = 1;
   regmatch_t pmatch[1];
 
   if (0 != (rc = regcomp(&preg, pattern, REG_EXTENDED)))
   {
      printf("regcomp() failed, returning nonzero (%d)\n", rc);
      exit(EXIT_FAILURE);
   }
 
   if (0 != (rc = regexec(&preg, string, nmatch, pmatch, 0)))
   {
      printf("Failed to match '%s' with '%s',returning %d.\n",
      string, pattern, rc);
   }
   else
   {
     printf("-&gt; offset: %d -&gt; %s\n",offset,string+offset);
     do
     {
      printf("A matched substring \"%.*s\" is found at position %d to %d.\n",
             pmatch[0].rm_eo - pmatch[0].rm_so, &string[pmatch[0].rm_so+offset],
             pmatch[0].rm_so, pmatch[0].rm_eo - 1);
      offset+=pmatch[0].rm_eo;
      printf("\n-&gt; offset: %d -&gt; %s\n",offset,string+offset);
     }
     while(0 == (rc = regexec(&preg, string+offset, nmatch, pmatch, 0)));
   }
   regfree(&preg);
   return 0;
}
</PRE>
<HR><H1><A NAME="HDRPREPROC" HREF="#ToC_125">12.0 Preprocessor-Anweisungen (Direktiven)</A></H1>
<P>Der Preprocessor ist ein Programm, welches den Quellcode
vor der eigentlichen
&Uuml;bersetzung bearbeitet. Alle Preprocessor-Anweisungen
beginnen in Spalte eins mit dem Zeichen <TT>#</TT> und geh&ouml;ren nicht
zum eigentlichen Sprachumfang von C. Sie werden vor dem
Compilieren verarbeitet. Es stehen folgende
Anweisungen zur Verf&uuml;gung:
<PRE>
 
      #define
      #elif
      #else
      #endif
      #error
      #if
      #ifdef
      #ifndef
      #include
      #line
      #pragma
      #undef
</PRE>
<P>Diese Anweisungen werden in den folgenden Abschnitten anhand von
Beispielen vorgestellt.
<P>
<HR><H2><A NAME="Header_126" HREF="#ToC_126">12.1 Symbolische Konstanten - #define</A></H2>
<A NAME="IDX297"></A>
<P>Mit der Anweisung <TT>#define suchtext ersatztext</TT> besteht die
M&ouml;glichkeit, einer Konstanten einen Namen zuzuordnen. Der
Preprocessor ersetzt vor dem Compilieren alle Textstellen im
Programm, die mit <TT>suchtext</TT> &uuml;bereinstimmen,
durch die in <TT>ersatztext</TT> angegebene Zeichenfolge.
<P>
Beispiel:
<P>
<PRE>
   #include &lt;stdio.h&gt;
   #define PI 3.1425
 
   void main(void)
   {
      ... ;
      erg = (PI * radius) / 2;
      ...;
   }
</PRE>
<P>S&auml;mtliche Textstellen im Quelltext, die <TT>PI</TT> lauten, werden
durch <TT>3.1425</TT> ersetzt.
<P>
<HR><H2><A NAME="Header_127" HREF="#ToC_127">12.2 Makros - #define</A></H2>
<A NAME="IDX298"></A>
<P>Es gibt F&auml;lle, in denen eine abgeschlossene Teilaufgabe so kurz
ist, da&szlig; es sich nicht lohnt, eine vollst&auml;ndige Funktion daf&uuml;r zu
programmieren. In diesen F&auml;llen benutzt man ein Makro.
<P>Die Definition eines Makros hat die Form
<TT>#define name anweisungen</TT>.
<P>Beispiel:
<P>
<PRE>
   #include &lt;stdio.h&gt;
   #define max(A,B)   ((A) &gt; (B) ? (A) : (B))
 
   void main(void)
   {
      int zahl_1, zahl_2;
 
      printf("\n\nGeben Sie 2 ganze Zahlen durch ein Komma getrennt ein!\n");
      scanf("%d,%d", &zahl_1, &zahl_2);
      printf("Das Maximum dieser beiden Zahlen ist %d\n", max(zahl_1,zahl_2));
   }
</PRE>
<P>Die Definition von <TT>max(A,B)</TT> pr&uuml;ft, ob der Ausdruck
<TT>A</TT> gr&ouml;&szlig;er als der Ausdruck <TT>B</TT> ist. Ist dies der
Fall, wird der Ausdruck <TT>A</TT> zur&uuml;ckgegeben, ist dies nicht der
Fall, so wird der Ausdruck <TT>B</TT> zur&uuml;ckgegeben. An jeder Stelle im
Quelltext, an der von der Definition <TT>max(A,B)</TT> Gebrauch
gemacht wird, wird das Makro ausgef&uuml;hrt.
<P>
<HR><H2><A NAME="Header_128" HREF="#ToC_128">12.3 &Uuml;bersetzungsabbruch - #error</A></H2>
<A NAME="IDX299"></A>
<P>Durch diese Anweisung wird der &Uuml;bersetzungsablauf
unterbrochen. Diese Anweisung findet vor allem bei
bedingter Compilierung Anwendung.
<HR><H2><A NAME="Header_129" HREF="#ToC_129">12.4 Einf&uuml;gen von Dateien - #include</A></H2>
<A NAME="IDX300"></A>
<P>C bietet zum Einf&uuml;gen von Dateien in den Quelltext
die Preprocessor-Anweisung <TT>#include</TT>. Wird der
Dateiname der einzuf&uuml;genden Datei in Hochkommata eingeschlossen, so
sucht der Compiler zuerst in der benutzereigenen Bibliothek und dann in
der Standardbibliothek. Wird der Dateiname hingegen in spitze
Klammern (&lt;&gt;) eingebettet, so wird sofort und ausschlie&szlig;lich in der
Standardbibliothek gesucht.
<P>
<HR><H2><A NAME="Header_130" HREF="#ToC_130">12.5 #if</A></H2>
<A NAME="IDX301"></A>
<P>Syntax: <TT>#if konstanter_ausdruck anweisungen</TT>
<P>Trifft der Ausdruck zu, wird der, bis zum <TT>#endif</TT>
folgende Code compiliert.
<HR><H2><A NAME="Header_131" HREF="#ToC_131">12.6 #ifdef</A></H2>
<A NAME="IDX302"></A>
<P>Syntax: <TT>#ifdef ausdruck anweisungen</TT>
<P>Ist der Ausdruck als Makro vorher definiert worden, wird der
folgende Code compiliert.
<HR><H2><A NAME="Header_132" HREF="#ToC_132">12.7 #ifndef</A></H2>
<A NAME="IDX303"></A>
<P>Syntax: <TT>#ifndef ausdruck anweisungen</TT>
<P>Ist der Ausdruck nicht vorher als Makro definiert worden,
wird der folgende Code compiliert.
<HR><H2><A NAME="Header_133" HREF="#ToC_133">12.8 #else</A></H2>
<A NAME="IDX304"></A>
<P>Syntax: <TT>#else anweisungen</TT>
<P>Dient bei <TT>#if, #ifdef</TT> und <TT>#ifndef</TT>
als <TT>else</TT>-Anweisung.
<HR><H2><A NAME="Header_134" HREF="#ToC_134">12.9 #endif</A></H2>
<A NAME="IDX305"></A>
<P>Syntax: <TT>#endif</TT>
<P>Beendet <TT>#if, #ifdef</TT> oder <TT>#ifndef</TT>.
<HR><H2><A NAME="Header_135" HREF="#ToC_135">12.10 #undef</A></H2>
<A NAME="IDX306"></A>
<P>Syntax: <TT>#undef name_der_definition</TT>
<P>Vorherige Definition mit <TT>#define</TT> wird annulliert.
<HR><H2><A NAME="Header_136" HREF="#ToC_136">12.11 #elif</A></H2>
<A NAME="IDX307"></A>
<P>Syntax: <TT>#elif ausdruck anweisungen</TT>
<P>Wenn der Ausdruck von <TT>#if</TT> unwahr und der Ausdruck hinter
<TT>#elif</TT> wahr ist, dann wird der, bis zum n&auml;chsten
<TT>#elif</TT> oder <TT>#else</TT>
auftauchende Code compiliert.
<HR><H2><A NAME="Header_137" HREF="#ToC_137">12.12 #line</A></H2>
<A NAME="IDX308"></A>
<P>Syntax: <TT>#line nummer</TT>
<P><TT>line</TT> beeinflu&szlig;t die Zeilennummerierung des Quelltextes
durch den Compiler. Die der Anweisung folgende Zeile wird
mit der angegebenen Zeilennummer versehen. Im folgenden wird mit
dieser Zeilennummer weitergez&auml;hlt.
<HR><H2><A NAME="Header_138" HREF="#ToC_138">12.13 #pragma</A></H2>
<A NAME="IDX309"></A>
<P>Synatx: <TT>#pragma zeichen_sequenz</TT>
<P><TT>pragma</TT> erm&ouml;glicht eine Einbindung von Anweisungen, die
den Compiler in seinem &Uuml;bersetzungsvorgang beeinflussen. Diese
Anweisungen sind von Compiler zu Compiler unterschiedlich.
<HR><H1><A NAME="HDRTROUB" HREF="#ToC_139">13.0 Problembehebung</A></H1>
<A NAME="IDX310"></A>
<P>Die folgende Liste enth&auml;lt eine Auswahl popul&auml;rer
Fehler der C Programmierung bzw. hilfreiche Hinweise.
H&auml;ufig sind kaum Ans&auml;tze zu erkennen, warum ein Programm
sich nicht so verh&auml;lt, wie es sollte.
<UL>
<P><LI>Beim Eingeben einer Klammer (egal, ob geschweift, rund oder
eckig) immer als n&auml;chstes die dazugeh&ouml;rige schlie&szlig;ende Klammer
eingeben und erst danach die Anweisungen/Ausdr&uuml;cke zwischen
die Klammern setzen. Dadurch ist automatisch sichergestellt, da&szlig;
zu jeder ge&ouml;ffneten Klammer auch eine geschlossene geh&ouml;rt.
<P><LI>Hinter eine geschweifte Klammer einen Kommentar setzen, was
&uuml;berhaupt geschlossen wird. Dies erleichtert die Lesbarkeit
bei mehrfach geschachtelten Klammerpaaren.
<P><LI>Variablen immer bei der Deklaration oder am Anfang eines
Blocks (vor deren Verwendung) initialisieren.
<P><LI>Zeichenketten immer vor deren Verwendung per
Schleife oder memset() initialisieren.
<P><LI><TT>printf()</TT> entspricht einer gepufferten Ausgabe.
Falls die
Ausgabe nicht zu dem gew&uuml;nschten Zeitpunkt erfolgt,
mu&szlig; diese mit <TT>fflush(stdout);</TT> erzwungen werden.
<P><LI>Scheint ein Programm Eingabeaufforderungen (z.B.
<TT>scanf()</TT> oder <TT>getch()</TT>) zu &uuml;berspringen,
so schafft ein <TT>fflush(stdin);</TT> vor der jeweiligen
Anweisung oft f&uuml;r Abhilfe.
<P><LI>Bei <TT>scanf()</TT> sollte die Feldbreite begrenzt werden.
<P><LI>Bei <TT>scanf()</TT> sollte beachtet werden, da&szlig; Fehleingaben
zur Zuweisung eines Nullwertes f&uuml;hren k&ouml;nnen. Das bedeutet, da&szlig; die
Variable nach der Eingabe den Wert Null hat.
<P><LI>Bei <TT>scanf()</TT> in Verbindung mit einfachen Datentypen
an den Adre&szlig;operator (&) denken!
<P><LI>Einer Konstante des Typs <TT>long int</TT> folgt
unmittelbar das Zeichen L (z.B. <TT>25434L</TT>). Im
Formatstring von <TT>printf</TT>, <TT>scanf</TT> etc.
wird dieser Typ jedoch mit dem Zeichen l (z.B.
<TT>%li</TT>) gekennzeichnet.
<P><LI>Nach M&ouml;glichkeit immer Funktionsprototypen verwenden, um
re-declaration Probleme zu vermeiden.
<P><LI><TT>==</TT> bei Vergleichen verwenden (z.B. if a==1),
nicht <TT>=</TT>.
<P><LI><TT>=</TT> bei Zuweisungen verwenden (z.B. anzahl=0),
nicht <TT>==</TT>.
<P><LI>Tests auf Buchstaben immer mit dem Zeichen, nie mit dem Code
(z.B. <TT>if (zeichen&gt;='a' && zeichen&lt;='z')</TT>) durchf&uuml;hren.
<P><LI>Abh&auml;ngigkeiten bei Verwendung der Operatoren ++ und --
vermeiden. Vergleiche z.B.:
<TT>for(i=0;i&lt;20;printf("%d\n",block[i]=i++));</TT>
<BR>
und
<TT>for(i=0;i&lt;20;printf("%d\n",block[i++]=i));</TT>
<P><LI>Bricht ein Programm mit einer Exception
<A NAME="Footnote_Used_7" HREF="#Footnote_7" ><SUP>7</SUP></A>
ab, so ist dies h&auml;ufig ein Hinweis auf ung&uuml;ltige Zugriffsoperationen
bei Zeichenketten bzw. Zeigern
(z.B. Zugriff auf das zehnte Element
einer Zeichenkette, die mit <TT>char xyz[5]</TT>; deklariert wurde).
<UL>
<P><LI>Der Abbruchcode c005 (OS/2) wird durch eine ung&uuml;ltige Zeigeroperation
(s.o.) verursacht.
<P><LI>Der Abbruchcode c009a (OS/2) wird durch Benutzung eines undefinierten
bzw. ung&uuml;ltigen Wertes verursacht. Eine der h&auml;ufigsten
Ursachen ist der Versuch, mit nicht initialisierten float, double
oder long double Werten zu rechnen. Beispiel:
<PRE>
  float zahl;
  zahl=zahl+1;
</PRE>
<P><LI>Der Abbruchcode c009b (OS/2) wird durch Benutzung eines undefinierten
bzw. ung&uuml;ltigen Wertes verursacht. Eine der h&auml;ufigsten
Ursachen ist der Versuch, mit nicht initialisierten Integer Werten
zu rechnen. Eine weitere h&auml;ufige Fehlerquelle ist die Division durch Null.
Beispiel:
<PRE>
  int eingabe, ergebnis;
  scanf("%d", eingabe);   /* hier fehlt der adre&szlig;operator & */
  ergebnis = eingabe / 111;
</PRE>
</UL>
<P><LI>Strukturdefinitionen in getrennt compilierten Modulen m&uuml;ssen
exakt &uuml;bereinstimmen, da der Linker nicht mehr &uuml;berpr&uuml;fen kann,
ob es z.B. bei der L&auml;nge eines Strings Abweichungen gibt. Der Code
l&auml;&szlig;t sich zwar compilieren und linken, aber zur Laufzeit kann es
zu merkw&uuml;rdigem Verhalten kommen (z.B. Pointer, die zwar innerhalb
einer Funktion noch den korrekten Wert haben, au&szlig;erhalb der Funktion
aber den Wert NULL haben).
</UL>
<HR><H1><A NAME="HDROOP" HREF="#ToC_140">14.0 Unterschiede zwischen C und C++</A></H1>
<P>C<TT>++</TT> stellt eine Erweiterung der Sprache C um die
M&ouml;glichkeiten der objektorientierten Programmierung dar. Da es sich
um eine Erweiterung der Sprache handelt, sind fast alle C-Programme
auch mit einem C<TT>++</TT>-Compiler
compilierbar. Des weiteren ist das meiste,
was f&uuml;r C gilt auch f&uuml;r C<TT>++</TT>
g&uuml;ltig. In diesem Kapitel soll
ein &Uuml;berblick &uuml;ber &Auml;nderungen und Erweiterungen gegeben
werden. Dieses Kapitel dient nicht der Erlernung der
C<TT>++</TT>-Programmierung&#33;
<P>Wie bereits erw&auml;hnt, hebt man bei objektorientierten
Sprachen die Trennung zwischen Daten und Algorithmen weitestgehend
auf. Es wird nicht versucht, da&szlig; Problem an die Sprache
anzupassen, sondern die Sprache an das Problem. Das Ziel der
objektorientierten Programmierung ist die Erstellung von Programmen,
die leicht wartbar und erweiterbar sind und deren Code
wiederverwendbar ist.
<P>Abgesehen von den neuen Eigenschaften und F&auml;higkeiten von
C<TT>++</TT>
gibt es einige Unterschiede zwischen C und C<TT>++</TT>,
die beachtet werden
m&uuml;ssen, wenn C-Programmteile in C<TT>++</TT>-Programmen
verwendet werden sollen:
<OL TYPE=1>
<P><LI>Variablen k&ouml;nnen in C<TT>++</TT>
an jeder beliebigen Stelle und nicht
nur zu Beginn eines Blockes deklariert werden.
<P><LI>Variablennamen k&ouml;nnen in C<TT>++</TT> beliebig lang sein.
<P><LI>Zeichenkonstanten sind vom Typ <TT>char</TT> und nicht, wie in
C, vom Typ <TT>int</TT>.
<P><LI>Einige Funktionen (wie z.B. <TT>printf()</TT>) sollten durch
die C<TT>++</TT>&Auml;quivalente (z.B. <TT>cout()</TT>)
ersetzt werden, welche in der Regel m&auml;chtiger
sind. Nichtsdestotrotz gelten diese Funktionen nach wie vor.
<P><LI>Kommentare k&ouml;nnen durch zwei Schr&auml;gstriche (// Kommentar) eingeleitet
werden. Eine Endmarkierung ist nicht notwendig, da diese Kommentare
nur bis zum Zeilenende gehen.
<P><LI>Die Datei <TT>iostream.h</TT> stellt eine Ersatzm&ouml;glichkeit
f&uuml;r die Datei <TT>stdio.h</TT> dar. Sie enth&auml;lt z.B. die
Funktion <TT>cout()</TT>, die anstatt von <TT>printf()</TT>
benutzt werden kann.
</OL>
<P>C<TT>++</TT> enth&auml;lt einige neue Eigenschaften,
die die Sprache flexibler machen. Einige dieser Erweiterungen werden
in den folgenden Abschnitten vorgestellt.
<P>
<HR><H2><A NAME="Header_141" HREF="#ToC_141">14.1 Operator&uuml;berladung</A></H2>
<P>Operatoren k&ouml;nnen unter C<TT>++</TT>
neue Bedeutungen zugewiesen werden.
Welche der Bedeutungen jeweils g&uuml;ltig ist, wird aus dem
Zusammenhang deutlich. So erh&auml;lt z.B. der links-shift-Operator (&lt;&lt;)
in der Funktion <TT>cout()</TT> die Eigenschaft, Daten auf die
Ausgabeeinheit zu leiten. Beispiel:
<BR>
<TT>cout &lt;&lt; "&#92;nHeutiger Tag&#58;" &lt;&lt; tag;</TT>
<P>
<HR><H2><A NAME="Header_142" HREF="#ToC_142">14.2 Funktions&uuml;berladung</A></H2>
<P>In einem Programm d&uuml;rfen mehrere Funktionen mit dem gleichen
Namen vorkommen. Diese Eigenschaft wird auch als
<I>Polymorphismus</I> bezeichnet. Der Compiler untersucht beim
jeweiligen Funktionsaufruf nicht nur den Namen sondern auch die
Argumentenliste und den Zugeh&ouml;rigkeitsbereich (klassenbezogen)
und entscheidet dann, welche Funktion aufgerufen wird.
<P>
<HR><H2><A NAME="Header_143" HREF="#ToC_143">14.3 Klassen</A></H2>
<P>Klassen sind zentrale Elemente der objektorientierten
Programmierung. Sie stellen eine Art Struktur dar, beinhalten jedoch
im Gegensatz zu <TT>struct</TT> nicht nur die Datenelemente der
Struktur, sondern zus&auml;tzlich die Funktionen, die auf diese
Datenelemente zugreifen. Des weiteren ist es m&ouml;glich, die Daten und
die Funktionen, die auf die Daten zugreifen, vor dem Rest des
Programms zu verbergen. Hierbei handelt es sich um
<TT>private</TT>-Daten und - Funktionen. Es kann f&uuml;r s&auml;mtliche
Elemente der Klasse festgelegt werden, ob sie <TT>private</TT> oder
<TT>public</TT> sein sollen, wobei alle Komponenten
standardm&auml;&szlig;ig <TT>private</TT> sind.
<P>Die Definition einer Klasse beinhaltet somit folgende Elemente:
<OL TYPE=1>
<P><LI>das Schl&uuml;sselwort <TT>class</TT>,
<P><LI>den Namen der Klasse,
<P><LI>die Datenelemente der Klasse,
<P><LI>die Funktionen der Klasse und
<P><LI>Informationen dar&uuml;ber, welche Elemente und Methoden <TT>public</TT>
oder <TT>private</TT> sind. (Gekennzeichnet durch die entsprechenden
Schl&uuml;sselw&ouml;rter)
</OL>
<P>Die Funktionen werden in der Regel als Prototypen in die Klasse
eingebunden und au&szlig;erhalb der Klasse definiert. Die komplette
Funktionsdefinition l&auml;&szlig;t sich zwar in eine Klassendefinition
einbetten, dies wird jedoch nur bei sehr kurzen Funktionen realisiert.
<P>Werden Klassenfunktionen au&szlig;erhalb einer Klasse definiert, so
wird durch den Namen der Klasse und zwei Doppelpunkte vor dem
Funktionsnamen signalisiert, da&szlig; diese Funktionen zu einer
bestimmten Klasse geh&ouml;ren. (Beispiel siehe unten)
<P>Diese Klassenfunktionen werden auch als <I>Methoden</I>
bezeichnet.
<P>Beispiel f&uuml;r die Definition einer Klasse:
<P>
<PRE>
// Definition einer Klasse
 
class personen
{
   private:
      int nummer;
      char nachname[40];
      char vorname[40];
      float postleitzahl;
      char wohnort[40];
      void gehalt&#95;ermitteln();
   public:
      void erfassen();
      void anzeigen();
};
 
void personen:&#58;erfassen()
{
   ...Code...
}
</PRE>
<P><TT>private</TT> und <TT>public</TT> k&ouml;nnen in einer
Klassendefinition beliebig oft erscheinen; die obige Aufteilung hat
sich jedoch durchgesetzt. Des weiteren werden die Daten einer Klasse
in der Regel <TT>private</TT> deklariert und die Methoden
<TT>public</TT>. Im obigen Beispiel ist die Methode
<TT>gehalt&#95;ermitteln</TT> auch <TT>private</TT> definiert, da
sie nach au&szlig;enhin nicht sichtbar sein soll.
<P>
<HR><H2><A NAME="Header_144" HREF="#ToC_144">14.4 Konstruktor und Destruktor</A></H2>
<P>Um Objekte einer Klasse bei ihrer Erzeugung zu initialisieren,
wird ein
Konstruktor benutzt. Er hat den gleichen Namen wie die Klasse
und kann bei der Definition der Klasse angegeben werden.
<P>Sobald ein Objekt aus dem Speicher entfernt wird,
wird der Destruktor aufgerufen. Sein Name entspricht
dem Namen der Klasse mit einer vorangehenden Tilde (&#126;).
<P>
<HR><H1><A NAME="Header_145" HREF="#ToC_145">Anh&auml;nge</A></H1>
<P><A NAME="PToC1" HREF="#ToC">Partial Table-of-Contents</A>
<MENU>
<P><B><LI><A NAME="PToC_146" HREF="#Header_146">Anhang A. Schl&uuml;sselworte</A></B>
<P><B><LI><A NAME="PToC_147" HREF="#Header_147">Anhang B. &Uuml;bersicht &uuml;ber die Datentypen</A></B>
<P><B><LI><A NAME="PToC_148" HREF="#Header_148">Anhang C. Operatoren</A></B>
<P><B><LI><A NAME="PToC_155" HREF="#Header_155">Anhang D. Formatstring</A></B>
<P><B><LI><A NAME="PToC_156" HREF="#Header_156">Anhang E. Fluchtsymbolzeichen</A></B>
<P><B><LI><A NAME="PToC_157" HREF="#Header_157">Anhang F. Funktionen zur Ein-/Ausgabe von Zeichen(-ketten)</A></B>
<P><B><LI><A NAME="PToC_158" HREF="#Header_158">Anhang G. Funktionen der Standardbibliotheken</A></B>
<P><B><LI><A NAME="PToC_159" HREF="#Header_159">Anhang H. &Uuml;bersicht &uuml;ber die Include-/Header-Dateien</A></B>
<P><B><LI><A NAME="PToC_160" HREF="#Header_160">Anhang I. Bedienung der Compiler Tools</A></B>
<P><B><LI><A NAME="PToC_163" HREF="#Header_163">Anhang J. Rechnung mit Bits und Bytes</A></B>
<P><B><LI><A NAME="PToC_164" HREF="#Header_164">Anhang K. Zeichens&auml;tze</A></B>
<P><B><LI><A NAME="PToC_169" HREF="#Header_169">Anhang L. Literaturverzeichnis</A></B>
<P><B><LI><A NAME="PToC_170" HREF="#Header_170">Anhang M. Online Ressourcen</A></B>
<P><B><LI><A NAME="PToC_173" HREF="#HDRINDEX_START">Index</A></B>
</MENU><P>
<HR><H1><A NAME="Header_146" HREF="#PToC_146">Anhang A. Schl&uuml;sselworte</A></H1>
<A NAME="IDX311"></A>
<BR>
<P><B><A NAME="Table_10" HREF="#FT_Table_10">Tabelle 10. Schl&uuml;sselworte</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">auto
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung der Speicherklasse <TT>auto</TT>
(siehe <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">break
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beendet die aktuelle Schleife und f&auml;hrt mit der Programmausf&uuml;hrung
bei der n&auml;chsten Anweisung nach der Schleife fort. Beendet auch
Anweisungszweige von <TT>switch</TT> Anweisungen.
(siehe <A HREF="#HDRBRE">6.4, "Die Anweisungen break und continue"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">case
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Anweisungszweig einer <TT>switch</TT> Anweisung.
(siehe <A HREF="#HDRCASE">7.2, "switch"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">char
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Datentyp f&uuml;r Zeichen und Zeichenketten.
(siehe <A HREF="#HDRCHAR">3.1.3, "Textzeichen - char"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">const
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer Konstanten.
(siehe <A HREF="#HDRBEZEI">2.7, "Bezeichner"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">continue
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Bricht den aktuellen Schleifendurchlauf ab und springt zum Ende
der Schleife.
(siehe <A HREF="#HDRBRE">6.4, "Die Anweisungen break und continue"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">default
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Anweisungszweig einer <TT>switch</TT> Anweisung, der ausgef&uuml;hrt wird,
wenn kein <TT>case</TT> Zweig zutrifft bzw. vorher kein <TT>break</TT>
auftrat.
(siehe <A HREF="#HDRCASE">7.2, "switch"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">do
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beginnt eine <TT>do while</TT> Schleife, die Pr&uuml;fung erfolgt am
Ende eines Schleifendurchlaufs.
(siehe <A HREF="#HDRREPEAT">6.0, "Wiederholungen - Schleifen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">double
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer rationellen Zahl.
(siehe <A HREF="#HDRRAT">3.1.2, "Rationale Zahlen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">else
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Alternativzweig einer <TT>if</TT> Anweisung.
(siehe <A HREF="#HDRCHOICE">7.0, "Auswahl"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">enum
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung eines Aufz&auml;hlungstyps.
(siehe <A HREF="#HDRENUM">3.3.2, "enum"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">extern
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung externer Bezeichner.
(siehe <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">float
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer rationellen Zahl.
(siehe <A HREF="#HDRRAT">3.1.2, "Rationale Zahlen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">for
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Schleife mit Pr&uuml;fung am Anfang eines Schleifendurchlaufs und
integriertem Z&auml;hler.
(siehe <A HREF="#HDRREPEAT">6.0, "Wiederholungen - Schleifen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">goto
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Unbedingter Sprung. (wird in diesem Handbuch nicht behandelt)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">if
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Abfrage einer Bedingung.
(siehe <A HREF="#HDRCHOICE">7.0, "Auswahl"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">int
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">long
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">register
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer Speicherklasse wie <TT>auto</TT>, jedoch
Register statt Speicher, falls m&ouml;glich.
(siehe <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">return
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beendet Funktionen und &uuml;bergibt ggf. einen R&uuml;ckgabewert.
(siehe <A HREF="#HDROWN">5.0, "Eigene Funktionen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">short
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">signed
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl oder eines Zeichens mit Vorzeichen.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A> bzw. <A HREF="#HDRCHAR">3.1.3, "Textzeichen - char"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">sizeof
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Ermittlung der L&auml;nge eines Operanden.
(siehe <A HREF="#HDRHIERAR">2.6.6, "Hierarchie der Operatoren"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">static
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer Speicherklasse. Der Speicherbereich wird bei
Programmbeginn zugeordnet.
(siehe <A HREF="#HDRCLASSES">3.6, "Speicherklassen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">struct
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer Struktur.
(siehe <A HREF="#HDRSTRUKT">3.2.2, "Strukturen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">switch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beginn einer Auswahl.
(siehe <A HREF="#HDRCASE">7.2, "switch"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">typedef
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Definition eigener Datentypen.
(siehe <A HREF="#HDROWNTYPE">3.5, "Eigene Typen - typedef"</A> und <A HREF="#HDRSTRDEF">3.2.2.3, "Strukturen mit Typendefinitionen - typedef"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">union
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung verschiedener Datentypen im selben Speicherbereich.
(siehe <A HREF="#HDRUNION">3.2.3, "Unions"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">unsigned
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung einer ganzen Zahl oder eines Zeichens ohne Vorzeichen.
(siehe <A HREF="#HDRINT">3.1.1, "Ganze Zahlen - Integer"</A> bzw. <A HREF="#HDRCHAR">3.1.3, "Textzeichen - char"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">void
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung ohne Typ. (Nichts)
(siehe <A HREF="#HDROWN">5.0, "Eigene Funktionen"</A>)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">volatile
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Vereinbarung eines unbest&auml;ndigen Datentyps.
Dieses Schl&uuml;sselwort teilt dem Compiler mit, da&szlig; die bezeichnete
Variable durch Ereignisse au&szlig;erhalb der Kontrolle des Programms
ver&auml;ndert werden kann. Der Wert der Variablen mu&szlig; deshlab vor
jedem Zugriff neu aus dem Hauptspeicher gelesen werden, d.h. er
darf nicht in einem Prozessorregister gespeichert werden.
(Wird in diesem Handbuch nicht weiter behandelt.)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">while
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Beginn einer <TT>while</TT> oder Ende einer <TT>do while</TT> Schleife.
(siehe <A HREF="#HDRCHOICE">7.0, "Auswahl"</A>)
</TD></TR></TABLE>
<HR><H1><A NAME="Header_147" HREF="#PToC_147">Anhang B. &Uuml;bersicht &uuml;ber die Datentypen</A></H1>
<A NAME="IDX313"></A>
<BR>
<P><B><A NAME="Table_11" HREF="#FT_Table_11">Tabelle 11. Wertebereiche der Datentypen unter OS/2</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">Typ
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">Gr&ouml;&szlig;e
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">Wertebereich von
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">Wertebereich bis
</TD></TR><TR>
<TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">char
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">1 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">-128
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+127
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">unsigned char
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">1 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+255
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">signed char
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">1 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">-128
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+127
</TD></TR><TR>
<TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">4 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">-2.147.483.648
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+2.147.483.649
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">unsigned int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">4 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+4.294.967.296
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">signed int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">4 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">-2.147.483.648
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+2.147.483.649
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">short int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">2 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">-32.768
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+32.767
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">unsigned short int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">2 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+65.535
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">signed short int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">2 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">-32.768
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+32.767
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">long int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">4 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">-2.147.483.648
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+2.147.483.649
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">unsigned long int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">4 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+4.294.967.296
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">signed long int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">4 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">-2.147.483.648
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">+2.147.483.649
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">long long int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">8 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0x8000000000000000
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0x7fffffffffffffff
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">unsigned long long int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">8 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0xffffffffffffffff
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">signed long long int
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">8 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0x8000000000000000
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">0x7fffffffffffffff
</TD></TR><TR>
<TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">float
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">4 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">3.4*10<SUP>-38</SUP>
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">3.4*10<SUP>+38</SUP>
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">double
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">8 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">1.7*10<SUP>-308</SUP>
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">1.7*10<SUP>+308</SUP>
</TD></TR><TR>
<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">long double
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="14%">16 Byte
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">3.4*10<SUP>-4932</SUP>
</TD><TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="29%">1.1*10<SUP>+4932</SUP>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Note&#58; </B>Der Datentyp long long ist im ANSI C Standard nicht enthalten
und deshalb nicht portabel. Er wird allerdings von vielen modernen
Compilern unterst&uuml;tzt (z.B. IBM C and C<TT>++</TT>
Compilers for OS/2, AIX, and for Windows NT 3.6).
</TD></TR></TABLE>
<HR><H1><A NAME="Header_148" HREF="#PToC_148">Anhang C. Operatoren</A></H1>
<A NAME="IDX314"></A>
<P>
<HR><H2><A NAME="Header_149" HREF="#ToC_149">C.1 Arithmetische Operatoren</A></H2>
<P>
<BR>
<P><B><A NAME="Table_12" HREF="#FT_Table_12">Tabelle 12. Arithmetische Operatoren</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Zweck
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Operator
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Addition
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">+
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Subtraktion
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">-
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Multiplikation
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">*
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Division
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">/
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Restwert
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">%
</TD></TR></TABLE>
<P>
<HR><H2><A NAME="Header_150" HREF="#ToC_150">C.2 Zusammengesetzte Zuweisungsoperatoren</A></H2>
<P>
<BR>
<P><B><A NAME="Table_13" HREF="#FT_Table_13">Tabelle 13. Zusammengesetzte Zuweisungsoperatoren</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Operator
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Beispiel
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&Auml;quivalenter Ausdruck
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">+=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index += 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index + 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">-=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index -= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index - 1
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">*=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index *= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index * 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">/=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index /= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index / 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">%=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index %= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">index = index % 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&lt;&lt;=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">result &lt;&lt;= num
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">result = rsult &lt;&lt; num
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&gt;&gt;=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">form &gt;&gt;= 1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">form = form &gt;&gt; 1
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">mask &= 2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">mask = mask & 2
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">&#94;=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">test &#94;= pre_text
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">test = test &#94;pre_test
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">|=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">flag |= on
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">flag = flag | on
</TD></TR></TABLE>
<P>
<HR><H2><A NAME="Header_151" HREF="#ToC_151">C.3 Un&auml;re Operatoren</A></H2>
<P>
<BR>
<P><B><A NAME="Table_14" HREF="#FT_Table_14">Tabelle 14. Un&auml;re oder monadische Operatoren</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Operator
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Bedeutung
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">++
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Wert inkrementieren
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">--
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Wert dekrementieren
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">!
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">logisches Nicht
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">&#126;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">bitweises Komplement
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">& 
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Adre&szlig;operator
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Verweisoperator (Inhalt von)
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">(typ)
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Typumwandler (type cast)
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">sizeof
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Gr&ouml;&szlig;enermittler
</TD></TR></TABLE>
<HR><H2><A NAME="Header_152" HREF="#ToC_152">C.4 Vergleichende Operatoren</A></H2>
<BR>
<P><B><A NAME="Table_15" HREF="#FT_Table_15">Tabelle 15. Vergleichende Operatoren</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Ausdruck
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Bedeutung
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Ausdruck == Ausdruck
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">gleich
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Ausdruck != Ausdruck
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">ungleich
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Ausdruck &lt; Ausdruck
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">kleiner als
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Ausdruck &lt;= Ausdruck
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">kleiner oder gleich
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Ausdruck &gt; Ausdruck
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">gr&ouml;&szlig;er
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Ausdruck &gt;= Ausdruck
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">gr&ouml;&szlig;er oder gleich
</TD></TR></TABLE>
<HR><H2><A NAME="Header_153" HREF="#ToC_153">C.5 Logische Operatoren</A></H2>
<BR>
<P><B><A NAME="Table_16" HREF="#FT_Table_16">Tabelle 16. Logische Zuweisungsoperatoren</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Operator
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">Bedeutung
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">!
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">logisches NICHT
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">&amp;&amp;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">logisches UND
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">||
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="50%">logisches ODER
</TD></TR></TABLE>
<P>
<HR><H2><A NAME="Header_154" HREF="#ToC_154">C.6 Hierarchie der Operatoren</A></H2>
<BR>
<P><B><A NAME="Table_17" HREF="#FT_Table_17">Tabelle 17. Tabelle der Hierarchie der Operatoren</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Operatoren
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Verwendung
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Auswertungsrichtung
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">( )
<BR>
[]
<BR>
-&gt;
<BR>
&#46;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">bildet einen Ausdruck
<BR>
bezeichnet ein Feldelement
<BR>
w&auml;hlt eine Strukturkomponente aus
<BR>
w&auml;hlt eine Strukturkomponente per Zeiger aus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">++
<BR>
--
<BR>
-
<BR>
+
<BR>
!
<BR>
&#126;
<BR>
&amp;
<BR>
*
<BR>
sizeof
<BR>
(typ)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Inkrementieren
<BR>
Dekrementieren
<BR>
bildet negativen Wert
<BR>
?
<BR>
logische Negierung
<BR>
bitweises Negieren
<BR>
liefert Adresse einer Variablen/Konstanten
<BR>
greift &uuml;ber Zeiger auf Variable/Konstante zu
<BR>
liefer Gr&ouml;&szlig;e eines Speicherbereiches
<BR>
wandelt in angegebenen Typ um (type cast)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">rechts nach links
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">*
<BR>
/
<BR>
%
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Multiplizieren
<BR>
Dividieren
<BR>
Restwert bilden
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">+
<BR>
-
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Addieren
<BR>
Subtrahieren
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&lt;&lt;
<BR>
&gt;&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">verschiebt Bits nach links
<BR>
verschiebt Bits nach rechts
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&lt;
<BR>
&lt;=
<BR>
&gt;
<BR>
&gt;=
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Vergleich auf kleiner
<BR>
Vergleich auf kleiner gleich
<BR>
Vergleich auf gr&ouml;&szlig;er
<BR>
Vergleich auf gr&ouml;&szlig;er gleich
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">==
<BR>
!=
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Vergleich auf gleich
<BR>
Vergleich auf nicht gleich
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&amp;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Bitweises UND
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#94;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Bitweises XOR
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&#124;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Bitweises ODER
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&& 
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Logisches UND
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">||
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Logisches ODER
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">? :
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Bedingung
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">rechts nach links
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">=
<BR>
+=
<BR>
-=
<BR>
*=
<BR>
/=
<BR>
%=
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">einfache Zuweisung
<BR>
Addieren und Zuweisen
<BR>
Subtrahieren und Zuweisen
<BR>
Multiplizieren und Zuweisen
<BR>
Dividieren und Zuweisen
<BR>
Restwert bilden und Zuweisen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">rechts nach links
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">,
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="60%">Operanden trennen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">links nach rechts
</TD></TR></TABLE>
<P>
<HR><H1><A NAME="Header_155" HREF="#PToC_155">Anhang D. Formatstring</A></H1>
<A NAME="IDX317"></A>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">scanf() - Formatspezifikation</TH><TR><TD>
<PRE>
                                             
>>--%--+-----+--+----------+--+---+--type--><
       |     |  |          |  |-h-|          
       +--*--+  +--Breite--+  |   |          
                              |-l-|          
                              |   |          
                              +-L-+          
</PRE>
</TD></TR></TABLE>
<TABLE BORDER WIDTH="100%"><TR><TH ALIGN="LEFT">printf() - Formatspezifikation</TH><TR><TD>
<PRE>
                                                                     
>>--%--+---------+--+----------+--+----------------+--+---+--type--><
       |         |  |          |  |                |  |-h-|          
       +--flags--+  +--Breite--+  +--.Genauigkeit--+  |   |          
                                                      |-L-|          
                                                      |   |          
                                                      +-l-+          
</PRE>
</TD></TR></TABLE>
<P>Die Formatspezifikationen beginnen mit einem Prozentzeichen (%) und
enden mit dem Umwandlungszeichen (<I>type</I>; z.B. d, s, c, f oder
e). Dazwischen k&ouml;nnen folgende Zeichen angef&uuml;hrt werden:
<OL TYPE=1>
<P><LI>Folgende Steuerzeichen (<I>flags</I>) in beliebiger Reihenfolge
<OL TYPE=a>
<P><LI>'-': linksb&uuml;ndige Ausgabe des Datenelements
<P><LI>'+': Zahlen werden immer mit Vorzeichen ausgegeben
<P><LI>'0': leere Stellen im Ausgabefeld mit f&uuml;hrenden/angeh&auml;ngten Nullen
f&uuml;llen
</OL>
<P><LI>eine Zahl, die die minimale Feldbreite festlegt (bei Bedarf
wird die Feldbreite vergr&ouml;&szlig;ert)
<P><LI>einen Punkt, der die Feldbreite von der Genauigkeit trennt und
eine Zahl f&uuml;r die Genauigkeit mit folgender Bedeutung:
<OL TYPE=a>
<P><LI>maximale Anzahl von Zeichen f&uuml;r eine Zeichenkette
<P><LI>Anzahl der Nachkommastellen f&uuml;r Flie&szlig;kommazahlen
(z.B. <TT>%.0lf</TT>)
<P><LI>die minimale Anzahl von Ziffern f&uuml;r Ganzzahlenwerte
</OL>
<P><LI>die Gr&ouml;&szlig;e des Argumentes
<UL>
<P><LI>h - Pr&auml;fix f&uuml;r die Integertypen (d, i, n, o, u, x und X),
der festlegt, da&szlig; das Argument <TT>short int</TT> oder
<TT>unsigned short int</TT> ist.
<P><LI>l - Pr&auml;fix f&uuml;r die Typen d, i, n, o, u, x und X, der festlegt,
da&szlig; das Argument <TT>long int</TT> oder
<TT>unsigned long int</TT>ist.
<P><LI>L - Pr&auml;fix f&uuml;r die Typen e, f und g, der festlegt, da&szlig; das
Argument <TT>long double</TT> ist.
</UL>
<P><LI>Der <I>type</I> kann aus folgenden Zeichen bestehen:
<DL>
<P><DT>c
<DD>f&uuml;r char
<P><DT>d
<DD>f&uuml;r signed int (dezimal)
<P><DT>e
<DD>f&uuml;r float-Variablen, allerdings wird der Wert in
Exponentenschreibweise ausgegeben.
<P><DT>E
<DD>wie e, aber E f&uuml;r den Exponent statt e
<P><DT>f
<DD>f&uuml;r float-Variablen, Ausgabe in Festkommaschreibweise
<P><DT>g
<DD>f&uuml;r float-Variablen. Der Compiler entscheidet abh&auml;ngig
von der L&auml;nge, ob Exponential- oder Festkommadarstellung gew&auml;hlt wird.
<P><DT>G
<DD>wie g, aber E f&uuml;r den Exponent statt e
<P><DT>i
<DD>f&uuml;r signed int (dezimal)
<P><DT>n
<DD>Nummer der Zeichen, die bis jetzt erfolgreich auf die Ausgabe
geschrieben wurde.
<P><DT>o
<DD>f&uuml;r signed int (oktal)
<P><DT>p
<DD>f&uuml;r Zeigervariablen
<P><DT>s
<DD>f&uuml;r Zeichenketten (char-Felder)
<P><DT>u
<DD>f&uuml;r unsigned int (dezimal)
<P><DT>x
<DD>f&uuml;r unsigned int (hexadezimal, a-f)
<P><DT>X
<DD>f&uuml;r unsigned int (hexadezimal, A-F)
</DL>
</OL>
<HR><H1><A NAME="Header_156" HREF="#PToC_156">Anhang E. Fluchtsymbolzeichen</A></H1>
<A NAME="IDX318"></A>
<DL>
<P><DT>- \\
<DD>gibt den Backslash aus
<P><DT>- \'
<DD>gibt das einfache Hochkomma (') aus
<P><DT>- \"
<DD>gibt die Anf&uuml;hrungszeichen bzw. das doppelte Hochkomma (") aus
<P><DT>- \0
<DD>Die bin&auml;re Null schlie&szlig;t eine Zeichenkette ab, wird von Funktionen
zur Zeichenkettenbearbeitung automatisch generiert.
<P><DT>- \a
<DD><I>alarm</I>; gibt einen Warnton aus.
<P><DT>- \b
<DD><I>backspace</I>; bewegt den Cursor um eine Stelle nach links.
<P><DT>- \f
<DD><I>formfeed</I>; veranla&szlig;t einen Seitenvorschub, d.h. da&szlig; der
nachfolgende Text auf einer neuen Seite ausgegeben wird.
<P><DT>- \n
<DD>markiert einen Zeilenvorschub (<I>new line</I>). Die
nachfolgende Ein- oder Ausgabe wird in einer neuen Zeile begonnen.
<P><DT>- \r
<DD><I>carriage return</I>/Wagenr&uuml;cklauf; bewegt den Cursor in
derselben Zeile an den Zeilenanfang.
<P><DT>- \t
<DD>setzt ein Tabulatorzeichen. Der folgende Text wird um einen
definierten Wert, der in der Entwicklungsumgebung eingestellt
wird, nach rechts verschoben.
</DL>
<P><I>Anmerkung: Um die Zeichen  <TT>\</TT> und <TT>%</TT>
darzustellen, werden sie doppelt eingegeben.
<BR>
Bsp: <TT>printf("Wechsel in das directory \"C:\\OS2\\APPS\"
verl&auml;uft ...");</TT> ergibt folgende Ausgabe: <TT>Wechsel
in das directory "C:\OS2\APPS"</TT></I> verl&auml;uft...
<HR><H1><A NAME="Header_157" HREF="#PToC_157">Anhang F. Funktionen zur Ein-/Ausgabe von Zeichen(-ketten)</A></H1>
<P>fgetc
<A NAME="IDX319"></A>
<PRE>
 Syntax:     int fgetc(FILE *stream);
 Bibliothek: stdio.h
 Beispiel:   zeichen = fgetc(filein);
</PRE>
<P>Von der mit stream verbundenen Datei wird ein Zeichen gelesen
und zur&uuml;ckgegeben. Ist das Dateiende erreicht, wird ein negativer Wert
zur&uuml;ckgeliefert.
<P>
<P>
<P>fgets
<A NAME="IDX320"></A>
<PRE>
 Syntax:     char *fgets(char *buffer, int n, FILE *stream);
 Bibliothek: stdio.h
 Beispiel:   fgets(line, 256, filein);
</PRE>
<P>Bis zum Erreichen von EOL werden alle Zeichen (inkl. \n), h&ouml;chstens
jedoch n-1 zeichen, aus der mit stream verbundenen Datei in den Puffer
<TT>buffer</TT> eingelesen.
Sind keine Fehler aufgetreten, liefert die Funktion
einen Zeiger auf den Puffer zur&uuml;ck. Sind Fehler aufgetreten, liefert sie
einen NULL-Zeiger zur&uuml;ck.
<P>
<P>
<P>fprintf
<A NAME="IDX321"></A>
<PRE>
 Syntax:     int fprintf(FILE *stream, char *format,...);
 Bibliothek: stdio.h
 Beispiel:   fprintf(fileout, "%04d. Zeile: %s\n", linenr, line);
</PRE>
<P>Gleiche Funktionsweise wie printf(), mit dem Unterschied, da&szlig; die
Ausgabe auf die mit stream verbundene Datei erfolgt.
<P>
<P>
<P>fputc
<A NAME="IDX322"></A>
<PRE>
 Syntax:     int fputc(int c, FILE *stream);
 Bibliothek: stdio.h
 Beispiel:   fputc('x', fileout);
</PRE>
<P>Das Zeichen c wird auf die mit stream verbundene Datei geschrieben.
Treten keine Fehler auf, wird das Zeichen c zur&uuml;ckgeliefert,
ansonsten EOF.
<P>
<P>
<P>fputs
<A NAME="IDX323"></A>
<PRE>
 Syntax:     int fputs(char *string, FILE *stream);
 Bibliothek: stdio.h
 Beispiel:   fputs(line, fileout);
</PRE>
<P>Die Zeichenkette string wird (ohne das abschlie&szlig;ende \0) in die mit
stream verbundene Datei geschrieben. Treten Fehler auf, wird ein Wert
ungleich 0 zur&uuml;ckgeliefert, ansonsten der Wert 0.
<P>
<P>
<P>getc
<A NAME="IDX324"></A>
<PRE>
 Syntax:     int getc(FILE *stream);
 Bibliothek: stdio.h
 Beispiel:   zeichen = getc(filein);
</PRE>
<P>Aus der mit stream verbundenen Datei wird das n&auml;chste Zeichen
gelesen und zur&uuml;ckgegeben. Traten Fehler auf, wird EOF zur&uuml;ckgegeben.
<P>
<P>
<P>getch
<A NAME="IDX325"></A>
<PRE>
 Syntax:     int getch(void);
 Bibliothek: conio.h
 Beispiel:   zeichen = getch();
</PRE>
<P>Liest ein Zeichen von der Tastatur ein und gibt es zur&uuml;ck. Das
Programm wird fortgef&uuml;hrt, nachdem eine Taste gedr&uuml;ckt wurde.
Das eingegebene Zeichen erscheint nicht auf dem Bildschirm.
<P>
<P>
<P>getchar
<A NAME="IDX326"></A>
<PRE>
 Syntax:     int getchar(void);
 Bibliothek: stdio.h
 Beispiel:   zeichen = getchar();
</PRE>
<P>Von stdin (i.d.R. die Tastatur) wird das n&auml;chste Zeichen gelesen und
zur&uuml;ckgegeben. Treten Fehler auf, wird EOF zur&uuml;ckgeliefert. Die
Tastenkombination CTRL-Z (oder STRG-Z) wird als EOF interpretiert.
<P>
<P>
<P>getche
<A NAME="IDX327"></A>
<PRE>
 Syntax:     int getche(void);
 Bibliothek: conio.h
 Beispiel:   zeichen = getche();
</PRE>
<P>Liest ein Zeichen von der Tastatur, zeigt es auf dem Bildschirm
an und gibt es zur&uuml;ck. Das Programm wird fortgef&uuml;hrt, nachdem eine
Taste gedr&uuml;ckt wurde.
<P>
<P>
<P>gets
<A NAME="IDX328"></A>
<PRE>
 Syntax:     char *gets(char *buffer);
 Bibliothek: stdio.h
 Beispiel:   gets(line);
</PRE>
<P>Von stdin (i.d.R. Tastatur) werden solange Zeichen gelesen,
bis \n (Return)
oder EOF eingegeben wird. Die Zeichen werden in <TT>buffer</TT>
gespeichert.
Treten Fehler auf, wird ein NULL-Zeiger zur&uuml;ckgegeben, ansonsten ein
Zeiger auf <TT>buffer</TT>.
<P>
<P>
<P>printf
<A NAME="IDX329"></A>
<PRE>
 Syntax:     int printf(char *format,...);
 Bibliothek: stdio.h
 Beispiel:   printf("%04d. Zeile: %s\n",linenr,line);
</PRE>
<P>Dient der formatierten Ausgabe von Daten auf stdout
(i.d.R. der Bildschirm).
Treten Fehler auf, wird -1 zur&uuml;ckgegeben, ansonsten die Anzahl Zeichen,
die auf die Ausgabe geschrieben wurden.
<P>
<P>
<P>putc
<A NAME="IDX330"></A>
<PRE>
 Syntax:     int putc(int c, FILE *stream);
 Bibliothek: stdio.h
 Beispiel:   putc(zeichen, fileout);
</PRE>
<P>Das Zeichen c wird in die mit stream verbundene Datei geschrieben.
Treten Fehler auf, wird EOF zur&uuml;ckgegeben, ansonsten das Zeichen c.
<P>
<P>
<P>putchar
<A NAME="IDX331"></A>
<PRE>
 Syntax:     int putchar(int c);
 Bibliothek: stdio.h
 Beispiel:   putchar(zeichen);
</PRE>
<P>Das Zeichen c wird auf die Standardausgabe geschrieben. Treten Fehler
auf, wird EOF zur&uuml;ckgeliefert, ansonsten das Zeichen c.
<P>
<P>
<P>puts
<A NAME="IDX332"></A>
<PRE>
 Syntax:     int puts(char *string);
 Bibliothek: stdio.h
 Beispiel:   puts(line);
</PRE>
<P>Die Zeichenkette string wird auf die Standardausgabe geschrieben und
der Cursor am Anfang der n&auml;chsten Zeile positioniert. Treten Fehler auf,
wird ein Wert ungleich 0 zur&uuml;ckgegeben, ansonsten der Wert 0.
<P>
<P>
<P>scanf
<A NAME="IDX333"></A>
<PRE>
 Syntax:     int scanf(char *format,...);
 Bibliothek: stdio.h
 Beispiel:   scanf("%d",&nummer);
</PRE>
<P>Von der Standardeingabe (i.d.R. Tastatur) werden Werte gem&auml;&szlig; der
Formatspezifikation eingelesen. Treten Fehler auf, wird EOF
zur&uuml;ckgegeben, ansonsten die Anzahl Zeichen, die eingelesen wurden.
<P>
<P>
<P>sscanf
<A NAME="IDX334"></A>
<PRE>
 Syntax:     int sscanf(char *string, char *format,...);
 Bibliothek: stdio.h
 Beispiel:   sscanf(string,"%d",&nummer);
</PRE>
<P>Gleiche Funktionsweise wie scanf(), mit dem Unterschied, da&szlig; die
Werte aus einer Zeichenkette gelesen werden, auf die
<TT>string</TT> weist.
<HR><H1><A NAME="Header_158" HREF="#PToC_158">Anhang G. Funktionen der Standardbibliotheken</A></H1>
<A NAME="IDX335"></A>
<A NAME="IDX336"></A>
<BR>
<P><B><A NAME="Table_18" HREF="#FT_Table_18">Tabelle 18. Ein-/Ausgabefunktionen</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">clearerr
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">setzt EOF- und Fehlerindikator einer Datei zur&uuml;ck
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fclose
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schlie&szlig;t eine Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">feof
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">testet auf EOF
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ferror
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">testet auf Dateifehler
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fflush
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">erzwingt das Speichern des Puffers in eine Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fgetc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest ein einzelnes Zeichen aus einer Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fgets
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest eine Zeile aus einer Datei in einen Puffer
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fopen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">&ouml;ffnet eine Datei in einem bestimmten Modus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fprintf
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt Daten formatiert in eine Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fputc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt ein einzelnes Zeichen in eine Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fputs
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt eine Zeichenkette in eine Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fread
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest mehrere S&auml;tze aus einer Datei in einen Puffer
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">freopen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ordnet einem Stream (Dateizeiger) eine neue Datei zu
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fscanf
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest Daten formatiert aus einer Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fseek
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">bewegt den Dateizeiger
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ftell
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt die aktuelle Position des Dateizeigers
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fwrite
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt mehrere S&auml;tze aus einem Puffer in eine Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">getc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest ein Zeichen von einem Stream
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">getch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest ein Zeichen von der Tastatur
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">conio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">getchar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest ein Zeichen von der Standardeingabe
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">getche
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest ein Zeichen von der Tastatur und gibt dieses auf dem
Bildschirm aus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">conio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">gets
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest eine Zeile von der Standardeingabe in einen Puffer
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">perror
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt eine Meldung auf stderr
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">printf
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt Daten formatiert auf die Standardausgabe
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">putc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt ein Zeichen auf einen stream
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">putchar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt ein Zeichen auf die Standardausgabe
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">puts
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt eine Zeile auf die Standardausgabe
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">remove
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">l&ouml;scht eine Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">rename
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">&auml;ndert den Namen einer Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">rewind
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">setzt den Dateizeiger auf den Anfang zur&uuml;ck
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">scanf
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest Daten formatiert von der Standardeingabe
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">setbuf
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">definiert einen Ein-/Ausgabe-Puffer f&uuml;r eine Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">setvbuf
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">definiert die Art der Pufferung f&uuml;r eine Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">sprintf
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">schreibt Daten formatiert an eine Speicherstelle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">sscanf
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liest Daten formatiert aus einer Zeichenkette
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">tmpfile
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">erzeugt und &ouml;ffnet eine tempor&auml;re Datei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">tmpnam
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">erzeugt einen tempor&auml;ren Dateinamen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ungetc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">R&uuml;ckg&auml;ngigmachen eines vorherigen getc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdio.h
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_19" HREF="#FT_Table_19">Tabelle 19. mathematische Funktionen</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">abs
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Absolutwert
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">acos
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Arcuscosinus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">asin
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Arcussinus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">atan
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Arcustangens
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">atan2
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Arcustangens eines Quotienten
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ceil
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">rundet positive Zahlen auf, negative ab
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">cos
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Cosinus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">cosh
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den hyperbolischen Cosinus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">exp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">dient als Exponentialfunktion e<SUP>x</SUP>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fabs
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Absolutwert einer Flie&szlig;kommazahl
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">floor
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">rundet positive Zahlen ab, negative auf
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fmod
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Rest einer Flie&szlig;kommaoperation
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">frexp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">bestimmt f&uuml;r float-Werte Mantisse und Exponent zur Basis 2
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ldexp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">berechnet das Produkt aus Mantisse und einer Zweierbasis
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">log
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den nat&uuml;rlichen Logarithmus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">log10
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den dekadischen Logarithmus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">pow
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">berechnet das Ergebnis von Potenzen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">rand
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">erzeugt eine Zufallszahl
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">sin
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Sinus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">sinh
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den hyperbolischen Sinus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">sqrt
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">berechnet die Quadratwurzel
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">srand
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">initialisiert den Zufallsgenerator
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">tan
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den Tangens
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">tanh
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt den hyperbolischen Tangens
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">math.h
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_20" HREF="#FT_Table_20">Tabelle 20. Speicherverwaltungsfunktionen</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">calloc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">reserviert Speicherplatz f&uuml;r Felder
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">free
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">gibt Speicherplatz frei
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">malloc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">reserviert Speicherplatz in Bytes
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">realloc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ver&auml;ndert die Gr&ouml;&szlig;e eines Speicherblockes
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">longjmp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">f&uuml;hrt R&uuml;cksprung zur setjmp-Stelle durch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">setjmp.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">setjmp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">markiert R&uuml;cksprung-Stelle f&uuml;r longjmp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">setjmp.h
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_21" HREF="#FT_Table_21">Tabelle 21. Test integer values (ohne deutsche Umlaute)</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">isalnum
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf alphanumerisch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">isalpha
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf alphabetisch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">iscntrl
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf Steuerzeichen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">isdigit
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf Ziffern
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">isgraph
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf Grafikzeichen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">islower
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf Kleinbuchstaben
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">isprint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf druckbare Zeichen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ispunct
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf Satzzeichen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">isspace
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf Trennzeichen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">isupper
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf Gro&szlig;buchstaben
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">isxdigit
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">pr&uuml;ft auf Hexadezimalziffern
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_22" HREF="#FT_Table_22">Tabelle 22. Umgebungssteuerung</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">abort
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">bricht das Programm mit einer Fehlermeldung ab
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">assert
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">erm&ouml;glicht den Programmabbruch, wenn ein Testergebnis fehlschl&auml;gt
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">
assert.h
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">exec
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">l&auml;dt und startet ein Programm
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">process.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">exit
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">beendet ein Programm ordnungsgem&auml;&szlig;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">getenv
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt die Werte der Umgebungsvariablen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">int86
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Interruptaufruf auf x86er-Systemen (z.B. DOS)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">dos.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">putenv
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">setzt eine neue Umgebungsvariable oder &auml;ndert
den Wert einer bestehenden
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">raise
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">sendet Signale an das Programm
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">signal.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">signal
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Funktion zur Behandlung von Interrupts des Betriebssystems
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">
signal.h
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">spawn
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">l&auml;dt und startet ein Programm
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">process.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">system
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Betriebssystemkommandos ausf&uuml;hren
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_23" HREF="#FT_Table_23">Tabelle 23. Umwandlungsfunktionen</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">atof
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert ASCII nach float
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">atoi
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert ASCII nach int
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">atol
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert ASCII nach long
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">itoa
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert int nach ASCII
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strtod
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert Zeichenkette nach double
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strtol
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert Zeichenkette nach long
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strtoul
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert Zeichenkette nach unsigned long
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">tolower
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert in Kleinbuchstaben
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">toupper
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert in Gro&szlig;buchstaben
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctype.h
</TD></TR></TABLE>
<P>
<BR>
<P><B><A NAME="Table_24" HREF="#FT_Table_24">Tabelle 24. Zeichenketten- und Speicherfunktionen</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">bsearch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">f&uuml;hrt bin&auml;re Suche in einem sortierten Feld durch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">memchr
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">sucht in einem bestimmten Speicherbereich nach einem
Zeichen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">memcmp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">vergleicht zwei Speicherbereiche miteinander
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">memset
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">initialisiert einen Speicherbereich
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">memcpy
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">kopiert n Bytes innerhalb des Speichers und liefert einen Zeiger
auf das Ziel zur&uuml;ck
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">qsort
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">sortiert ein Feld nach dem QuickSort-Algorithmus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">stdlib.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strcat
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">verkettet zwei Zeichenketten miteinander
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strchr
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">sucht ein Zeichen innerhalb einer Zeichenkette
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strcmp / stricmp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">vergleicht zwei Zeichenketten miteinander
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strcpy
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">kopiert eine Zeichenkette in einen anderen Speicherbereich
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.
h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strcspn
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt die Anzahl Zeichen einer Zeichenkette bis zu einem Begren
zer
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strlen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt die L&auml;nge einer Zeichenkette
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strncat
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">verkettet eine Zeichenkette mit einer Teilzeichenkette
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strncmp / strnicmp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">vergleicht n Zeichen zweier Zeichenketten
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strncpy
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">kopiert eine Teilzeichenkette in einen anderen
Speicherbereich
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strpbrk
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">ermittelt die Position des ersten Begrenzerzeichens
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strrchr
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">sucht von rechts nach links in einer Zeichenkette nach einem
einzelnen Zeichen
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strspn
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">sucht die Position eines nicht zur Vorgabemenge geh&ouml;rigen Zeichens
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strstr
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">sucht eine Teilzeichenkette in einer Zeichenkette
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">strtok
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">f&uuml;hrt eine Token-Suche in einer Zeichenkette durch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">string.h
</TD></TR></TABLE>
<P>
<BR>
<P><B><A NAME="Table_25" HREF="#FT_Table_25">Tabelle 25. Zeitfunktionen</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">asctime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert die Time-Struktur in eine Zeichenkette
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">time.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ctime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liefert eine Zeichenkette mit Datum und Uhrzeit
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">time.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">difftime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">liefert die Zeitdifferenz in Sekunden
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">time.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">gmtime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert die Time-Struktur in "Greenwich mean time"
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">time.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">localtime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">konvertiert die Time-Struktur in "Local time"
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">time.h
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">aktualisiert die Time-Struktur
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">time.h
</TD></TR></TABLE>
<HR><H1><A NAME="Header_159" HREF="#PToC_159">Anhang H. &Uuml;bersicht &uuml;ber die Include-/Header-Dateien</A></H1>
<P>Diese &Uuml;bersicht enth&auml;lt u.U. nicht alle Funktionsnamen,
die in den jeweiligen Dateien enthalten sind.
<P>
<P>assert.h
<P>Die Datei assert.h definiert nur das Test-Makro assert.
<P>
<P>
<P>ctype.h
<P>ctype.h enth&auml;lt u.a. die folgenden Funktionsprototypen, die
Integerwerte auf bestimmte Kennzeichen hin untersuchen:
<PRE>
isalnum     isdigit     isprint     isupper     toupper
isalpha     isgraph     ispunct     isxdigit
iscntrl     islower     isspace     tolower
</PRE>
<P>
<P>
<P>float.h
<P>Die Datei float.h enth&auml;lt u.a. Definitionen der Flie&szlig;kommakonstanten,
z.B. den Wertebereich der einzelnen Flie&szlig;kommadatentypen.
<P>
<P>
<P>limits.h
<P>Die Datei limits.h enth&auml;lt u.a. Definitionen f&uuml;r integer und
character.
<P>
<P>
<P>math.h
<P>Die Datei math.h enth&auml;lt u.a. Funktionsprototypen f&uuml;r mathematische
Funktionen und Makros:
<PRE>
acos         ceil       floor        log10         sqrt
asin         cos        fmod         modf          tan
atan         cosh       frexp        pow           tanh
atan2        exp        ldexp        sin
bessel       fabs       log          sinh
</PRE>
<P>
<P>
<P>setjmp.h
<P>Diese Datei definiert Prototypen f&uuml;r die Funktionen
<TT>setjmp</TT> und <TT>longjmp</TT> sowie einen Buffertyp, den
diese beiden Funktionen zum Speichern von Daten ben&ouml;tigen.
<P>
<P>
<P>signal.h
<P>Diese Datei enth&auml;lt u.a. Prototypen f&uuml;r die Funktionen <TT>signal</TT>
und <TT>raise</TT> sowie Wertzuordnungen f&uuml;r einzelne Signale.
<P>
<P>
<P>stdarg.h
<P>Diese Datei enth&auml;lt u.a. Makrodefinitionen, die es erm&ouml;glichen, auf
Parameter in Funktionen mit variablen Parameterlisten zuzugreifen.
Die dazugeh&ouml;rigen Funktionen sind <TT>va_arg, va_start</TT> und
<TT>va_end</TT>.
<P>
<P>
<P>stdio.h
<P>Diese Datei enth&auml;lt u.a. Prototypen und Makrodefinitionen f&uuml;r die
Ein- und Ausgabe von Daten. Sie umfa&szlig;t folgende Funktionen:
<PRE>
clearerr      fprintf      fwrite       puts         sscanf
fclose        fputc        getc         remove       tmpfile
feof          fputs        gets         rename       tmpnam
ferror        fread        getchar      rewind       ungetc
fflush        freopen      perror       scanf        vfprintf
fgetc         fscanf       printf       setbuf       vprintf
fgets         fseek        putc         setvbuf      vsprintf
fopen         ftell        putchar      sprintf
</PRE>
<P>
<P>
<P>stdlib.h
<P>Diese Datei enth&auml;lt u.a. Prototypen f&uuml;r folgende Funktionen:
<PRE>
abort         atol         free         qsort        strtod
abs           bsearch      getenv       rand         strtol
atof          calloc       labs         realloc      system
atoi          exit         malloc       srand
</PRE>
<P>
<P>
<P>string.h
<P>Diese Datei enth&auml;lt u.a. Prototypen f&uuml;r die Funktionen zur
Zeichenkettenbearbeitung.
<PRE>
memchr        strcat       strcspn      strncpy      strstr
memcmp        strchr       strlen       strpbrk      strtok
memcpy        strcmp       strncat      strrchr
memset        strcpy       strncmp      strspn
</PRE>
<P>
<P>
<P><P>
<P>time.h
<P>Diese Datei beinhaltet die Prototypen f&uuml;r folgende Funktionen:
<PRE>
              asctime      difftime     localtime
              ctime        gmtime       time
</PRE>
<P>Des weiteren befindet sich in dieser Datei die Definition der
Struktur <TT>tm</TT>, die von einigen der oben genannten Funktionen
benutzt wird.
<P>
<HR><H1><A NAME="Header_160" HREF="#PToC_160">Anhang I. Bedienung der Compiler Tools</A></H1>
<A NAME="IDX337"></A>
<A NAME="IDX338"></A>
<A NAME="IDX339"></A>
<A NAME="IDX340"></A>
<P>Die folgenden Abschnitte enthalten eine Auswahl der
Kommandozeilenschalter des Compilers
ICC und der Linker LINK386 und ILINK.
<HR><H2><A NAME="Header_161" HREF="#ToC_161">I.1 Compiler</A></H2>
<PRE>
ICC xyz.c                // compilieren und linken
ICC xyz.c abc.obj        // compilieren, linken und abc.obj linken
ICC /c xyz.c             // nur compilieren
ICC /?                   // Hilfe
ICC /Fc+                 // nur Syntax Check
ICC /Ti+                 // Debug information generieren
ICC /Wall+               // s&auml;mtliche Warnings ausgeben, die m&ouml;glich sind
ICC /Wgrp                // bestimmte Gruppen von Warnings ausgeben (siehe
                         // Onlinehilfe)
ICC /Sa                  // ANSI konform
ICC /Ss                  // C++ (//) Kommentare erlauben
 
ICC /Gd+                 // dynamische Runtime Library (DLL ben&ouml;tigt)
ICC /Ge-                 // DLL anstatt EXE erzeugen
ICC /Gm+                 // Multithreading Libraries
ICC /Gn+                 // keine Default Libraries im Objektfile
</PRE>
<HR><H2><A NAME="Header_162" HREF="#ToC_162">I.2 Linker</A></H2>
<P>LINK386
<PRE>
LINK386 /?                             // Parameter anzeigen
LINK386 abc.obj;                       // objektfile linken
LINK386 /PMTYPE&#58;windowcompat xyz.obj   // Programmtyp:
                                       // OS/2 window compatible
LINK386 abc+cursor, , MAIN;            // abc.obj und cursor.obj linken und
                                       // EXE mit dem Namen MAIN.EXE erzeugen
</PRE>
<P>ILINK (Visual Age C<TT>++</TT>,
IBM C and C<TT>++</TT> compilers 3.6)
<PRE>
ILINK /PMTYPE&#58;PM abc.obj abc.def       // Objektfile als PM Anwendung linken
 
</PRE>
<HR><H1><A NAME="Header_163" HREF="#PToC_163">Anhang J. Rechnung mit Bits und Bytes</A></H1>
<PRE>
Bitposition      7    6    5    4   3   2   1   0
Bitwert        128   64   32   16   8   4   2   1
</PRE>
<P>Beispiel
<PRE>
Bitposition      7    6    5    4   3   2   1   0
Bitwert        128   64   32   16   8   4   2   1
 
 
                 1    0    1    0   1   0   1   0
               128 +  0 + 32 +  0 + 8 + 0 + 2 + 0
 
Ergebnis:                                     170
</PRE>
<P>Bei <TT>signed</TT> Variablen und
Flie&szlig;kommazahlen wird das Bit links au&szlig;en, das sog.
Sign Bit, als Vorzeichen verwendet.
<HR><H1><A NAME="Header_164" HREF="#PToC_164">Anhang K. Zeichens&auml;tze</A></H1>
<HR><H2><A NAME="HDRSAS" HREF="#ToC_165">K.1 Standard ASCII</A></H2>
<A NAME="IDX342"></A>
<BR>
<P><B><A NAME="Table_26" HREF="#FT_Table_26">Tabelle 26. Standard ASCII Zeichensatz</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">3
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">4
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">5
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">6
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">7
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">8
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">9
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">000
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">NULL
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&face.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&FACE.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&HEART.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&DIAMOND.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&CLUB.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&SPADE.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">BEL
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">???
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">TAB
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">010
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">LF
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">VT
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">FF
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">CR
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&note1616.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&sun.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&gt;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&lt;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&udarrow.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#33;&#33;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">020
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&para;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&sect;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&cursor.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&udarrowus.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#94;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">V
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&gt;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&lt;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&lrarrow.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">030
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&TRIANGLE.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">???
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">Blank
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#33;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&quot;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">#
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#36;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#37;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&amp;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#39;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">040
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">(
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">)
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">+
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">,
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#46;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">/
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">1
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">050
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">3
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">4
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">5
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">6
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">7
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">8
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">9
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#58;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">060
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&lt;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">=
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&gt;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">?
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#64;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">A
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">B
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">C
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">D
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">E
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">070
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">F
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">G
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">H
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">I
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">J
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">K
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">L
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">M
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">N
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">O
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">080
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">P
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">Q
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">R
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">S
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">T
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">U
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">V
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">W
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">X
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">Y
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">090
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">Z
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#91;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#92;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#93;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#94;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#95;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#96;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">a
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">b
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">c
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">100
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">d
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">e
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">f
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">g
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">h
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">i
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">j
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">k
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">l
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">m
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">110
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">n
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">o
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">p
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">q
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">r
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">s
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">t
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">u
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">v
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">w
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">120
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">x
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">y
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">z
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#123;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#124;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#125;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#126;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&house.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD></TR></TABLE>
<P><P>
<HR><H2><A NAME="HDREAS" HREF="#ToC_166">K.2 Extended ASCII</A></H2>
<A NAME="IDX344"></A>
<BR>
<P><B><A NAME="Table_27" HREF="#FT_Table_27">Tabelle 27. Extended ASCII Zeichensatz</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="11" WIDTH="100%">-?- nicht darstellbar; ??? unbekannt
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">3
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">4
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">5
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">6
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">7
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">8
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">9
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">120
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ccedil;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&uuml;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">130
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&eacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&acirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&auml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&agrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&aring;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ccedil;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ecirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&euml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&egrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&iuml;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">140
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&icirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&igrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Auml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Aring;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Eacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&aelig;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&AElig;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ocirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ouml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ograve;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">150
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ucirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ugrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#95;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ouml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Uuml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&oslash;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&pound;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&yen;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#95;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&fnof.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">160
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&aacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&iacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&oacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&uacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ntilde;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ntilde;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><SUP>a</SUP>
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><SUP>o</SUP>
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&iquest;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#95;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">170
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&not;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&frac12;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&frac14;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&iexcl;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&laquo;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&raquo;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&box14.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&box12.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&box34.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#124;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">180
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx1012.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2021.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0021.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0012.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2022.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2020.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0022.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2002.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2001.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">190
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx1002.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx1210.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2120.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">200
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2200.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0220.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2202.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0222.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2220.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0202.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2222.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx1202.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2101.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0212.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">210
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0121.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2100.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx1200.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0210.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx0120.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx2121.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&bx1212.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&BOX.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">220
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&BOXBOT.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&BOXLEFT.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&BOXRIGHT.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&BOXTOP.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&alpha.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&szlig;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Gamma.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&pi.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&sum.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&sigma.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">230
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&micro;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&tau.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Phi.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">???
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Omega.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&delta.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&infinity.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">???
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">???
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&intersect.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">240
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&identical.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&plusmn;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&gt;&#61;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&lt;&#61;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&inttop.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&intbot.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&divide;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&nearly.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&deg;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#46;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">250
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#46;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&nu.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#95;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><SUP>2</SUP>
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&sqbul.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-?-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD></TR></TABLE>
<P><P>
<HR><H2><A NAME="HDRANSI" HREF="#ToC_167">K.3 ANSI</A></H2>
<A NAME="IDX346"></A>
<P>Die Zeichen mit den Codes 0 bis 127 entsprechen dem
ASCII Zeichensatz. Der ANSI Zeichensatz kommt unter Windows
zum Einsatz.
<BR>
<P><B><A NAME="Table_28" HREF="#FT_Table_28">Tabelle 28. ANSI Zeichensatz</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="11" WIDTH="100%">nb=nicht benutzt; -?- nicht darstellbar
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">3
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">4
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">5
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">6
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">7
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">8
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">9
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">120
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">nb
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">nb
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">130
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">,
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-?-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&quot;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">...
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&dagger.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&dbldag.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#94;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-?-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-?-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&lt;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">140
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">OE
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">nb
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">nb
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">nb
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">nb
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#39;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#39;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&quot;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&quot;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">*
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">150
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">--
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#126;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">(TM)
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-?-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&gt;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">oe
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">nb
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">nb
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ye.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">160
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-?-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&iexcl;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&cent;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&pound;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&curren;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&yen;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&brvbar;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&sect;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><SUP>&#46;&#46;</SUP>
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&copy;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">170
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><U>a</U>
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&laquo;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&not;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#45;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&reg;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&macr;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&deg;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&plusmn;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><SUB>2</SUB>
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><SUB>3</SUB>
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">180
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&acute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&micro;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&para;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&middot;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">-?-
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><SUB>1</SUB>
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><U>o</U>
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&raquo;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&frac14;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&frac12;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">190
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&frac34;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&iquest;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Agrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Aacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Acirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Atilde;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Auml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Aring;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&AElig;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ccedil;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">200
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Egrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Eacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ecirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Euml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Igrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Iacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Icirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Iuml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Dstroke.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ntilde;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">210
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ograve;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Oacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ocirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Otilde;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ouml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&times;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Oslash;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ugrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Uacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Ucirc;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">220
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Uuml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&Yacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&THORN;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&szlig;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&agrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&aacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&acirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&atilde;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&auml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&aring;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">230
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&aelig;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ccedil;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&egrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&eacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ecirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&euml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&igrave;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&iacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&icirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&iuml;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">240
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&eth;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ntilde;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ograve;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&oacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ocirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&otilde;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ouml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&divide;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&oslash;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ugrave;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">250
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&uacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&ucirc;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&uuml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&yacute;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&thorn;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&yuml;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD></TR></TABLE>
<P><P>
<HR><H2><A NAME="HDREBCD" HREF="#ToC_168">K.4 EBCDIC</A></H2>
<A NAME="IDX348"></A>
<BR>
<P><B><A NAME="Table_29" HREF="#FT_Table_29">Tabelle 29. EBCDIC Zeichensatz</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">3
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">4
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">5
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">6
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">7
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">8
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">9
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">060
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">BLANK
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">070
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#46;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&lt;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">(
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#43;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#124;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">080
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&amp;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">090
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#33;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#36;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#42;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">)
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#59;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#94;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#95;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#47;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">100
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#124;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">,
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#37;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#95;
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">110
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&gt;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">?
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">120
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#58;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#35;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#64;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#39;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#61;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&quot;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">a
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">130
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">b
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">c
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">d
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">e
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">f
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">g
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">h
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">i
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">140
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">j
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">k
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">l
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">m
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">n
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">150
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">o
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">p
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">q
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">r
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">160
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">s
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">t
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">u
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">v
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">w
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">x
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">y
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">z
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">170
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">180
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%"><BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">190
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">{
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">A
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">B
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">C
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">D
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">E
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">F
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">G
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">200
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">H
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">I
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">}
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">J
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">210
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">K
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">L
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">M
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">N
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">O
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">P
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">Q
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">R
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">220
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">&#92;
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">S
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">T
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">U
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">V
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">230
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">W
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">X
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">Y
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">Z
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">
<BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">240
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">0
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">1
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">2
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">3
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">4
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">5
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">6
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">7
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">8
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="9%">9
</TD></TR></TABLE>
<HR><H1><A NAME="Header_169" HREF="#PToC_169">Anhang L. Literaturverzeichnis</A></H1>
<DL>
<P><DT>Erlenk&ouml;tter, Helmut; Reher, Volker
<DD>Programmiersprache C
<BR>
Ein strukturierte Einf&uuml;hrung
<BR>
Reinbek bei Hamburg: Rowohlt Taschenbuch Verlag GmbH
<BR>
ISBN 3 499 18166 5
<P><DT>IBM document
<DD>Common Programming Interface - C Reference
<BR>
Doc.Nr. SC26-4353-0
<BR>
IBM document
<BR>
SAA - Writing Applications: A Design Guide
<BR>
Doc.Nr. SC26-4362
<P><DT>Kernighan, Brian W; Ritchie, Dennis M
<DD>Programmieren in C - Mit dem C-Reference Manual in deutscher Sprache
<BR>
2. Ausgabe, ANSI C
<BR>
Muenchen: Hanser
<BR>
ISBN 3-446-15497-3
<P><DT>Kernighan, Brian W; Ritchie, Dennis M
<DD>The C Programming Language
<BR>
Englewood Cliffs: Prentice-Hall
<BR>
ISBN 0-13-110370-9
</DL>
<HR><H1><A NAME="Header_170" HREF="#PToC_170">Anhang M. Online Ressourcen</A></H1>
<HR><H2><A NAME="Header_171" HREF="#ToC_171">M.1 Ressourcen unter VM</A></H2>
<P>Im Office Vision/VM sind nach Eingabe von
<TT>RZLINK IBMPC</TT> u.a. folgende Dateien
im Zugriff, die sich mit der Programmiersprache
C befassen:
<UL>
<P><LI>C-ANSI FORUM
<P><LI>C-DEVELO FORUM
<P><LI>C-LANG FORUM
<P><LI>C-LANG ANSWERS
<P><LI>C-LANG PROCS
<P><LI>C-PITFAL ANSWERS
<P><LI>C-SET++ FORUM
<P><LI>C-SET++ ANSWERS
<P><LI>OS2BASE PROCS
<P><LI>VACPP FORUM
<P><LI>VACPP CFORUM
</UL>
<P>Dateien mit der Erweiterung <TT>FORUM</TT> sind
Diskussionsforen, an denen jeder IBMer teilnehmen kann.
Dateien mit der Erweiterung <TT>CFORUM</TT> sind
ebenfalls Diskussionsforen. Diese sind jedoch auch
externen zug&auml;nglich und unterliegen daher strengeren
Sicherheitsvorschriften. Die Verbreitung von
vertraulichem Material ist selbstverst&auml;ndlich in allen
Diskussionsforen, egal ob intern oder intern/extern,
untersagt. Dateien mit der Erweiterung <TT>ANSWERS</TT>
enthalten h&auml;ufig gestellte Fragen und entsprechende
Antworten. Diese Dateien lassen sich mit der Anwendung
<TT>SHOWME</TT> betrachten. Dateien mit der Erweiterung
<TT>PROCS</TT> enthalten h&auml;ufig ben&ouml;tigte Codefragmente.
Bei allen Dateien ist zu beachten, da&szlig; diese ausschlie&szlig;lich
in englischer Sprache gef&uuml;hrt werden und durch unterschiedliche
Codepages Sonderzeichen (z.B. { }) auf deutschen Systemen
nicht korrekt dargestellt werden.
<P>Dateien, die sich mit der Programmiersprache
C<TT>++</TT> befassen:
<UL>
<P><LI>C<TT>++</TT> PROCS
<P><LI>C<TT>++</TT> ANSWERS
<P><LI>C<TT>++</TT>CLASS PROCS
<P><LI>C<TT>++</TT>CLASS FORUM
</UL>
<P>Dateien, die sich mit C/C<TT>++</TT>/REXX
und weiteren Programmiersprachen befassen:
<UL>
<P><LI>OS2DEVEL FORUM
<P><LI>OS2PM PROCS
<P><LI>OS2PMPRG ANSWERS
<P><LI>OS2SQL PROCS
<P><LI>REXXOS2 ANSWERS
<P><LI>REXXOS2 CMDFILES
<P><LI>RXUTILS PROCS
<P><LI>SWREUSE FORUM
<P><LI>TOOLKT21 FORUM
</UL>
<HR><H2><A NAME="Header_172" HREF="#ToC_172">M.2 Ressourcen im Internet</A></H2>
<P>Die folgenden Adressen stellen eine Auswahl des Angebotes
an Seiten im Internet dar, die sich mit der Programmiersprache C
befassen. Da nichts unverg&auml;nglich ist, k&ouml;nnen sich die Adressen
jederzeit &auml;ndern. Stand der Liste: 15.04.1997
<P>C Library Reference (&Uuml;bersicht &uuml;ber die C Libraryfunktionen)
<PRE>
http://ebweb.tuwien.ac.at/gnu-docs/libc-1.12/libc_toc.html
</PRE>
<P>The Electronic Developer Magazine for OS/2
<P>Viele Informationen und Beispielcode zur Programmierung unter OS/2.
Auch Produkttests und hervorragende Einf&uuml;hrungen in C und
C<TT>++</TT>.
<PRE>
http://www.edm2.com/
</PRE>
<P>Learn C/C<TT>++</TT> Today (A list of resources/tutorial)
<PRE>
http://www.lib.ox.ac.uk/internet/news/faq/archive/c-faq.learn-c-cpp-today.html
</PRE>
<P>Online EE Textbook (C Kurs)
<PRE>
http://spectra.eng.hawaii.edu/Courses/EE150/Book/book.html
</PRE>
<P>Programmiersprache C/C<TT>++</TT> (C Kurs)
<PRE>
http://www.informatik.uni-halle.de/lehre/c/index.html
</PRE>
<P>Programming in C (C Kurs)
<PRE>
http://www.cm.cf.ac.uk/Dave/C/CE.html
</PRE>
<P>SIMTEL NET - C (Programme und Quelltexte)
<PRE>
http://www.simtel.net/simtel.net/msdos/c-pre.html
</PRE>
<P>SNIPPETS (Exzellente Sammlung von Quelltexten und Informationsdateien)
<PRE>
http://www.brokersys.com/snippets/
</PRE>
<HR><H1><A NAME="HDRINDEX_START" HREF="#PToC_173">Index</A></H1>
<A NAME="IDX0_00" HREF="#IDX1_00">Special Characters</A><BR>
<A NAME="IDX0_41" HREF="#IDX1_41">A</A>
<A NAME="IDX0_42" HREF="#IDX1_42">B</A>
<A NAME="IDX0_43" HREF="#IDX1_43">C</A>
<A NAME="IDX0_44" HREF="#IDX1_44">D</A>
<A NAME="IDX0_45" HREF="#IDX1_45">E</A>
<A NAME="IDX0_46" HREF="#IDX1_46">F</A>
<A NAME="IDX0_47" HREF="#IDX1_47">G</A>
<A NAME="IDX0_48" HREF="#IDX1_48">H</A>
<A NAME="IDX0_49" HREF="#IDX1_49">I</A>
<A NAME="IDX0_4B" HREF="#IDX1_4B">K</A>
<A NAME="IDX0_4C" HREF="#IDX1_4C">L</A>
<A NAME="IDX0_4D" HREF="#IDX1_4D">M</A>
<A NAME="IDX0_4E" HREF="#IDX1_4E">N</A>
<A NAME="IDX0_4F" HREF="#IDX1_4F">O</A>
<A NAME="IDX0_50" HREF="#IDX1_50">P</A>
<A NAME="IDX0_51" HREF="#IDX1_51">Q</A>
<A NAME="IDX0_52" HREF="#IDX1_52">R</A>
<A NAME="IDX0_53" HREF="#IDX1_53">S</A>
<A NAME="IDX0_54" HREF="#IDX1_54">T</A>
<A NAME="IDX0_55" HREF="#IDX1_55">U</A>
<A NAME="IDX0_56" HREF="#IDX1_56">V</A>
<A NAME="IDX0_57" HREF="#IDX1_57">W</A>
<A NAME="IDX0_5A" HREF="#IDX1_5A">Z</A>
<HR>
<STRONG><A NAME="IDX1_00" HREF="#IDX0_00">Special Characters</A></STRONG>
<MENU>
<LI>#define 
<A HREF="#IDX286">(286)</A>, <A HREF="#IDX297">(297)</A>, <A HREF="#IDX298">(298)</A>
<LI>#elif 
<A HREF="#IDX307">(307)</A>
<LI>#else 
<A HREF="#IDX304">(304)</A>
<LI>#endif 
<A HREF="#IDX305">(305)</A>
<LI>#error 
<A HREF="#IDX299">(299)</A>
<LI>#if 
<A HREF="#IDX301">(301)</A>
<LI>#ifdef 
<A HREF="#IDX302">(302)</A>
<LI>#ifndef 
<A HREF="#IDX303">(303)</A>
<LI>#include 
<A HREF="#IDX300">(300)</A>
<LI>#line 
<A HREF="#IDX308">(308)</A>
<LI>#pragma 
<A HREF="#IDX309">(309)</A>
<LI>#undef 
<A HREF="#IDX306">(306)</A>
<LI>&amp; 
<A HREF="#IDX144">(144)</A>
<LI>\0 
<A HREF="#IDX186">(186)</A>
<LI>\n 
<A HREF="#IDX187">(187)</A>
<LI>\r 
<A HREF="#IDX188">(188)</A>
<LI>__FILE__ 
<A HREF="#IDX284">(284)</A>
<LI>__LINE__ 
<A HREF="#IDX285">(285)</A>
</MENU>
<STRONG><A NAME="IDX1_41" HREF="#IDX0_41">A</A></STRONG>
<MENU>
<LI>Algorithmus 
<A HREF="#IDX3">(3)</A>
<LI>argc 
<A HREF="#IDX289">(289)</A>
<LI>argv 
<A HREF="#IDX288">(288)</A>
<MENU>
<LI>Beispiel 
<A HREF="#IDX148">(148)</A>
</MENU>
<LI>Array 
<A HREF="#IDX106">(106)</A>
<MENU>
<LI>Eindimensionales array 
<A HREF="#IDX110">(110)</A>
<LI>Initialisierung 
<A HREF="#IDX114">(114)</A>
<LI>Mehrdimensionales array 
<A HREF="#IDX112">(112)</A>
<LI>String 
<A HREF="#IDX117">(117)</A>
<LI>Zeichenketten 
<A HREF="#IDX116">(116)</A>
</MENU>
<LI>ASCII 
<A HREF="#IDX85">(85)</A>
<MENU>
<LI>Extended ASCII 
<A HREF="#IDX89">(89)</A>
</MENU>
<LI>Ausdr&uuml;cke 
<A HREF="#IDX15">(15)</A>
<LI>auto 
<A HREF="#IDX170">(170)</A>
</MENU>
<STRONG><A NAME="IDX1_42" HREF="#IDX0_42">B</A></STRONG>
<MENU>
<LI>Betriebssystembefehle ausf&uuml;hren 
<A HREF="#IDX290">(290)</A>
<LI>Bezeichner 
<A HREF="#IDX34">(34)</A>
<LI>Big Endian 
<A HREF="#IDX254">(254)</A>
<LI>boolsche Variable 
<A HREF="#IDX17">(17)</A>
<LI>break 
<A HREF="#IDX225">(225)</A>, <A HREF="#IDX232">(232)</A>, <A HREF="#IDX235">(235)</A>
</MENU>
<STRONG><A NAME="IDX1_43" HREF="#IDX0_43">C</A></STRONG>
<MENU>
<LI>calloc 
<A HREF="#IDX271">(271)</A>
<LI>case 
<A HREF="#IDX230">(230)</A>, <A HREF="#IDX233">(233)</A>
<LI>cast 
<A HREF="#IDX159">(159)</A>
<LI>char 
<A HREF="#IDX82">(82)</A>
<LI>Compiler 
<A HREF="#IDX337">(337)</A>
<LI>Compilersprache 
<A HREF="#IDX4">(4)</A>
<LI>continue 
<A HREF="#IDX226">(226)</A>
</MENU>
<STRONG><A NAME="IDX1_44" HREF="#IDX0_44">D</A></STRONG>
<MENU>
<LI>Dateibehandlung 
<A HREF="#IDX236">(236)</A>
<MENU>
<LI>bin&auml;re Dateien 
<A HREF="#IDX252">(252)</A>
<LI>Datei &ouml;ffnen/schlie&szlig;en 
<A HREF="#IDX238">(238)</A>
<LI>Zeichen/Zeichenketten lesen 
<A HREF="#IDX244">(244)</A>
</MENU>
<LI>Datentypen 
<A HREF="#IDX35">(35)</A>
<MENU>
<LI>&Uuml;bersicht &uuml;ber die Datentypen 
<A HREF="#IDX313">(313)</A>
<LI>Array 
<A HREF="#IDX108">(108)</A>
<LI>char 
<A HREF="#IDX84">(84)</A>
<LI>eigene Datentypen 
<A HREF="#IDX166">(166)</A>
<LI>Einfache Datentypen 
<A HREF="#IDX37">(37)</A>
<LI>enum 
<A HREF="#IDX155">(155)</A>
<LI>Floating Point 
<MENU>
<LI>double 
<A HREF="#IDX72">(72)</A>
<LI>float 
<A HREF="#IDX67">(67)</A>
<LI>long double 
<A HREF="#IDX77">(77)</A>
</MENU>
<LI>Integer 
<A HREF="#IDX40">(40)</A>
<MENU>
<LI>int 
<A HREF="#IDX50">(50)</A>
<LI>long int 
<A HREF="#IDX55">(55)</A>
<LI>long long int 
<A HREF="#IDX60">(60)</A>
<LI>short int 
<A HREF="#IDX45">(45)</A>
</MENU>
<LI>Pointer 
<A HREF="#IDX138">(138)</A>
<LI>struct 
<A HREF="#IDX121">(121)</A>
<LI>union 
<A HREF="#IDX134">(134)</A>
<LI>void 
<A HREF="#IDX151">(151)</A>
<LI>wchar_t 
<A HREF="#IDX99">(99)</A>
</MENU>
<LI>Datentypumwandlung 
<A HREF="#IDX156">(156)</A>
<MENU>
<LI>cast 
<A HREF="#IDX163">(163)</A>
<LI>Explizite Datentypumwandlung 
<A HREF="#IDX162">(162)</A>
<LI>Implizite Datentypumwandlung 
<A HREF="#IDX158">(158)</A>
</MENU>
<LI>Debugging 
<A HREF="#IDX283">(283)</A>
<LI>default 
<A HREF="#IDX231">(231)</A>, <A HREF="#IDX234">(234)</A>
<LI>do while 
<A HREF="#IDX219">(219)</A>
</MENU>
<STRONG><A NAME="IDX1_45" HREF="#IDX0_45">E</A></STRONG>
<MENU>
<LI>EBCDIC 
<A HREF="#IDX92">(92)</A>
<LI>else 
<A HREF="#IDX228">(228)</A>
<LI>enum 
<A HREF="#IDX152">(152)</A>
<LI>Enumeration 
<A HREF="#IDX153">(153)</A>
<LI>exec 
<A HREF="#IDX294">(294)</A>
<LI>extern 
<A HREF="#IDX176">(176)</A>
</MENU>
<STRONG><A NAME="IDX1_46" HREF="#IDX0_46">F</A></STRONG>
<MENU>
<LI>falsch 
<A HREF="#IDX18">(18)</A>
<LI>fclose 
<A HREF="#IDX241">(241)</A>
<LI>Felder 
<A HREF="#IDX105">(105)</A>
<LI>feof 
<A HREF="#IDX247">(247)</A>
<LI>fflush 
<A HREF="#IDX190">(190)</A>
<LI>fgetc 
<A HREF="#IDX245">(245)</A>, <A HREF="#IDX258">(258)</A>, <A HREF="#IDX319">(319)</A>
<LI>fgets 
<A HREF="#IDX248">(248)</A>, <A HREF="#IDX260">(260)</A>, <A HREF="#IDX320">(320)</A>
<LI>FILE 
<A HREF="#IDX239">(239)</A>
<LI>Floating Point 
<A HREF="#IDX62">(62)</A>
<LI>Fluchtsymbolzeichen 
<A HREF="#IDX185">(185)</A>, <A HREF="#IDX318">(318)</A>
<LI>fopen 
<A HREF="#IDX240">(240)</A>
<LI>for 
<A HREF="#IDX222">(222)</A>
<LI>Formale Grundstruktur 
<A HREF="#IDX13">(13)</A>
<LI>fprintf 
<A HREF="#IDX261">(261)</A>, <A HREF="#IDX321">(321)</A>
<LI>fputc 
<A HREF="#IDX256">(256)</A>, <A HREF="#IDX322">(322)</A>
<LI>fputs 
<A HREF="#IDX249">(249)</A>, <A HREF="#IDX259">(259)</A>, <A HREF="#IDX323">(323)</A>
<LI>fread 
<A HREF="#IDX264">(264)</A>
<LI>free 
<A HREF="#IDX277">(277)</A>
<LI>fscanf 
<A HREF="#IDX262">(262)</A>
<LI>Funktionen 
<A HREF="#IDX202">(202)</A>
<MENU>
<LI>call by reference 
<A HREF="#IDX206">(206)</A>
<LI>call by value 
<A HREF="#IDX205">(205)</A>
<LI>Prototypen 
<A HREF="#IDX208">(208)</A>
<LI>Variable Anzahl an Parametern 
<A HREF="#IDX210">(210)</A>
</MENU>
<LI>fwrite 
<A HREF="#IDX263">(263)</A>
</MENU>
<STRONG><A NAME="IDX1_47" HREF="#IDX0_47">G</A></STRONG>
<MENU>
<LI>getc 
<A HREF="#IDX257">(257)</A>, <A HREF="#IDX324">(324)</A>
<LI>getch 
<A HREF="#IDX325">(325)</A>
<LI>getchar 
<A HREF="#IDX250">(250)</A>, <A HREF="#IDX326">(326)</A>
<LI>getche 
<A HREF="#IDX327">(327)</A>
<LI>gets 
<A HREF="#IDX328">(328)</A>
</MENU>
<STRONG><A NAME="IDX1_48" HREF="#IDX0_48">H</A></STRONG>
<MENU>
<LI>Heap 
<A HREF="#IDX169">(169)</A>
</MENU>
<STRONG><A NAME="IDX1_49" HREF="#IDX0_49">I</A></STRONG>
<MENU>
<LI>ICC 
<A HREF="#IDX338">(338)</A>
<LI>if 
<A HREF="#IDX227">(227)</A>
<LI>ILINK 
<A HREF="#IDX340">(340)</A>
<LI>Integer 
<A HREF="#IDX38">(38)</A>
<MENU>
<LI>int 
<A HREF="#IDX47">(47)</A>
<LI>long int 
<A HREF="#IDX52">(52)</A>
<LI>long long int 
<A HREF="#IDX57">(57)</A>
<LI>short int 
<A HREF="#IDX42">(42)</A>
</MENU>
<LI>Interpretersprache 
<A HREF="#IDX5">(5)</A>
</MENU>
<STRONG><A NAME="IDX1_4B" HREF="#IDX0_4B">K</A></STRONG>
<MENU>
<LI>Kommandozeilenparameter 
<A HREF="#IDX287">(287)</A>
<LI>Kommentare 
<A HREF="#IDX14">(14)</A>
<LI>Konstanten 
<MENU>
<LI>Floating Point 
<A HREF="#IDX81">(81)</A>
<LI>Zeichenkettenkonstanten 
<A HREF="#IDX104">(104)</A>
<LI>Zeichenkonstanten 
<A HREF="#IDX103">(103)</A>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_4C" HREF="#IDX0_4C">L</A></STRONG>
<MENU>
<LI>Laufzeitbibliothek 
<A HREF="#IDX6">(6)</A>
<LI>Library 
<A HREF="#IDX336">(336)</A>
<LI>LINK386 
<A HREF="#IDX339">(339)</A>
<LI>Little Endian 
<A HREF="#IDX253">(253)</A>
</MENU>
<STRONG><A NAME="IDX1_4D" HREF="#IDX0_4D">M</A></STRONG>
<MENU>
<LI>malloc 
<A HREF="#IDX268">(268)</A>
</MENU>
<STRONG><A NAME="IDX1_4E" HREF="#IDX0_4E">N</A></STRONG>
<MENU>
<LI>NULL 
<A HREF="#IDX139">(139)</A>
</MENU>
<STRONG><A NAME="IDX1_4F" HREF="#IDX0_4F">O</A></STRONG>
<MENU>
<LI>Objektcode 
<A HREF="#IDX8">(8)</A>
<LI>objektorientierte Sprache 
<A HREF="#IDX10">(10)</A>
<LI>Operand 
<A HREF="#IDX16">(16)</A>
<LI>Operator 
<A HREF="#IDX20">(20)</A>
<LI>Operatoren 
<A HREF="#IDX314">(314)</A>
<MENU>
<LI>Arithmetische Operatoren 
<A HREF="#IDX22">(22)</A>
<LI>Hierarchie der Operatoren 
<A HREF="#IDX33">(33)</A>
<LI>Logische Operatoren 
<A HREF="#IDX29">(29)</A>
<LI>Monadische Operatoren 
<A HREF="#IDX25">(25)</A>
<LI>Un&auml;re Operatoren 
<A HREF="#IDX24">(24)</A>
<LI>Vergleichende Operatoren 
<A HREF="#IDX27">(27)</A>
<LI>Zusammengesetzte Zuweisungsoperatoren 
<A HREF="#IDX31">(31)</A>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_50" HREF="#IDX0_50">P</A></STRONG>
<MENU>
<LI>Pointer 
<A HREF="#IDX136">(136)</A>
<LI>Portabilit&auml;t 
<A HREF="#IDX1">(1)</A>
<LI>printf 
<A HREF="#IDX182">(182)</A>, <A HREF="#IDX329">(329)</A>
<MENU>
<LI>Formatstring 
<A HREF="#IDX184">(184)</A>
</MENU>
<LI>Problembehebung 
<A HREF="#IDX310">(310)</A>
<LI>Programme starten 
<A HREF="#IDX292">(292)</A>
<LI>prozedurale Sprache 
<A HREF="#IDX9">(9)</A>
<LI>Puffer leeren 
<A HREF="#IDX191">(191)</A>
<LI>putc 
<A HREF="#IDX255">(255)</A>, <A HREF="#IDX330">(330)</A>
<LI>putchar 
<A HREF="#IDX246">(246)</A>, <A HREF="#IDX331">(331)</A>
<LI>puts 
<A HREF="#IDX332">(332)</A>
</MENU>
<STRONG><A NAME="IDX1_51" HREF="#IDX0_51">Q</A></STRONG>
<MENU>
<LI>Quellcode 
<A HREF="#IDX2">(2)</A>
</MENU>
<STRONG><A NAME="IDX1_52" HREF="#IDX0_52">R</A></STRONG>
<MENU>
<LI>Rationale Zahlen 
<A HREF="#IDX61">(61)</A>
<MENU>
<LI>double 
<A HREF="#IDX69">(69)</A>
<LI>float 
<A HREF="#IDX64">(64)</A>
<LI>Konstanten 
<A HREF="#IDX79">(79)</A>
<LI>long double 
<A HREF="#IDX74">(74)</A>
</MENU>
<LI>realloc 
<A HREF="#IDX274">(274)</A>
<LI>register 
<A HREF="#IDX179">(179)</A>
<LI>Regul&auml;re Ausdr&uuml;cke 
<A HREF="#IDX296">(296)</A>
<LI>Regular Expression 
<A HREF="#IDX295">(295)</A>
<LI>return 
<A HREF="#IDX203">(203)</A>
<LI>Runtime-Library 
<A HREF="#IDX7">(7)</A>
</MENU>
<STRONG><A NAME="IDX1_53" HREF="#IDX0_53">S</A></STRONG>
<MENU>
<LI>scanf 
<A HREF="#IDX189">(189)</A>, <A HREF="#IDX333">(333)</A>
<MENU>
<LI>Formatstring 
<A HREF="#IDX317">(317)</A>
</MENU>
<LI>Schl&uuml;sselworte 
<A HREF="#IDX12">(12)</A>, <A HREF="#IDX311">(311)</A>
<LI>Schleifen 
<A HREF="#IDX215">(215)</A>
<MENU>
<LI>do while 
<A HREF="#IDX221">(221)</A>
<LI>for 
<A HREF="#IDX224">(224)</A>
<LI>while 
<A HREF="#IDX218">(218)</A>
</MENU>
<LI>spawn 
<A HREF="#IDX293">(293)</A>
<LI>Speicherklassen 
<A HREF="#IDX167">(167)</A>
<MENU>
<LI>automatic 
<A HREF="#IDX172">(172)</A>
<LI>extern 
<A HREF="#IDX178">(178)</A>
<LI>register 
<A HREF="#IDX181">(181)</A>
<LI>static 
<A HREF="#IDX175">(175)</A>
</MENU>
<LI>Speicherverwaltung 
<A HREF="#IDX265">(265)</A>
<MENU>
<LI>Speicherblock freigeben 
<A HREF="#IDX276">(276)</A>
<LI>Speicherplatz reservieren 
<A HREF="#IDX267">(267)</A>
<LI>Speicherplatz reservieren und initialisieren 
<A HREF="#IDX270">(270)</A>
<LI>Speicherplatzgr&ouml;&szlig;e ver&auml;ndern 
<A HREF="#IDX273">(273)</A>
</MENU>
<LI>sscanf 
<A HREF="#IDX334">(334)</A>
<LI>Stack 
<A HREF="#IDX168">(168)</A>
<LI>Standardbibliothek 
<A HREF="#IDX335">(335)</A>
<LI>static 
<A HREF="#IDX173">(173)</A>
<LI>strcat 
<A HREF="#IDX193">(193)</A>, <A HREF="#IDX196">(196)</A>
<LI>strcmp 
<A HREF="#IDX198">(198)</A>
<LI>strcpy 
<A HREF="#IDX192">(192)</A>, <A HREF="#IDX201">(201)</A>
<LI>String 
<A HREF="#IDX118">(118)</A>
<LI>strlen 
<A HREF="#IDX200">(200)</A>
<LI>strncat 
<A HREF="#IDX197">(197)</A>
<LI>strncmp 
<A HREF="#IDX199">(199)</A>
<LI>struct 
<A HREF="#IDX122">(122)</A>
<LI>Strukturen 
<A HREF="#IDX119">(119)</A>
<MENU>
<LI>Felder von Strukturen 
<A HREF="#IDX124">(124)</A>
<LI>Initialisierung von Strukturen 
<A HREF="#IDX131">(131)</A>
<LI>Strukturen mit Typendefinition 
<A HREF="#IDX127">(127)</A>
<LI>Zugriff auf Strukturkomponenten 
<A HREF="#IDX129">(129)</A>
</MENU>
<LI>switch 
<A HREF="#IDX229">(229)</A>
<LI>system 
<A HREF="#IDX291">(291)</A>
</MENU>
<STRONG><A NAME="IDX1_54" HREF="#IDX0_54">T</A></STRONG>
<MENU>
<LI>tolower 
<A HREF="#IDX194">(194)</A>
<LI>toupper 
<A HREF="#IDX195">(195)</A>
<LI>type cast 
<A HREF="#IDX160">(160)</A>
<LI>typedef 
<A HREF="#IDX125">(125)</A>, <A HREF="#IDX164">(164)</A>
</MENU>
<STRONG><A NAME="IDX1_55" HREF="#IDX0_55">U</A></STRONG>
<MENU>
<LI>Unions 
<A HREF="#IDX132">(132)</A>
</MENU>
<STRONG><A NAME="IDX1_56" HREF="#IDX0_56">V</A></STRONG>
<MENU>
<LI>va_arg 
<A HREF="#IDX213">(213)</A>
<LI>va_end 
<A HREF="#IDX214">(214)</A>
<LI>va_list 
<A HREF="#IDX211">(211)</A>
<LI>va_start 
<A HREF="#IDX212">(212)</A>
<LI>Verkettete Listen 
<A HREF="#IDX278">(278)</A>
<MENU>
<LI>Doppelt verkettete Liste 
<A HREF="#IDX280">(280)</A>
<LI>Einfach verkettete Liste 
<A HREF="#IDX282">(282)</A>
</MENU>
<LI>void 
<A HREF="#IDX149">(149)</A>
</MENU>
<STRONG><A NAME="IDX1_57" HREF="#IDX0_57">W</A></STRONG>
<MENU>
<LI>wahr 
<A HREF="#IDX19">(19)</A>
<LI>wchar_t 
<A HREF="#IDX97">(97)</A>
<LI>while 
<A HREF="#IDX216">(216)</A>
</MENU>
<STRONG><A NAME="IDX1_5A" HREF="#IDX0_5A">Z</A></STRONG>
<MENU>
<LI>Zeichenkettenkonstanten 
<A HREF="#IDX101">(101)</A>
<LI>Zeichenkonstanten 
<A HREF="#IDX100">(100)</A>
<LI>Zeichens&auml;tze 
<MENU>
<LI>ASCII 
<A HREF="#IDX87">(87)</A>
<LI>EBCDIC 
<A HREF="#IDX94">(94)</A>
<LI>Extended ASCII 
<A HREF="#IDX91">(91)</A>
<LI>ISO Latin 1 
<A HREF="#IDX96">(96)</A>
</MENU>
<LI>Zeichensatz 
<A HREF="#IDX11">(11)</A>
<MENU>
<LI>ANSI 
<A HREF="#IDX346">(346)</A>
<LI>ASCII 
<A HREF="#IDX342">(342)</A>
<LI>EBCDIC 
<A HREF="#IDX348">(348)</A>
<LI>Extended ASCII 
<A HREF="#IDX344">(344)</A>
</MENU>
<LI>Zeiger 
<A HREF="#IDX135">(135)</A>
<MENU>
<LI>Anwendung von Zeigern 
<A HREF="#IDX143">(143)</A>
<LI>Vereinbarung von Zeigern 
<A HREF="#IDX141">(141)</A>
<LI>Zeiger und Felder 
<A HREF="#IDX146">(146)</A>
</MENU>
<LI>Zugriffsmodus 
<A HREF="#IDX242">(242)</A>
</MENU>
<DL COMPACT>
<P><DT><SUP><A NAME="Footnote_1" HREF="#Footnote_Used_1" >1</A></SUP></DT>
<DD>Portabilit&auml;t bezeichnet die M&ouml;glichkeit,
den Quellcode eines Programmes
ohne Modifikation auf mehreren Computersystemen &uuml;bersetzen
zu lassen.
</DD>
<P><DT><SUP><A NAME="Footnote_2" HREF="#Footnote_Used_2" >2</A></SUP></DT>
<DD>
<CITE>Eine Variable ist einfach ein praktischer Ort, an dem man etwas
unterbringen kann. Ein Ort mit einem Namen, an dem Sie Ihr spezielles
Etwas wiederfinden, wenn Sie zu einem sp&auml;teren Zeitpunkt nachsehen.
Wie im richtigen Leben gibt es verschiedene Arten von Orten,
an denen Dinge gespeichert werden k&ouml;nnen. Die einen sind eher privater
Natur, w&auml;hrend die anderen der &Ouml;ffentlichkeit zug&auml;nglich sind.
Einige Orte existieren nur &uuml;ber kurze Zeit, w&auml;hrend andere immer 
vorhanden sind. Informatiker lieben es, hier vom "Geltungsbereich" von 
Variablen zu sprechen, aber mehr als das gerade Gesagte ist nicht damit 
gemeint.</CITE>
(Programmieren mit Perl; Larry Wall, Tom Christiansen & Randal L.
Schwartz; O'Reilly Verlag 1997; Deutsche Ausgabe der 2. Auflage)
<P>Eine singulare Variable ist ein "Skalar", eine plurale Variable ein
"Array".
</DD>
<P><DT><SUP><A NAME="Footnote_3" HREF="#Footnote_Used_3" >3</A></SUP></DT>
<DD>American National Standard Code for
Information Interchange, siehe auch
<A HREF="#HDRSAS">K.1, "Standard ASCII"</A>
</DD>
<P><DT><SUP><A NAME="Footnote_4" HREF="#Footnote_Used_4" >4</A></SUP></DT>
<DD>extended
binary coded decimal interchange code
(siehe auch <A HREF="#HDREBCD">K.4, "EBCDIC"</A>)
</DD>
<P><DT><SUP><A NAME="Footnote_5" HREF="#Footnote_Used_5" >5</A></SUP></DT>
<DD>American National Standards Institute
(siehe auch <A HREF="#HDRANSI">K.3, "ANSI"</A>)
</DD>
<P><DT><SUP><A NAME="Footnote_6" HREF="#Footnote_Used_6" >6</A></SUP></DT>
<DD>Mit Variablen sind hier auch
komplexe Datentypen wie Strukturen gemeint.
</DD>
<P><DT><SUP><A NAME="Footnote_7" HREF="#Footnote_Used_7" >7</A></SUP></DT>
<DD>Eine Exception
ist eine, vom Betriebssystem ausgel&ouml;ste, Ausnahmebedingung,
die den Abbruch der Programmausf&uuml;hrung zur Folge hat, sofern
keine eigenen Routinen f&uuml;r die Behandlung von Exceptions
(sog. Exception Handler) geschrieben wurden. Diese Ausnahmebedingung
ist das Resultat eines Programmfehlers.
</DD>
</DL>
<A NAME="Bot_Of_Page"></A>
</BODY></HTML>
